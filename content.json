{"meta":{"title":"4eriri's blog","subtitle":null,"description":null,"author":"4eriri","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"cgctf-480小时精通c++","slug":"2018-9-21-成功搭建blog","date":"2018-09-20T16:52:52.000Z","updated":"2018-09-21T17:09:33.619Z","comments":true,"path":"2018/09/21/2018-9-21-成功搭建blog/","link":"","permalink":"http://yoursite.com/2018/09/21/2018-9-21-成功搭建blog/","excerpt":"","text":"听了大佬的话先来搭个blog，虽然啥也不会，但是可以对着教程慢慢搭，不管怎样能看见网页就行了先…… 题目来自于cgctf平台，之前一直没做出来，光是名字就让我望而却步…… ida启动！main函数伪代码如下： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int i; // [rsp+Ch] [rbp-54h] __int64 v5; // [rsp+10h] [rbp-50h] __int64 v6; // [rsp+18h] [rbp-48h] __int64 v7; // [rsp+20h] [rbp-40h] __int64 v8; // [rsp+28h] [rbp-38h] int v9; // [rsp+30h] [rbp-30h] char v10; // [rsp+34h] [rbp-2Ch] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); v5 = 7652827924304847970LL; v6 = 6588269719570178159LL; v7 = 0615273543157435660505LL; v8 = 4932672475662219355LL; v9 = 2099869557; v10 = 0; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((__int64)&amp;std::cout, (__int64)&quot;The Encrypted Flag is: &quot;); for ( i = 0; i &lt;= 35; ++i ) printf(&quot;%02x&quot;, *((unsigned __int8 *)&amp;v5 + i)); std::ostream::operator&lt;&lt;((__int64)&amp;std::cout, (__int64)std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); return 0;&#125; 很容易发现输出了加密后的flag，也就是v5-v9中的值，按r键转换成字符型，得加密flag:bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)} 进入汇编界面发现输出”The Encrypted Flag is: “前被nop了一段，应该就是加密函数。 左侧函数列表中有480个名为_X1C_CG_EncryptFunction的函数，实现output[i]^=string[i%len(string)]^i，区别就是这480个函数中的string是从“001001001”到“480480480”。所以可以知道flag经过了这480个函数的加密后，就变成了bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)}。 逆运算脚本如下： 1234567891011121314#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalfor i in range(479,-1,-1): a=key[i] for j in range(35,-1,-1): s=ord(flag[j]) s^=ord(a[j%9])^j flag=flag.replace(flag[j],chr(s),1)print flag 于是得到了flag 可能由于并不会替换字符串中特定下标处的值，所以并没有得到flag……向大佬求救尚未得到回复…… 两小时后原因没错，通过百度了一会python中字符串替换的问题，找到了正确的替换方式： 12345678910111213141516#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalflag1=list(flag)for i in range(479,-1,-1): a=key[i] for j in range(36): s=ord(flag1[j]) s^=ord(a[j%9])^j flag1[j]=chr(s)flag=&apos;&apos;.join(flag1)print flag flag get！ 通过大佬的指点终于是完成了这一道简单题，明明知道了怎么去逆运算，结果因为python不会用的原因忙了这么久……要学的太多 明天目标逆acdES","categories":[],"tags":[]}]}