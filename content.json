{"meta":{"title":"4eriri's blog","subtitle":null,"description":null,"author":"4eriri","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"cgctf-480小时精通c++","slug":"2018-9-21-成功搭建blog","date":"2018-09-20T16:52:52.000Z","updated":"2018-09-21T16:31:39.180Z","comments":true,"path":"2018/09/21/2018-9-21-成功搭建blog/","link":"","permalink":"http://yoursite.com/2018/09/21/2018-9-21-成功搭建blog/","excerpt":"","text":"啥也不会…… 听了大佬的话先来搭个blog，于是乎对着教程忙到了现在还是一知半解，不管怎样能看见网页就行了先…… ida启动！main函数伪代码如下： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int i; // [rsp+Ch] [rbp-54h] __int64 v5; // [rsp+10h] [rbp-50h] __int64 v6; // [rsp+18h] [rbp-48h] __int64 v7; // [rsp+20h] [rbp-40h] __int64 v8; // [rsp+28h] [rbp-38h] int v9; // [rsp+30h] [rbp-30h] char v10; // [rsp+34h] [rbp-2Ch] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); v5 = 7652827924304847970LL; v6 = 6588269719570178159LL; v7 = 0615273543157435660505LL; v8 = 4932672475662219355LL; v9 = 2099869557; v10 = 0; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((__int64)&amp;std::cout, (__int64)&quot;The Encrypted Flag is: &quot;); for ( i = 0; i &lt;= 35; ++i ) printf(&quot;%02x&quot;, *((unsigned __int8 *)&amp;v5 + i)); std::ostream::operator&lt;&lt;((__int64)&amp;std::cout, (__int64)std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); return 0;&#125; 发现是输出了加密后的flag，进入汇编界面发现输出”The Encrypted Flag is: “前被nop了一段，左侧函数列表中有大量名为_X1C_CG_EncryptFunction的函数，一共有480个，函数代码大致如下： 12345678910111213141516171819202122232425unsigned __int64 __fastcall __X1C_CG_EncryptFunction111666_FuncC99_Pha_(unsigned __int8 *a1, int a2)&#123; unsigned __int8 *v2; // rbx unsigned __int8 v3; // r12 _BYTE *v4; // rax char v6; // [rsp+17h] [rbp-49h] int i; // [rsp+18h] [rbp-48h] int v8; // [rsp+1Ch] [rbp-44h] char v9; // [rsp+20h] [rbp-40h] unsigned __int64 v10; // [rsp+48h] [rbp-18h] v10 = __readfsqword(0x28u); std::allocator&lt;char&gt;::allocator(&amp;v6); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v9, &quot;001001001&quot;, &amp;v6); std::allocator&lt;char&gt;::~allocator(&amp;v6); v8 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length(&amp;v9); for ( i = 0; i &lt; a2; ++i ) &#123; v2 = &amp;a1[i]; v3 = *v2; v4 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](&amp;v9, i % v8); *v2 = *v4 ^ v3 ^ i; &#125; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v9); return __readfsqword(0x28u) ^ v10; 可以发现所有的加密函数都是一样的，不同的地方只有用来加密的字符串部分，从”001001001”到”480480480”。于是推断出加密过程是从001001001开始 output[i]^=string[i%len(string)]^i逆运算脚本如下： 1234567891011121314#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalfor i in range(479,-1,-1): a=key[i] for j in range(35,-1,-1): s=ord(flag[j]) s^=ord(a[j%9])^j flag=flag.replace(flag[j],chr(s),1)print flag 于是得到了flag可能由于并不会替换字符串中特定下标处的值，所以并没有得到flag……向大佬求救尚未得到回复…… 明天目标逆acdES并了解base64","categories":[],"tags":[]}]}