{"meta":{"title":"4eriri's blog","subtitle":null,"description":null,"author":"4eriri","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"base64","slug":"base64","date":"2018-09-22T06:58:58.000Z","updated":"2018-09-22T07:05:24.117Z","comments":true,"path":"2018/09/22/base64/","link":"","permalink":"http://yoursite.com/2018/09/22/base64/","excerpt":"","text":"百度了一会base64，在吾爱破解上发现了一篇讲解很详细的文章，于是尝试自己实现base64加密 12345678910111213141516171819202122232425262728293031323334353637383940letters=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;+&apos;, &apos;/&apos;]def encode(str_input): str_output=&apos;&apos; list_input=[&apos;&#123;:0&gt;8&#125;&apos;.format(str(bin(ord(str_input[i]))).replace(&apos;0b&apos;, &apos;&apos;)) for i in range(len(str_input))] compensate=0 while list_input: list_temp=list_input[:3] while len(list_temp)%3: compensate+=1 list_temp.append(&apos;0&apos;*8) str_temp=&apos;&apos;.join(list_temp) list_str_temp=[str_temp[i:i+6] for i in [0,6,12,18]] list_str_temp=[int(i,2) for i in list_str_temp] str_output+=&apos;&apos;.join(letters[i] for i in list_str_temp) list_input=list_input[3:] str_output+=&apos;=&apos;*compensate return str_outputdef decode(str_input): str_output=&apos;&apos; list_input=[&apos;&#123;:0&gt;6&#125;&apos;.format(str(bin(letters.index(i))).replace(&apos;0b&apos;, &apos;&apos;))for i in str_input if i != &apos;=&apos;] compensate=0 for i in str_input: if i == &apos;=&apos;: compensate+=1 while list_input: list_temp=list_input[:4] str_temp=&apos;&apos;.join(list_temp) while len(str_temp)%8: str_temp=str_temp[0:-1*2*compensate] list_str_temp=[str_temp[i:i+8] for i in [0,8,16]] list_str_temp=[int(i,2) for i in list_str_temp] str_output+=&apos;&apos;.join([chr(i)for i in list_str_temp]) list_input=list_input[4:] return str_outputs=&quot;sadadsadaddasdadas&quot;d=&apos;c2FkYWRzYWRhZGRhc2RhZGFz&apos;print encode(s)print decode(d) 运行： 123sH1rkEr:desktop macbook$ python base64.pyc2FkYWRzYWRhZGRhc2RhZGFzsadadsadaddasdadas 终于是成功了，编写过程中由于字符串和list的问题总是出错，还是要多看看python","categories":[],"tags":[]},{"title":"acdES","slug":"acdES","date":"2018-09-22T01:21:17.000Z","updated":"2018-09-22T03:17:24.561Z","comments":true,"path":"2018/09/22/acdES/","link":"","permalink":"http://yoursite.com/2018/09/22/acdES/","excerpt":"","text":"f5大法好，main函数伪代码如下： 12345678910111213141516171819202122v18 = __readfsqword(0x28u); s = (char *)malloc(0x80uLL); v9 = (char *)malloc(0xC0uLL); v10 = &apos;uijizieM&apos;; v11 = &apos;goD dna &apos;; v12 = &apos; era yob&apos;; v13 = &apos;cus yrev&apos;; v14 = &apos;lufssec&apos;; v15 = 0LL; v16 = 0LL; v17 = 0LL; v3 = sub_400B64((__int64)&amp;v10, 64); srand(v3); v7 = 0LL; for ( i = 0; i &lt;= 7; ++i ) v7 = (unsigned __int8)rand() + (v7 &lt;&lt; 8); puts(&quot;Input your text:&quot;); scanf(&quot;%96s&quot;, s); v4 = strlen(s); sub_400E48((__int64)v9, (__int64)s, v4, v7); puts(v9); return 0LL; Meizijiu and Dogboy are very successful sub_400b64循环60次，v3为v10中所有字符异或结果，写脚本得到v7=-1006576376。v4=96,随后进入sub_400e48函数: 12345678910111213v6 = a3; v5 = a4; v8 = (char *)malloc(0x80uLL); if ( v6 &amp; 7 ) &#123; sub_400BA5(a2, v6, 8 - v6 % 8); v6 += 8 - v6 % 8; &#125; v9 = malloc(0x80uLL); sub_4009B9(v5, 32, (__int64)v9); for ( i = 0; i &lt; v6; i += 8 ) *(_QWORD *)&amp;v8[i] = sub_400AC3(*(_QWORD *)(i + a2), 32, (__int64)v9); return sub_400C02(a1, (__int64)v8, v6); v6=v4,v5=v7,v6&amp;7=0 if不执行 进入sub_4009B9： 12345678910111213141516v5 = a1; v4 = a3; v11 = __readfsqword(0x28u); v6 = 0; dest = malloc(0x40uLL); src = malloc(0x40uLL); sub_40086F((unsigned __int64 *)&amp;v5, (__int64)dest); for ( i = 0; i &lt; a2; ++i ) &#123; for ( j = 0; j &lt;= 63; ++j ) *((_BYTE *)src + j) = *((_BYTE *)dest + dword_6021E0[j]); memcpy(dest, src, 0x40uLL); sub_40095D(dest, &amp;v6); *(_DWORD *)(v4 + 4LL * i) = v6; &#125; return __readfsqword(0x28u) ^ v11; sub_40086f循环64次dest[i]=v7&amp;1v7&gt;&gt;=1 一个32次的大循环中 dest[i]=dest[i]+dword_6021E0[i] sub_40095D循环64次 v6*=2 v6^=dest[i] v9[i*4]=v6 返回sub400e48中","categories":[],"tags":[]},{"title":"cgctf-480小时精通c++","slug":"480小时","date":"2018-09-20T16:52:52.000Z","updated":"2018-09-22T01:20:58.359Z","comments":true,"path":"2018/09/21/480小时/","link":"","permalink":"http://yoursite.com/2018/09/21/480小时/","excerpt":"","text":"听了大佬的话先来搭个blog，虽然啥也不会，但是可以对着教程慢慢搭，不管怎样能看见网页就行了先…… 题目来自于cgctf平台，之前一直没做出来，光是名字就让我望而却步…… ida启动！main函数伪代码如下： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int i; // [rsp+Ch] [rbp-54h] __int64 v5; // [rsp+10h] [rbp-50h] __int64 v6; // [rsp+18h] [rbp-48h] __int64 v7; // [rsp+20h] [rbp-40h] __int64 v8; // [rsp+28h] [rbp-38h] int v9; // [rsp+30h] [rbp-30h] char v10; // [rsp+34h] [rbp-2Ch] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); v5 = 7652827924304847970LL; v6 = 6588269719570178159LL; v7 = 0615273543157435660505LL; v8 = 4932672475662219355LL; v9 = 2099869557; v10 = 0; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((__int64)&amp;std::cout, (__int64)&quot;The Encrypted Flag is: &quot;); for ( i = 0; i &lt;= 35; ++i ) printf(&quot;%02x&quot;, *((unsigned __int8 *)&amp;v5 + i)); std::ostream::operator&lt;&lt;((__int64)&amp;std::cout, (__int64)std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); return 0;&#125; 很容易发现输出了加密后的flag，也就是v5-v9中的值，按r键转换成字符型，得加密flag:bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)} 进入汇编界面发现输出”The Encrypted Flag is: “前被nop了一段，应该就是加密函数。 左侧函数列表中有480个名为_X1C_CG_EncryptFunction的函数，实现output[i]^=string[i%len(string)]^i，区别就是这480个函数中的string是从“001001001”到“480480480”。所以可以知道flag经过了这480个函数的加密后，就变成了bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)}。 逆运算脚本如下： 1234567891011121314#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalfor i in range(479,-1,-1): a=key[i] for j in range(35,-1,-1): s=ord(flag[j]) s^=ord(a[j%9])^j flag=flag.replace(flag[j],chr(s),1)print flag 于是得到了flag 可能由于并不会替换字符串中特定下标处的值，所以并没有得到flag……向大佬求救尚未得到回复…… 两小时后原因没错，通过百度了一会python中字符串替换的问题，找到了正确的替换方式： 12345678910111213141516#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalflag1=list(flag)for i in range(479,-1,-1): a=key[i] for j in range(36): s=ord(flag1[j]) s^=ord(a[j%9])^j flag1[j]=chr(s)flag=&apos;&apos;.join(flag1)print flag flag get！ 通过大佬的指点终于是完成了这一道简单题，明明知道了怎么去逆运算，结果因为python不会用的原因忙了这么久……要学的太多 明天目标逆acdES","categories":[],"tags":[]}]}